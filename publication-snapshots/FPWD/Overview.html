<!DOCTYPE html><html lang="en" dir="ltr"><head>
<meta charset="utf-8">
<meta name="generator" content="ReSpec 34.1.1">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<style>
dfn{cursor:pointer}
.dfn-panel{position:absolute;z-index:35;min-width:300px;max-width:500px;padding:.5em .75em;margin-top:.6em;font-family:"Helvetica Neue",sans-serif;font-size:small;background:#fff;color:#000;box-shadow:0 1em 3em -.4em rgba(0,0,0,.3),0 0 1px 1px rgba(0,0,0,.05);border-radius:2px}
.dfn-panel:not(.docked)>.caret{position:absolute;top:-9px}
.dfn-panel:not(.docked)>.caret::after,.dfn-panel:not(.docked)>.caret::before{content:"";position:absolute;border:10px solid transparent;border-top:0;border-bottom:10px solid #fff;top:0}
.dfn-panel:not(.docked)>.caret::before{border-bottom:9px solid #a2a9b1}
.dfn-panel *{margin:0}
.dfn-panel b{display:block;color:#000;margin-top:.25em}
.dfn-panel ul a[href]{color:#333}
.dfn-panel>div{display:flex}
.dfn-panel a.self-link{font-weight:700;margin-right:auto}
.dfn-panel .marker{padding:.1em;margin-left:.5em;border-radius:.2em;text-align:center;white-space:nowrap;font-size:90%;color:#040b1c}
.dfn-panel .marker.dfn-exported{background:#d1edfd;box-shadow:0 0 0 .125em #1ca5f940}
.dfn-panel .marker.idl-block{background:#8ccbf2;box-shadow:0 0 0 .125em #0670b161}
.dfn-panel a:not(:hover){text-decoration:none!important;border-bottom:none!important}
.dfn-panel a[href]:hover{border-bottom-width:1px}
.dfn-panel ul{padding:0}
.dfn-panel li{margin-left:1em}
.dfn-panel.docked{position:fixed;left:.5em;top:unset;bottom:2em;margin:0 auto;max-width:calc(100vw - .75em * 2 - .5em - .2em * 2);max-height:30vh;overflow:auto}
</style>
    
    
<title>SPARQL 1.2 Entailment Regimes</title>

    
<style id="respec-mainstyle">
@keyframes pop{
0%{transform:scale(1,1)}
25%{transform:scale(1.25,1.25);opacity:.75}
100%{transform:scale(1,1)}
}
:is(h1,h2,h3,h4,h5,h6,a) abbr{border:none}
dfn{font-weight:700}
a.internalDFN{color:inherit;border-bottom:1px solid #99c;text-decoration:none}
a.externalDFN{color:inherit;border-bottom:1px dotted #ccc;text-decoration:none}
a.bibref{text-decoration:none}
.respec-offending-element:target{animation:pop .25s ease-in-out 0s 1}
.respec-offending-element,a[href].respec-offending-element{text-decoration:red wavy underline}
@supports not (text-decoration:red wavy underline){
.respec-offending-element:not(pre){display:inline-block}
.respec-offending-element{background:url(data:image/gif;base64,R0lGODdhBAADAPEAANv///8AAP///wAAACwAAAAABAADAEACBZQjmIAFADs=) bottom repeat-x}
}
#references :target{background:#eaf3ff;animation:pop .4s ease-in-out 0s 1}
cite .bibref{font-style:normal}
a[href].orcid{padding-left:4px;padding-right:4px}
a[href].orcid>svg{margin-bottom:-2px}
.toc a,.tof a{text-decoration:none}
a .figno,a .secno{color:#000}
ol.tof,ul.tof{list-style:none outside none}
.caption{margin-top:.5em;font-style:italic}
table.simple{border-spacing:0;border-collapse:collapse;border-bottom:3px solid #005a9c}
.simple th{background:#005a9c;color:#fff;padding:3px 5px;text-align:left}
.simple th a{color:#fff;padding:3px 5px;text-align:left}
.simple th[scope=row]{background:inherit;color:inherit;border-top:1px solid #ddd}
.simple td{padding:3px 10px;border-top:1px solid #ddd}
.simple tr:nth-child(even){background:#f0f6ff}
.section dd>p:first-child{margin-top:0}
.section dd>p:last-child{margin-bottom:0}
.section dd{margin-bottom:1em}
.section dl.attrs dd,.section dl.eldef dd{margin-bottom:0}
#issue-summary>ul{column-count:2}
#issue-summary li{list-style:none;display:inline-block}
details.respec-tests-details{margin-left:1em;display:inline-block;vertical-align:top}
details.respec-tests-details>*{padding-right:2em}
details.respec-tests-details[open]{z-index:999999;position:absolute;border:thin solid #cad3e2;border-radius:.3em;background-color:#fff;padding-bottom:.5em}
details.respec-tests-details[open]>summary{border-bottom:thin solid #cad3e2;padding-left:1em;margin-bottom:1em;line-height:2em}
details.respec-tests-details>ul{width:100%;margin-top:-.3em}
details.respec-tests-details>li{padding-left:1em}
.self-link:hover{opacity:1;text-decoration:none;background-color:transparent}
aside.example .marker>a.self-link{color:inherit}
.header-wrapper{display:flex;align-items:baseline}
:is(h2,h3,h4,h5,h6):not(#toc>h2,#abstract>h2,#sotd>h2,.head>h2){position:relative;left:-.5em}
:is(h2,h3,h4,h5,h6):not(#toch2)+a.self-link{color:inherit;order:-1;position:relative;left:-1.1em;font-size:1rem;opacity:.5}
:is(h2,h3,h4,h5,h6)+a.self-link::before{content:"§";text-decoration:none;color:var(--heading-text)}
:is(h2,h3)+a.self-link{top:-.2em}
:is(h4,h5,h6)+a.self-link::before{color:#000}
@media (max-width:767px){
dd{margin-left:0}
}
@media print{
.removeOnSave{display:none}
}
</style>
    
    

    

    
<style>

      /* @import url("local.css"); */
      /* Inlined to make preview work */

/* CSS For SPARQL Query */

/* In-progress working draft artifacts - to be removed eventually */
  .issue	{ background-color: #fdd;
                  font-size: 88% ; }
  .add		{ background-color: #7fff7f }
  .remove	{ background-color: #ff7f7f }
ul.issue	{}
  .issueBlock	{ margin: 1em 4em 1em 2.5em ; /* Top Right Bottom Left */
                  padding: 1ex;
	          /*overflow: auto;*/
                  page-break-inside: avoid ; }
  .issueTopic	{ font-weight: bold ; }

 .todo		{ font-size: 80% ; color: #444 ; }
p.todo		{}

.wgNote	{ border: 0.2em solid red;
      padding: 0.5em ;
      margin: 1em 4em 1em 2em ; }

.box     { border: thin solid #888888;
           page-break-inside: avoid ;
           background-color: #F8F8F8 ; padding:1em ;
           margin-left:0 ; margin-right: 2ex; 
           margin-top: 0.1ex ; margin-bottom: 0.1ex ;
         }

/* Misc WD stuff */
span.cvs-id     {color: gray; font-size:80%; display: block; }

/* == General Tag Treatment == */
pre		 { margin: 1em 4em 1em 2.5em ; /* Top Right Bottom Left */
                   padding: 1ex;
	           /*overflow: auto;*/
                   page-break-inside: avoid ; }

/* Tables */
table, td	{ text-align: left; }
td, th   { border-style: solid;
                  border-width: 1px;
                  border-color: black;
                  border-bottom-color: gray;
                  border-right-color: gray; }
td.annotation, th.annotation { border-style: none; border-bottom-style: dotted; }
table.plain	{ border-spacing: 0px; padding: 0px ; border-collapse: collapse ; }
                  /* cellpadding="0" cellspacing="1" style="border-collapse: collapse */


th.major	{ background-color: #005a9c;
                  color: white; }
.subHeading	{ text-align: left;
                  background-color: #CCCCCC; }
th, td		{ padding: 3px; }
td		{ font-size: 85%; }
th a:link	{ text-decoration: none; }
th a:hover	{ background-color:#FFFF99;
                  text-decoration: underline; }

/* == Prototypes == */
pre.prototype	{ background-color:#f7f8ff;
                  border:thin solid #8888aa;
                  margin: 1em 4em 1em 0em ; }
.return, .type	{ color: #177 }

/* == Notes ==  */
.note		{ margin-left: 2.5em; margin-right: 4ex ; font-size: 85% ; font-style: italic ; }

/* Definitions */
.defn		{ margin-left:0 ; margin-right: 2ex; 
                  margin-top: 0.1ex ; margin-bottom: 0.1ex ;
                  /*border: double 1px #888888; *//* Buggy */
                  border: thin solid #888888;
                  padding: 1ex 2ex 0.5ex 2ex ; /* top, right, bottom, left */
                  page-break-inside: avoid ;
                  background-color: #F0F8F8 ; }
div.defn p	{ margin-top: 1ex ; margin-bottom: 1.5ex ;}
div.defn ul	{ margin-top: 1ex ; margin-bottom: 1.5ex ; }
@media print	{ .defn { margin: 1em 1em 1em 1em ; } }
span.definedTerm	{font-weight: bold;}

div.grammarExtract
                { border: thin solid #888888;
                  padding: 1ex 2ex 1ex 2ex ; /* top, right, bottom, left */
                  margin: 1em 6em 1em 2em ; 
                  page-break-inside: avoid ;
                  background-color: #F8F8F8 ; }

pre.codeBlock  { font-family:monospace ; page-break-inside: avoid ; 
                 margin: 0 ;
	         margin-right: 2ex ;
                 border: thin solid #888888; }




/* Examples */
pre.data	{ border: thin solid #88AA88;
                  background-color: #E8F0E8;
                  margin: 1em 4em 1em 0em ; }

pre.dataExcerpt	{ border: thin solid #88AA88;
                  background-color: #E8F0E8;
                  margin: 1em 4em 1em 0em ; }
/* Example Queries */
.query          { background-color:#f7f8ff; }
.queryExcerpt   { background-color:#f7f8ff; }
pre.query	{ border:thin solid #8888aa;
                  margin: 1em 4em 1em 0em ; }
/* Example Results */
.result		{ border: thin solid  #888888 ;
                  background-color: #F0F0F0 ; }
pre.resultGraph	{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }
pre.resultSet	{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }
pre.resultAsk	{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }
pre.resultTurtle{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }

pre.result	{ margin: 1em 4em 1em 0em ; }

div.result	{ font-family: monospace;
                  margin:  1em 4em 1em 0em ;
                  padding: 1ex ; }

.result table	{ border-collapse: collapse; }
.result table td{ border-width: 1px ;
                  border-color : black ; 
                  font-family: monospace ;
                  empty-cells: show;
                  padding-left: 1ex ; padding-right: 1ex ;
                  vertical-align:top;
                  text-align: left ; } 
/*  spacing: 0 ;*/
.result table th{ border-width: 1px ;
                  font-family: monospace ;
                  border-color: black ;
                  empty-cells: show;
                  padding-left: 1ex ; padding-right: 1ex ;
                  vertical-align:top;
                  text-align:center; } 

/* Examples : Algebra */
div.algExample {  border: thin solid #888888;
                  page-break-inside: avoid ;
                  padding:0.5em ; margin:0.5em ;
                  margin-left: 2em ; margin-right: 2em ;
                  font-family:monospace ; }

div.algExample1 { padding:0.5em ; background-color: #F0F0FF ; }
div.algExample2 { padding:0.5em ; margin-top: 0.5em ; background-color: #F0FFF0 ; }

/* Grammar Mark-up */
.operator	{ color: #3f3f5f;
                  text-transform: uppercase; }
.function	{ color: #3f3f5f;
                }

/* Tuned to cope with different browsers behaviours */
div.grammarTable table	{ border-style: solid ;
			  border-width: 1px ;
			  border-color: #AAA ;
			  border-spacing: 0px ; 
			  border-collapse: collapse ; }

div.grammarTable table * { border-left-width: 0px ;
			   border-right-width: 0px ;
			   border-color: #AAA ; } 

div.grammarTable table * tr   { border-top-style: solid ;
			  border-top-width: 1px ;
			  border-top-color: #AAA ; } 

.grammar	{ text-align: left ;
                  vertical-align: top ; }
.token		{ color: #3f3f5f; }
table.FAndOTable .token		{ color: #00c; }
table.FAndOTable .token:visited		{ color: #a0c; }
.gRuleHead	{ font-style: italic ;
                  font-family: monospace ; }
.gRuleBody	{ font-family: monospace ; }
.gRuleLabel	{ font-family: monospace ; }

.code		{ font-family: monospace; font-size: 100%; }
pre.code	{ font-family: monospace; font-size: 100%; margin: 0 ; }

/* Table of Contents */
.toc		{ text-indent: 0; }
DIV.toc UL UL, DIV.toc OL OL {margin-left: 0}
DIV.toc UL UL UL, DIV.toc OL OL OL {margin-left: 1em}
DIV.toc UL UL UL UL, DIV.toc OL OL OL OL {margin-left: 0}
LI.tocline1	{ font-weight: bold}
LI.tocline2	{ font-weight: normal}
LI.tocline4	{ font-style: italic}
/* The border in the following rule crashes NN4 on fonts.html :-(
DIV.subtoc	{ padding: 1em; border: solid black thin; margin: 1em 0;
                  background: #ddd} */
DIV.toc, UL.index, DT { text-align: left; }


/* References to the Rdf Data Model */
span.rdfDM	{ color: #11d; }


/* Truth Table */
  .truth	{ font-family: monospace; }
  .error	{ color: #ff1f1f; }
  table.truthTable td	{ text-align: center; font-family: monospace; }
  table.truthTable th	{ background-color: #dfdfdf; }
  table.truthTable tbody th	{ font-weight: normal; font-family: monospace; }

/* Casting table */
table.casting	{ font-size: x-small; }

.castY	{ background-color: #7FFF7F;
                  color: black; }

.castN	{ background-color: #FF7F7F;
                  color: black; }

.castM	{ background-color: white;
                  color: black; }

span.cancast:hover { background-color: #ffa;
                     color: black; }

.SPARQLoperator	{ background-color: #FFFFbf; /* yellow */
          }

.owlnonterminal {
    font-weight: bold;
    font-family: sans-serif;
    font-size: 95%;
}
.owlgrammar {
    margin-top: 1ex;
    margin-bottom: 1ex;
    padding-left: 1ex;
    padding-right: 1ex;
    padding-top: 1ex;
    padding-bottom: 0.6ex;
    border: 1px dashed #2f6fab;
    font-family: monospace;
}

      /* ReSpec */
      dfn { font-style: normal ; }
      /* ReSpec */

  code           { font-family: monospace; }

  div.constraint,
  div.issue,
  div.note,
  div.notice     { margin-left: 2em; }

  ol.enumar      { list-style-type: decimal; }
  ol.enumla      { list-style-type: lower-alpha; }
  ol.enumlr      { list-style-type: lower-roman; }
  ol.enumua      { list-style-type: upper-alpha; }
  ol.enumur      { list-style-type: upper-roman; }


  div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
  div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
  div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
  div.exampleWrapper { margin: 4px }
  div.exampleHeader { font-weight: bold;
                    margin: 4px}

  em.rfc2119 { text-transform: lowercase;
             font-variant: small-caps;
             font-style: normal; }
    
</style>
  
<style>
ul.index{columns:30ch;column-gap:1.5em}
ul.index li{list-style:inherit}
ul.index li span{color:inherit;cursor:pointer;white-space:normal}
#index-defined-here ul.index li{font-size:.9rem}
ul.index code{color:inherit}
#index-defined-here .print-only{display:none}
@media print{
#index-defined-here .print-only{display:initial}
}
</style>
<meta name="description" content="SPARQL is a query language and a protocol for data that is stored natively as RDF or viewed as RDF via middleware. The main mechanism for computing query results in SPARQL is subgraph
    matching: RDF triples in both the queried RDF data and the query pattern are interpreted as nodes and edges of directed graphs, and the resulting query graph is matched to the data graph using
    variables as wild cards. Various W3C standards, including RDF 1.2 Concepts and Abstract Syntax [RDF12-CONCEPTS] and OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition) [OWL2-MAPPING-TO-RDF], provide semantic
    interpretations for RDF graphs that allow additional RDF statements to be inferred from explicitly given assertions. Many applications that rely on these semantics require a query language such
    as SPARQL, but in order to use SPARQL, basic graph pattern matching has to be defined using semantic entailment relations instead of explicitly given graph structures. There are different
    possible ways of defining a basic graph pattern matching extension for an entailment relation. This document specifies one such way for a range of standard semantic web entailment relations. Such
    extensions of the SPARQL semantics are called entailment regimes within this document. An entailment regime defines not only which entailment relation is used, but also which queries and
    graphs are well-formed for the regime, how the entailment is used (since there are potentially different meaningful ways to use the same entailment relation), and what kinds of errors can arise.
    The entailment relations used in this document are standard entailment relations in the semantic web: RDF entailment, RDFS entailment, D-entailment, OWL Direct and RDF-Based Semantics entailment,
    and RIF Core entailment.">
<link rel="canonical" href="https://www.w3.org/TR/sparql12-entailment/">
<script type="application/ld+json">{
  "@context": [
    "http://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "w3p": "http://www.w3.org/2001/02pd/rec54#",
      "foaf": "http://xmlns.com/foaf/0.1/",
      "datePublished": {
        "@type": "http://www.w3.org/2001/XMLSchema#date"
      },
      "inLanguage": {
        "@language": null
      },
      "isBasedOn": {
        "@type": "@id"
      },
      "license": {
        "@type": "@id"
      }
    }
  ],
  "id": "https://www.w3.org/TR/sparql12-entailment/",
  "type": [
    "TechArticle"
  ],
  "name": "SPARQL 1.2 Entailment Regimes",
  "inLanguage": "en",
  "license": "https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document",
  "datePublished": "2023-06-06",
  "copyrightHolder": {
    "name": "World Wide Web Consortium",
    "url": "https://www.w3.org/"
  },
  "discussionUrl": "https://github.com/w3c/sparql-entailment/issues/",
  "alternativeHeadline": "",
  "isBasedOn": "https://www.w3.org/TR/2013/REC-sparql12-entailment-20130321/",
  "description": "SPARQL is a query language and a protocol for data that is stored natively as RDF or viewed as RDF via middleware. The main mechanism for computing query results in SPARQL is subgraph\n    matching: RDF triples in both the queried RDF data and the query pattern are interpreted as nodes and edges of directed graphs, and the resulting query graph is matched to the data graph using\n    variables as wild cards. Various W3C standards, including RDF 1.2 Concepts and Abstract Syntax [RDF12-CONCEPTS] and OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition) [OWL2-MAPPING-TO-RDF], provide semantic\n    interpretations for RDF graphs that allow additional RDF statements to be inferred from explicitly given assertions. Many applications that rely on these semantics require a query language such\n    as SPARQL, but in order to use SPARQL, basic graph pattern matching has to be defined using semantic entailment relations instead of explicitly given graph structures. There are different\n    possible ways of defining a basic graph pattern matching extension for an entailment relation. This document specifies one such way for a range of standard semantic web entailment relations. Such\n    extensions of the SPARQL semantics are called entailment regimes within this document. An entailment regime defines not only which entailment relation is used, but also which queries and\n    graphs are well-formed for the regime, how the entailment is used (since there are potentially different meaningful ways to use the same entailment relation), and what kinds of errors can arise.\n    The entailment relations used in this document are standard entailment relations in the semantic web: RDF entailment, RDFS entailment, D-entailment, OWL Direct and RDF-Based Semantics entailment,\n    and RIF Core entailment.",
  "editor": [
    {
      "type": "Person",
      "name": "Peter Patel-Schneider"
    }
  ],
  "contributor": [],
  "citation": [
    {
      "id": "https://w3c.github.io/sparql-query/spec/",
      "type": "TechArticle",
      "name": "SPARQL 1.2 Query Language",
      "url": "https://w3c.github.io/sparql-query/spec/",
      "creator": [
        {
          "name": "Steven Harris"
        },
        {
          "name": "Andy Seaborne"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://w3c.github.io/rdf-turtle/spec/",
      "type": "TechArticle",
      "name": "RDF 1.2 Turtle",
      "url": "https://w3c.github.io/rdf-turtle/spec/",
      "creator": [
        {
          "name": "Eric Prud'hommeaux"
        },
        {
          "name": "Gavin Carothers"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://w3c.github.io/rdf-semantics/spec/",
      "type": "TechArticle",
      "name": "RDF 1.2 Semantics",
      "url": "https://w3c.github.io/rdf-semantics/spec/",
      "creator": [
        {
          "name": "Patrick Hayes"
        },
        {
          "name": "Peter Patel-Schneider"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/xmlschema11-2/",
      "type": "TechArticle",
      "name": "W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes",
      "url": "https://www.w3.org/TR/xmlschema11-2/",
      "creator": [
        {
          "name": "David Peterson"
        },
        {
          "name": "Sandy Gao"
        },
        {
          "name": "Ashok Malhotra"
        },
        {
          "name": "Michael Sperberg-McQueen"
        },
        {
          "name": "Henry Thompson"
        },
        {
          "name": "Paul V. Biron"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/owl2-rdf-based-semantics/",
      "type": "TechArticle",
      "name": "OWL 2 Web Ontology Language RDF-Based Semantics (Second Edition)",
      "url": "https://www.w3.org/TR/owl2-rdf-based-semantics/",
      "creator": [
        {
          "name": "Michael Schneider"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/owl2-profiles/",
      "type": "TechArticle",
      "name": "OWL 2 Web Ontology Language Profiles (Second Edition)",
      "url": "https://www.w3.org/TR/owl2-profiles/",
      "creator": [
        {
          "name": "Boris Motik"
        },
        {
          "name": "Bernardo Cuenca Grau"
        },
        {
          "name": "Ian Horrocks"
        },
        {
          "name": "Zhe Wu"
        },
        {
          "name": "Achille Fokoue"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/owl2-conformance/",
      "type": "TechArticle",
      "name": "OWL 2 Web Ontology Language Conformance (Second Edition)",
      "url": "https://www.w3.org/TR/owl2-conformance/",
      "creator": [
        {
          "name": "Michael[tm] Smith"
        },
        {
          "name": "Ian Horrocks"
        },
        {
          "name": "Markus Krötzsch"
        },
        {
          "name": "Birte Glimm"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/owl2-syntax/",
      "type": "TechArticle",
      "name": "OWL 2 Web Ontology Language Structural Specification and Functional-Style Syntax (Second Edition)",
      "url": "https://www.w3.org/TR/owl2-syntax/",
      "creator": [
        {
          "name": "Boris Motik"
        },
        {
          "name": "Peter Patel-Schneider"
        },
        {
          "name": "Bijan Parsia"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/owl2-mapping-to-rdf/",
      "type": "TechArticle",
      "name": "OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition)",
      "url": "https://www.w3.org/TR/owl2-mapping-to-rdf/",
      "creator": [
        {
          "name": "Peter Patel-Schneider"
        },
        {
          "name": "Boris Motik"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/owl2-direct-semantics/",
      "type": "TechArticle",
      "name": "OWL 2 Web Ontology Language Direct Semantics (Second Edition)",
      "url": "https://www.w3.org/TR/owl2-direct-semantics/",
      "creator": [
        {
          "name": "Boris Motik"
        },
        {
          "name": "Peter Patel-Schneider"
        },
        {
          "name": "Bernardo Cuenca Grau"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/rif-rdf-owl/",
      "type": "TechArticle",
      "name": "RIF RDF and OWL Compatibility (Second Edition)",
      "url": "https://www.w3.org/TR/rif-rdf-owl/",
      "creator": [
        {
          "name": "Jos de Bruijn"
        },
        {
          "name": "Christopher Welty"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/rif-owl-rl/",
      "type": "TechArticle",
      "name": "OWL 2 RL in RIF (Second Edition)",
      "url": "https://www.w3.org/TR/rif-owl-rl/",
      "creator": [
        {
          "name": "Dave Reynolds"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/rif-core/",
      "type": "TechArticle",
      "name": "RIF Core Dialect (Second Edition)",
      "url": "https://www.w3.org/TR/rif-core/",
      "creator": [
        {
          "name": "Harold Boley"
        },
        {
          "name": "Gary Hallmark"
        },
        {
          "name": "Michael Kifer"
        },
        {
          "name": "Adrian Paschke"
        },
        {
          "name": "Axel Polleres"
        },
        {
          "name": "Dave Reynolds"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/rif-in-rdf/",
      "type": "TechArticle",
      "name": "RIF In RDF (Second Edition)",
      "url": "https://www.w3.org/TR/rif-in-rdf/",
      "creator": [
        {
          "name": "Sandro Hawke"
        },
        {
          "name": "Axel Polleres"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.rfc-editor.org/rfc/rfc2119",
      "type": "TechArticle",
      "name": "Key words for use in RFCs to Indicate Requirement Levels",
      "url": "https://www.rfc-editor.org/rfc/rfc2119",
      "creator": [
        {
          "name": "S. Bradner"
        }
      ],
      "publisher": {
        "name": "IETF"
      }
    },
    {
      "id": "https://www.rfc-editor.org/rfc/rfc8174",
      "type": "TechArticle",
      "name": "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words",
      "url": "https://www.rfc-editor.org/rfc/rfc8174",
      "creator": [
        {
          "name": "B. Leiba"
        }
      ],
      "publisher": {
        "name": "IETF"
      }
    },
    {
      "id": "https://w3c.github.io/rdf-concepts/spec/",
      "type": "TechArticle",
      "name": "RDF 1.2 Concepts and Abstract Syntax",
      "url": "https://w3c.github.io/rdf-concepts/spec/",
      "creator": [
        {
          "name": "Richard Cyganiak"
        },
        {
          "name": "David Wood"
        },
        {
          "name": "Markus Lanthaler"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://w3c.github.io/sparql-protocol/spec/",
      "type": "TechArticle",
      "name": "SPARQL 1.2 Protocol",
      "url": "https://w3c.github.io/sparql-protocol/spec/",
      "creator": [
        {
          "name": "Lee Feigenbaum"
        },
        {
          "name": "Gregory Williams"
        },
        {
          "name": "Kendall Clark"
        },
        {
          "name": "Elias Torres"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/rif-bld/",
      "type": "TechArticle",
      "name": "RIF Basic Logic Dialect (Second Edition)",
      "url": "https://www.w3.org/TR/rif-bld/",
      "creator": [
        {
          "name": "Harold Boley"
        },
        {
          "name": "Michael Kifer"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://www.w3.org/TR/owl2-overview/",
      "type": "TechArticle",
      "name": "OWL 2 Web Ontology Language Document Overview (Second Edition)",
      "url": "https://www.w3.org/TR/owl2-overview/",
      "creator": [
        {
          "name": "W3C OWL Working Group"
        }
      ],
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://dx.doi.org/10.2139/ssrn.3199251",
      "type": "TechArticle",
      "name": "Completeness, Decidability and Complexity of Entailment for RDF Schema and a Semantic Extension Involving the OWL Vocabulary",
      "url": "https://dx.doi.org/10.2139/ssrn.3199251",
      "creator": [
        {
          "name": "Herman J. ter Horst"
        }
      ],
      "publisher": {
        "name": "Journal of Web Semantics"
      }
    },
    {
      "id": "http://arxiv.org/abs/cs.LO/9809032",
      "type": "TechArticle",
      "name": "Saftety of recursive horn clauses with infinite relations",
      "url": "http://arxiv.org/abs/cs.LO/9809032",
      "creator": [
        {
          "name": "R. Ramakrishnan"
        },
        {
          "name": "F. Bancilhon"
        },
        {
          "name": "A. Silberschatz"
        }
      ],
      "publisher": {
        "name": "ACM New York"
      }
    },
    {
      "id": "https://w3c.github.io/sparql-update/spec/",
      "type": "TechArticle",
      "name": "SPARQL 1.2 Update",
      "url": "https://w3c.github.io/sparql-update/spec/",
      "creator": [
        {
          "name": "Paula Gearon"
        },
        {
          "name": "Alexandre Passant"
        },
        {
          "name": "Axel Polleres"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://w3c.github.io/sparql-graph-store-protocol/spec/",
      "type": "TechArticle",
      "name": "SPARQL 1.2 Graph Store HTTP Protocol",
      "url": "https://w3c.github.io/sparql-graph-store-protocol/spec/",
      "creator": [
        {
          "name": "Chimezie Ogbuji"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://w3c.github.io/sparql-new/spec/",
      "type": "TechArticle",
      "name": "What’s New in SPARQL 1.2",
      "url": "https://w3c.github.io/sparql-new/spec/",
      "creator": [
        {
          "name": "The W3C RDF-star Working Group"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://w3c.github.io/sparql-concepts/spec/",
      "type": "TechArticle",
      "name": "SPARQL 1.2 Concepts",
      "url": "https://w3c.github.io/sparql-concepts/spec/",
      "creator": [
        {
          "name": "The W3C RDF-star Working Group"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://w3c.github.io/sparql-service-description/spec/",
      "type": "TechArticle",
      "name": "SPARQL 1.2 Service Description",
      "url": "https://w3c.github.io/sparql-service-description/spec/",
      "creator": [
        {
          "name": "Gregory Williams"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://w3c.github.io/sparql-federated-query/spec/",
      "type": "TechArticle",
      "name": "SPARQL 1.2 Federated Query",
      "url": "https://w3c.github.io/sparql-federated-query/spec/",
      "creator": [
        {
          "name": "Eric Prud'hommeaux"
        },
        {
          "name": "Carlos Buil Aranda"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://w3c.github.io/sparql-results-json/spec/",
      "type": "TechArticle",
      "name": "SPARQL 1.2 Query Results JSON Format",
      "url": "https://w3c.github.io/sparql-results-json/spec/",
      "creator": [
        {
          "name": "Andy Seaborne"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://w3c.github.io/sparql-results-csv-tsv/spec/",
      "type": "TechArticle",
      "name": "SPARQL 1.2 Query Results CSV and TSV Formats",
      "url": "https://w3c.github.io/sparql-results-csv-tsv/spec/",
      "creator": [
        {
          "name": "Andy Seaborne"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    },
    {
      "id": "https://w3c.github.io/sparql-results-xml/spec/",
      "type": "TechArticle",
      "name": "SPARQL 1.2 Query Results XML Formats",
      "url": "https://w3c.github.io/sparql-results-xml/spec/",
      "creator": [
        {
          "name": "Sandro Hawke"
        },
        {
          "name": "Dave Beckett"
        },
        {
          "name": "Jeen Broekstra"
        }
      ],
      "publishedDate": "2022-01-01",
      "publisher": {
        "name": "W3C"
      }
    }
  ]
}</script>
<style>
.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}
.hljs-comment,.hljs-quote{color:#717277;font-style:italic}
.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}
.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#ca4706;font-weight:700}
.hljs-literal{color:#0b76c5}
.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#42803c}
.hljs-built_in,.hljs-class .hljs-title{color:#9a6a01}
.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}
.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#336ae3}
.hljs-emphasis{font-style:italic}
.hljs-strong{font-weight:700}
.hljs-link{text-decoration:underline}
</style>
<style>
var{position:relative;cursor:pointer}
var[data-type]::after,var[data-type]::before{position:absolute;left:50%;top:-6px;opacity:0;transition:opacity .4s;pointer-events:none}
var[data-type]::before{content:"";transform:translateX(-50%);border-width:4px 6px 0 6px;border-style:solid;border-color:transparent;border-top-color:#000}
var[data-type]::after{content:attr(data-type);transform:translateX(-50%) translateY(-100%);background:#000;text-align:center;font-family:"Dank Mono","Fira Code",monospace;font-style:normal;padding:6px;border-radius:3px;color:#daca88;text-indent:0;font-weight:400}
var[data-type]:hover::after,var[data-type]:hover::before{opacity:1}
</style>
<script id="initialUserConfig" type="application/json">{
  "specStatus": "FPWD",
  "edDraftURI": "https://w3c.github.io/sparql-entailment/spec/",
  "testSuiteURI": "https://w3c.github.io/rdf-tests/",
  "shortName": "sparql12-entailment",
  "copyrightStart": "2012",
  "previousPublishDate": "2013-03-21",
  "previousMaturity": "REC",
  "prevRecShortname": "sparql11-entailment",
  "editors": [
    {
      "name": "Peter Patel-Schneider",
      "w3cid": "13382"
    }
  ],
  "formerEditors": [
    {
      "name": "Birte Glimm"
    },
    {
      "name": "Chimezie Ogbuji"
    }
  ],
  "github": "https://github.com/w3c/sparql-entailment",
  "group": "rdf-star",
  "doJsonLd": true,
  "wgPublicList": "public-rdf-star-wg",
  "localBiblio": {
    "ISO24707": {
      "id": "ISO24707",
      "title": "Information technology — Common Logic (CL) — A framework for a family of logic-based languages",
      "date": "2018-07",
      "href": "https://www.iso.org/standard/66249.html",
      "status": "Published",
      "publisher": "ISO/EIC"
    },
    "HORST04": {
      "id": "HORST04",
      "title": "Extending the RDFS Entailment Lemma",
      "authors": [
        "Herman J. ter Horst"
      ],
      "date": "2004",
      "isbn": "978-3-540-30475-3",
      "href": "https://doi.org/10.1007/978-3-540-30475-3_7",
      "status": "Conference Proceeding",
      "publisher": "Springer, Berlin, Heidelberg"
    },
    "HORST05": {
      "id": "HORST05",
      "title": "Completeness, Decidability and Complexity of Entailment for RDF Schema and a Semantic Extension Involving the OWL Vocabulary",
      "authors": [
        "Herman J. ter Horst"
      ],
      "date": "2005",
      "href": "https://dx.doi.org/10.2139/ssrn.3199251",
      "status": "Conference Proceeding",
      "publisher": "Journal of Web Semantics"
    },
    "SAFETY": {
      "title": "Saftety of recursive horn clauses with infinite relations",
      "href": "http://arxiv.org/abs/cs.LO/9809032",
      "authors": [
        "R. Ramakrishnan",
        "F. Bancilhon",
        "A. Silberschatz"
      ],
      "date": "1987",
      "publisher": "ACM New York",
      "id": "safety"
    },
    "STRIPEDRDF": {
      "id": "STRIPEDRDF",
      "title": "RDF: Understanding the Striped RDF/XML Syntax",
      "editors": [
        "D. Brickley"
      ],
      "date": "2001",
      "href": "http://www.w3.org/2001/10/stripes/",
      "status": "Team Submission",
      "publisher": "W3C"
    },
    "RDF12-CONCEPTS": {
      "authors": [
        "Richard Cyganiak",
        "David Wood",
        "Markus Lanthaler"
      ],
      "href": "https://w3c.github.io/rdf-concepts/spec/",
      "title": "RDF 1.2 Concepts and Abstract Syntax",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "rdf12-concepts"
    },
    "RDF12-SEMANTICS": {
      "authors": [
        "Patrick Hayes",
        "Peter Patel-Schneider"
      ],
      "href": "https://w3c.github.io/rdf-semantics/spec/",
      "title": "RDF 1.2 Semantics",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "rdf12-semantics"
    },
    "RDF12-N-QUADS": {
      "authors": [
        "Gavin Carothers"
      ],
      "href": "https://w3c.github.io/rdf-n-quads/spec/",
      "title": "RDF 1.2 N-Quads",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C"
    },
    "RDF12-N-TRIPLES": {
      "authors": [
        "Gavin Carothers",
        "Andy Seaborne"
      ],
      "href": "https://w3c.github.io/rdf-n-triples/spec/",
      "title": "RDF 1.2 N-Triples",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C"
    },
    "RDF12-NEW": {
      "authors": [
        "David Wood"
      ],
      "href": "https://w3c.github.io/rdf-new/spec/",
      "title": "What’s New in RDF 1.2",
      "rawDate": "2022-01-01",
      "status": "DNOTE",
      "publisher": "W3C"
    },
    "RDF12-PRIMER": {
      "authors": [
        "Guus Schreiber",
        "Yves Raimond"
      ],
      "href": "https://w3c.github.io/rdf-primer/spec/",
      "title": "RDF 1.2 Primer",
      "rawDate": "2022-01-01",
      "status": "DNOTE",
      "publisher": "W3C"
    },
    "RDF12-SCHEMA": {
      "authors": [
        "Dan Brickley",
        "Ramanathan Guha"
      ],
      "href": "https://w3c.github.io/rdf-schema/spec/",
      "title": "RDF 1.2 Schema",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C"
    },
    "RDF12-TRIG": {
      "authors": [
        "Gavin Carothers",
        "Andy Seaborne"
      ],
      "href": "https://w3c.github.io/rdf-trig/spec/",
      "title": "RDF 1.2 TriG",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C"
    },
    "RDF12-TURTLE": {
      "authors": [
        "Eric Prud'hommeaux",
        "Gavin Carothers"
      ],
      "href": "https://w3c.github.io/rdf-turtle/spec/",
      "title": "RDF 1.2 Turtle",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "rdf12-turtle"
    },
    "RDF12-XML": {
      "authors": [
        "Fabien Gandon",
        "Guus Schreiber"
      ],
      "href": "https://w3c.github.io/rdf-xml/spec/",
      "title": "RDF 1.2 XML Syntax",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C"
    },
    "SPARQL12-NEW": {
      "authors": [
        "The W3C RDF-star Working Group"
      ],
      "href": "https://w3c.github.io/sparql-new/spec/",
      "title": "What’s New in SPARQL 1.2",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "sparql12-new"
    },
    "SPARQL12-CONCEPTS": {
      "authors": [
        "The W3C RDF-star Working Group"
      ],
      "href": "https://w3c.github.io/sparql-concepts/spec/",
      "title": "SPARQL 1.2 Concepts",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "sparql12-concepts"
    },
    "SPARQL12-QUERY": {
      "authors": [
        "Steven Harris",
        "Andy Seaborne"
      ],
      "href": "https://w3c.github.io/sparql-query/spec/",
      "title": "SPARQL 1.2 Query Language",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "sparql12-query"
    },
    "SPARQL12-UPDATE": {
      "authors": [
        "Paula Gearon",
        "Alexandre Passant",
        "Axel Polleres"
      ],
      "href": "https://w3c.github.io/sparql-update/spec/",
      "title": "SPARQL 1.2 Update",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "sparql12-update"
    },
    "SPARQL12-SERVICE-DESCRIPTION": {
      "authors": [
        "Gregory Williams"
      ],
      "href": "https://w3c.github.io/sparql-service-description/spec/",
      "title": "SPARQL 1.2 Service Description",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "sparql12-service-description"
    },
    "SPARQL12-FEDERATED-QUERY": {
      "authors": [
        "Eric Prud'hommeaux",
        "Carlos Buil Aranda"
      ],
      "href": "https://w3c.github.io/sparql-federated-query/spec/",
      "title": "SPARQL 1.2 Federated Query",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "sparql12-federated-query"
    },
    "SPARQL12-RESULTS-JSON": {
      "authors": [
        "Andy Seaborne"
      ],
      "href": "https://w3c.github.io/sparql-results-json/spec/",
      "title": "SPARQL 1.2 Query Results JSON Format",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "sparql12-results-json"
    },
    "SPARQL12-RESULTS-CSV-TSV": {
      "authors": [
        "Andy Seaborne"
      ],
      "href": "https://w3c.github.io/sparql-results-csv-tsv/spec/",
      "title": "SPARQL 1.2 Query Results CSV and TSV Formats",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "sparql12-results-csv-tsv"
    },
    "SPARQL12-RESULTS-XML": {
      "authors": [
        "Sandro Hawke",
        "Dave Beckett",
        "Jeen Broekstra"
      ],
      "href": "https://w3c.github.io/sparql-results-xml/spec/",
      "title": "SPARQL 1.2 Query Results XML Formats",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "sparql12-results-xml"
    },
    "SPARQL12-ENTAILMENT": {
      "authors": [
        "Birte Glimm",
        "Chimezie Ogbuji"
      ],
      "href": "https://w3c.github.io/sparql-entailment/spec/",
      "title": "SPARQL 1.2 Entailment Regimes",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C"
    },
    "SPARQL12-PROTOCOL": {
      "authors": [
        "Lee Feigenbaum",
        "Gregory Williams",
        "Kendall Clark",
        "Elias Torres"
      ],
      "href": "https://w3c.github.io/sparql-protocol/spec/",
      "title": "SPARQL 1.2 Protocol",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "sparql12-protocol"
    },
    "SPARQL12-GRAPH-STORE-PROTOCOL": {
      "authors": [
        "Chimezie Ogbuji"
      ],
      "href": "https://w3c.github.io/sparql-graph-store-protocol/spec/",
      "title": "SPARQL 1.2 Graph Store HTTP Protocol",
      "rawDate": "2022-01-01",
      "status": "WD",
      "publisher": "W3C",
      "id": "sparql12-graph-store-protocol"
    },
    "CBD": {
      "title": "CBD - Concise Bounded Description",
      "href": "https://www.w3.org/Submission/CBD/",
      "authors": [
        "Patrick Stickler, Nokia"
      ],
      "rawDate": "2005-06-03",
      "publisher": "W3C",
      "status": "W3C Member Submission"
    }
  },
  "lint": {
    "no-unused-dfns": false
  },
  "publishDate": "2023-06-06",
  "publishISODate": "2023-06-06T00:00:00.000Z",
  "generatedSubtitle": "W3C First Public Working Draft 06 June 2023"
}</script>
<link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/2021/W3C-WD"></head>
  <body class="h-entry"><div class="head">
    <p class="logos"><a class="logo" href="https://www.w3.org/"><img crossorigin="" alt="W3C" height="48" src="https://www.w3.org/StyleSheets/TR/2021/logos/W3C" width="72">
  </a></p>
    <h1 id="title" class="title">SPARQL 1.2 Entailment Regimes</h1> 
    <p id="w3c-state"><a href="https://www.w3.org/standards/types#FPWD">W3C First Public Working Draft</a> <time class="dt-published" datetime="2023-06-06">06 June 2023</time></p>
    <details open="">
      <summary>More details about this document</summary>
      <dl>
        <dt>This version:</dt><dd>
                <a class="u-url" href="https://www.w3.org/TR/2023/WD-sparql12-entailment-20230606/">https://www.w3.org/TR/2023/WD-sparql12-entailment-20230606/</a>
              </dd>
        <dt>Latest published version:</dt><dd>
                <a href="https://www.w3.org/TR/sparql12-entailment/">https://www.w3.org/TR/sparql12-entailment/</a>
              </dd>
        <dt>Latest editor's draft:</dt><dd><a href="https://w3c.github.io/sparql-entailment/spec/">https://w3c.github.io/sparql-entailment/spec/</a></dd>
        <dt>History:</dt><dd>
                    <a href="https://www.w3.org/standards/history/sparql12-entailment">https://www.w3.org/standards/history/sparql12-entailment</a>
                  </dd><dd>
                    <a href="https://github.com/w3c/sparql-entailment/commits/">Commit history</a>
                  </dd>
        <dt>Test suite:</dt><dd><a href="https://w3c.github.io/rdf-tests/">https://w3c.github.io/rdf-tests/</a></dd>
        
        
        
        <dt>Latest Recommendation:</dt><dd><a href="https://www.w3.org/TR/sparql11-entailment">https://www.w3.org/TR/sparql11-entailment</a></dd>
        <dt>Editor:</dt><dd class="editor p-author h-card vcard" data-editor-id="13382">
    <span class="p-name fn">Peter Patel-Schneider</span>
  </dd>
        <dt>
                Former editors:
              </dt><dd class="editor p-author h-card vcard">
    <span class="p-name fn">Birte Glimm</span>
  </dd><dd class="editor p-author h-card vcard">
    <span class="p-name fn">Chimezie Ogbuji</span>
  </dd>
        
        <dt>Feedback:</dt><dd>
        <a href="https://github.com/w3c/sparql-entailment/">GitHub w3c/sparql-entailment</a>
        (<a href="https://github.com/w3c/sparql-entailment/pulls/">pull requests</a>,
        <a href="https://github.com/w3c/sparql-entailment/issues/new/choose">new issue</a>,
        <a href="https://github.com/w3c/sparql-entailment/issues/">open issues</a>)
      </dd><dd><a href="mailto:public-rdf-star-wg@w3.org?subject=%5Bsparql12-entailment%5D%20YOUR%20TOPIC%20HERE">public-rdf-star-wg@w3.org</a> with subject line <kbd>[sparql12-entailment] <em>… message topic …</em></kbd> (<a rel="discussion" href="https://lists.w3.org/Archives/Public/public-rdf-star-wg">archives</a>)</dd>
        
        
      </dl>
    </details>
    
    
    <p class="copyright">
    <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
    ©
    2012-2023
    
    <a href="https://www.w3.org/">World Wide Web Consortium</a>.
    <abbr title="World Wide Web Consortium">W3C</abbr><sup>®</sup>
    <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
    <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and
    <a rel="license" href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document" title="W3C Software and Document Notice and License">permissive document license</a> rules apply.
  </p>
    <hr title="Separator for header">
  </div>
    <section id="abstract" class="introductory"><h2>Abstract</h2>
      
<p>SPARQL is a query language and a protocol for data that is stored natively as RDF or viewed as RDF via middleware. The main mechanism for computing query results in SPARQL is subgraph
    matching: RDF triples in both the queried RDF data and the query pattern are interpreted as nodes and edges of directed graphs, and the resulting query graph is matched to the data graph using
    variables as wild cards. Various <abbr title="World Wide Web Consortium">W3C</abbr> standards, including <cite><a data-matched-text="[[[RDF12-CONCEPTS]]]" href="https://w3c.github.io/rdf-concepts/spec/">RDF 1.2 Concepts and Abstract Syntax</a></cite> [<cite><a class="bibref" data-link-type="biblio" href="#bib-rdf12-concepts" title="RDF 1.2 Concepts and Abstract Syntax">RDF12-CONCEPTS</a></cite>] and <cite><a data-matched-text="[[[OWL2-MAPPING-TO-RDF]]]" href="https://www.w3.org/TR/owl2-mapping-to-rdf/">OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition)</a></cite> [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-mapping-to-rdf" title="OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition)">OWL2-MAPPING-TO-RDF</a></cite>], provide semantic
    interpretations for RDF graphs that allow additional RDF statements to be inferred from explicitly given assertions. Many applications that rely on these semantics require a query language such
    as SPARQL, but in order to use SPARQL, basic graph pattern matching has to be defined using semantic entailment relations instead of explicitly given graph structures. There are different
    possible ways of defining a basic graph pattern matching extension for an entailment relation. This document specifies one such way for a range of standard semantic web entailment relations. Such
    extensions of the SPARQL semantics are called <em>entailment regimes</em> within this document. An entailment regime defines not only which entailment relation is used, but also which queries and
    graphs are well-formed for the regime, how the entailment is used (since there are potentially different meaningful ways to use the same entailment relation), and what kinds of errors can arise.
    The entailment relations used in this document are standard entailment relations in the semantic web: RDF entailment, RDFS entailment, D-entailment, OWL Direct and RDF-Based Semantics entailment,
    and RIF Core entailment.</p>
    </section>

    <section id="sotd" class="introductory"><h2>Status of This Document</h2><p><em>This section describes the status of this
      document at the time of its publication. A list of current <abbr title="World Wide Web Consortium">W3C</abbr>
      publications and the latest revision of this technical report can be found
      in the <a href="https://www.w3.org/TR/"><abbr title="World Wide Web Consortium">W3C</abbr> technical reports index</a> at
      https://www.w3.org/TR/.</em></p>
      <p>
        This specification is published by the
        <a href="https://www.w3.org/groups/wg/rdf-star">RDF Star Working Group</a> as part of the
        update of specifications for format and errata.
      </p>

      <p>
    This document was published by the <a href="https://www.w3.org/groups/wg/rdf-star">RDF-star Working Group</a> as
    a First Public Working Draft using the
        <a href="https://www.w3.org/2021/Process-20211102/#recs-and-notes">Recommendation track</a>. 
  </p><p>Publication as a First Public Working Draft does not
  imply endorsement by <abbr title="World Wide Web Consortium">W3C</abbr> and its Members. </p><p>
    This is a draft document and may be updated, replaced or obsoleted by other
    documents at any time. It is inappropriate to cite this document as other
    than work in progress.
    
  </p><p>
    
        This document was produced by a group
        operating under the
        <a href="https://www.w3.org/Consortium/Patent-Policy/"><abbr title="World Wide Web Consortium">W3C</abbr> Patent
          Policy</a>.
      
    
                <abbr title="World Wide Web Consortium">W3C</abbr> maintains a
                <a rel="disclosure" href="https://www.w3.org/groups/wg/rdf-star/ipr">public list of any patent disclosures</a>
          made in connection with the deliverables of
          the group; that page also includes
          instructions for disclosing a patent. An individual who has actual
          knowledge of a patent which the individual believes contains
          <a href="https://www.w3.org/Consortium/Patent-Policy/#def-essential">Essential Claim(s)</a>
          must disclose the information in accordance with
          <a href="https://www.w3.org/Consortium/Patent-Policy/#sec-Disclosure">section 6 of the <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>.
        
  </p><p>
                  This document is governed by the
                  <a id="w3c_process_revision" href="https://www.w3.org/2021/Process-20211102/">2 November 2021 <abbr title="World Wide Web Consortium">W3C</abbr> Process Document</a>.
                </p><section id="set-of-documents"><div class="header-wrapper"><h3 id="set-of-documents-0">Set of Documents</h3><a class="self-link" href="#set-of-documents" aria-label="Permalink for this Section"></a></div>
<p>This document is one of twelve SPARQL 1.2 Recommendations produced by the <a href="https://www.w3.org/groups/wg/rdf-star">RDF-star Working Group</a>:</p>

<p>SPARQL 1.2 Recommendations:</p>
<ol>
  <li><cite><a data-matched-text="[[[SPARQL12-NEW]]]" href="https://w3c.github.io/sparql-new/spec/">What’s New in SPARQL 1.2</a></cite></li>
  <li><cite><a data-matched-text="[[[SPARQL12-CONCEPTS]]]" href="https://w3c.github.io/sparql-concepts/spec/">SPARQL 1.2 Concepts</a></cite></li>
  <li><cite><a data-matched-text="[[[SPARQL12-QUERY]]]" href="https://w3c.github.io/sparql-query/spec/">SPARQL 1.2 Query Language</a></cite></li>
  <li><cite><a data-matched-text="[[[SPARQL12-UPDATE]]]" href="https://w3c.github.io/sparql-update/spec/">SPARQL 1.2 Update</a></cite></li>
  <li><cite><a data-matched-text="[[[SPARQL12-SERVICE-DESCRIPTION]]]" href="https://w3c.github.io/sparql-service-description/spec/">SPARQL 1.2 Service Description</a></cite></li>
  <li><cite><a data-matched-text="[[[SPARQL12-FEDERATED-QUERY]]]" href="https://w3c.github.io/sparql-federated-query/spec/">SPARQL 1.2 Federated Query</a></cite></li>
  <li><cite><a data-matched-text="[[[SPARQL12-RESULTS-JSON]]]" href="https://w3c.github.io/sparql-results-json/spec/">SPARQL 1.2 Query Results JSON Format</a></cite></li>
  <li><cite><a data-matched-text="[[[SPARQL12-RESULTS-CSV-TSV]]]" href="https://w3c.github.io/sparql-results-csv-tsv/spec/">SPARQL 1.2 Query Results CSV and TSV Formats</a></cite></li>
  <li><cite><a data-matched-text="[[[SPARQL12-RESULTS-XML]]]" href="https://w3c.github.io/sparql-results-xml/spec/">SPARQL 1.2 Query Results XML Formats</a></cite></li>
  <li>SPARQL 1.2 Entailment Regimes(this document)</li>
  <li><cite><a data-matched-text="[[[SPARQL12-PROTOCOL]]]" href="https://w3c.github.io/sparql-protocol/spec/">SPARQL 1.2 Protocol</a></cite></li>
  <li><cite><a data-matched-text="[[[SPARQL12-GRAPH-STORE-PROTOCOL]]]" href="https://w3c.github.io/sparql-graph-store-protocol/spec/">SPARQL 1.2 Graph Store HTTP Protocol</a></cite></li>
</ol>
</section>
    </section><nav id="toc"><h2 class="introductory" id="table-of-contents">Table of Contents</h2><ol class="toc"><li class="tocline"><a class="tocxref" href="#abstract">Abstract</a></li><li class="tocline"><a class="tocxref" href="#sotd">Status of This Document</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#set-of-documents">Set of Documents</a></li></ol></li><li class="tocline"><a class="tocxref" href="#sec-intro"><bdi class="secno">1. </bdi>Introduction</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#Conventions"><bdi class="secno">1.1 </bdi>Document Conventions</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#syntax"><bdi class="secno">1.1.1 </bdi>Graph Syntax</a></li><li class="tocline"><a class="tocxref" href="#namespaces"><bdi class="secno">1.1.2 </bdi>Namespaces</a></li><li class="tocline"><a class="tocxref" href="#prelims"><bdi class="secno">1.1.3 </bdi>Preliminary Definitions</a></li><li class="tocline"><a class="tocxref" href="#resultDesc"><bdi class="secno">1.1.4 </bdi>Result Descriptions</a></li></ol></li><li class="tocline"><a class="tocxref" href="#entEffects"><bdi class="secno">1.2 </bdi>Effects of Different Entailment Regimes</a></li><li class="tocline"><a class="tocxref" href="#bgpMatchingExtensions"><bdi class="secno">1.3 </bdi>Extensions to Basic Graph Pattern Matching</a></li><li class="tocline"><a class="tocxref" href="#entRegimeParts"><bdi class="secno">1.4 </bdi>Parts of an Entailment Regime</a></li></ol></li><li class="tocline"><a class="tocxref" href="#RDFEntRegime"><bdi class="secno">2. </bdi>RDF Entailment Regime</a></li><li class="tocline"><a class="tocxref" href="#GeneralNotes"><bdi class="secno">3. </bdi>General Notes on Entailment Regimes (Informative)</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#bnodes"><bdi class="secno">3.1 </bdi>Blank Nodes in the Queried Graph</a></li><li class="tocline"><a class="tocxref" href="#axiomaticTriples"><bdi class="secno">3.2 </bdi>Answers from Axiomatic Triples</a></li><li class="tocline"><a class="tocxref" href="#literalSubjects"><bdi class="secno">3.3 </bdi>Literals in the Subject Position</a></li><li class="tocline"><a class="tocxref" href="#booleanQueries"><bdi class="secno">3.4 </bdi>Boolean Queries</a></li><li class="tocline"><a class="tocxref" href="#aggregates"><bdi class="secno">3.5 </bdi>Aggregates and Blank Nodes</a></li></ol></li><li class="tocline"><a class="tocxref" href="#RDFSEntRegime"><bdi class="secno">4. </bdi>RDFS Entailment Regime</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#inconsistencies"><bdi class="secno">4.1 </bdi>Inconsistencies (Informative)</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#uncheckedInconsistencies"><bdi class="secno">4.1.1 </bdi>Effects of Unchecked Inconsistencies</a></li></ol></li></ol></li><li class="tocline"><a class="tocxref" href="#DEntRegime"><bdi class="secno">5. </bdi>D-Entailment Regime</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#CanonicalLit"><bdi class="secno">5.1 </bdi>The D-Entailment Regime</a></li><li class="tocline"><a class="tocxref" href="#canonicalRep"><bdi class="secno">5.2 </bdi>XML Schema Datatypes and Canonical Lexical Representations</a></li></ol></li><li class="tocline"><a class="tocxref" href="#OWLRDFBSEntRegime"><bdi class="secno">6. </bdi>OWL 2 RDF-Based Semantics Entailment Regime</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#OWLRDFBSEntailments"><bdi class="secno">6.1 </bdi>Entailments under the OWL 2 RDF-Based Semantics (Informative)</a></li><li class="tocline"><a class="tocxref" href="#OWLRDFBSRestrictions"><bdi class="secno">6.2 </bdi>Restriction on Solutions</a></li><li class="tocline"><a class="tocxref" href="#OWLRDFBSComputing"><bdi class="secno">6.3 </bdi>Computing Query Answers under the RDF-Based Semantics (Informative)</a></li><li class="tocline"><a class="tocxref" href="#OWL2-RDFBS-Profiles"><bdi class="secno">6.4 </bdi>OWL 2 Profiles and Entailment Checkers</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#OWL2DL"><bdi class="secno">6.4.1 </bdi>OWL 2 DL</a></li><li class="tocline"><a class="tocxref" href="#OWL2EL"><bdi class="secno">6.4.2 </bdi>The OWL 2 EL Profile</a></li><li class="tocline"><a class="tocxref" href="#OWL2QL"><bdi class="secno">6.4.3 </bdi>The OWL 2 QL Profile</a></li><li class="tocline"><a class="tocxref" href="#OWL2RLDS"><bdi class="secno">6.4.4 </bdi>The OWL 2 RL Profile</a></li><li class="tocline"><a class="tocxref" href="#OWL2RLRDFBSComputing"><bdi class="secno">6.4.5 </bdi>Computing Query Answers for the OWL 2 RL Profile with RDF-Based Semantics (Informative)</a></li></ol></li></ol></li><li class="tocline"><a class="tocxref" href="#OWLDSEnRegime"><bdi class="secno">7. </bdi>OWL 2 Direct Semantics Entailment Regime</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#OWLDSIntro"><bdi class="secno">7.1 </bdi>Introduction</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#OWLDSImports"><bdi class="secno">7.1.1 </bdi>OWL Import Directives</a></li><li class="tocline"><a class="tocxref" href="#OWLDSExtGrammar"><bdi class="secno">7.1.2 </bdi>Extended Grammar for OWL 2 Direct Semantics BGPs</a></li><li class="tocline"><a class="tocxref" href="#VarTyping"><bdi class="secno">7.1.3 </bdi>Variable Typing</a></li></ol></li><li class="tocline"><a class="tocxref" href="#OWLDSEntRegime"><bdi class="secno">7.2 </bdi>The OWL 2 Direct Semantics Entailment Regime</a></li><li class="tocline"><a class="tocxref" href="#OWLDSRestrictions"><bdi class="secno">7.3 </bdi>Restrictions on Solutions (Informative)</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#OWLDSConstraints"><bdi class="secno">7.3.1 </bdi>BGP Constraints for OWL 2 DL</a></li><li class="tocline"><a class="tocxref" href="#OWLDSLiteralVars"><bdi class="secno">7.3.2 </bdi>Queries with Variables in Literal Positions</a></li></ol></li><li class="tocline"><a class="tocxref" href="#OWLDSHigherOrder"><bdi class="secno">7.4 </bdi>Higher-Order Queries (Informative)</a></li><li class="tocline"><a class="tocxref" href="#OWL2ProfilesDS"><bdi class="secno">7.5 </bdi>OWL 2 Entailment Checkers and Profiles</a></li></ol></li><li class="tocline"><a class="tocxref" href="#RIFCoreEnt"><bdi class="secno">8. </bdi>RIF Core Entailment</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#SimpeRIFCoreEntRegime"><bdi class="secno">8.1 </bdi>(Simple) RIF Core Entailment Regime</a></li><li class="tocline"><a class="tocxref" href="#RIFCustomRuleSets"><bdi class="secno">8.2 </bdi>Custom Rulesets for Common Vocabulary Interpretations (Informative)</a></li><li class="tocline"><a class="tocxref" href="#RIFFiniteAnswers"><bdi class="secno">8.3 </bdi>Finite Answer Set Conditions (Informative)</a></li><li class="tocline"><a class="tocxref" href="#RIFDocReferences"><bdi class="secno">8.4 </bdi>Referencing a RIF Document</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#RIFUsedWithProfile"><bdi class="secno">8.4.1 </bdi>Semantics of <code>rif:usedWithProfile</code></a></li><li class="tocline"><a class="tocxref" href="#RIFDereferencing"><bdi class="secno">8.4.2 </bdi>Dereferencing RIF Documents (Informative)</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#RIFHTTPDereferencing"><bdi class="secno">8.4.2.1 </bdi>HTTP Dereferencing</a></li><li class="tocline"><a class="tocxref" href="#RIFDocsAsNamedGraphs"><bdi class="secno">8.4.2.2 </bdi>Encoding RIF documents within named graphs in the dataset</a></li></ol></li></ol></li></ol></li><li class="tocline"><a class="tocxref" href="#DataSets"><bdi class="secno">9. </bdi>Entailment Regimes and Data Sets (Informative)</a></li><li class="tocline"><a class="tocxref" href="#PropertyPaths"><bdi class="secno">10. </bdi>Entailment Regimes and Property Paths (Informative)</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#PropertyPathsLimitations"><bdi class="secno">10.1 </bdi>Limitations of Property Paths in Combination with Entailment Regimes</a></li></ol></li><li class="tocline"><a class="tocxref" href="#Updates"><bdi class="secno">11. </bdi>Entailment Regimes and Updates (Informative)</a></li><li class="tocline"><a class="tocxref" href="#AppendixMapping"><bdi class="secno">12. </bdi>Appendix: Mapping from BGPs to the extended OWL 2 Structural Specification</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#OWLParsing"><bdi class="secno">12.1 </bdi>Parsing BGPs into Objects of the Extended OWL 2 Structural Specification</a></li></ol></li><li class="tocline"><a class="tocxref" href="#AppendixProofs"><bdi class="secno">13. </bdi>Appendix: Proofs</a></li><li class="tocline"><a class="tocxref" href="#conformance"><bdi class="secno">14. </bdi>Conformance</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#conformance-0"><bdi class="secno">14.1 </bdi>Conformance</a></li></ol></li><li class="tocline"><a class="tocxref" href="#privacy"><bdi class="secno">15. </bdi>Privacy Considerations</a></li><li class="tocline"><a class="tocxref" href="#security"><bdi class="secno">16. </bdi>Security Considerations</a></li><li class="tocline"><a class="tocxref" href="#internationalization"><bdi class="secno">17. </bdi>Internationalization Considerations</a></li><li class="tocline"><a class="tocxref" href="#changes-from-sparql11"><bdi class="secno">A. </bdi>Change Log</a></li><li class="tocline"><a class="tocxref" href="#index"><bdi class="secno">B. </bdi>Index</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#index-defined-here"><bdi class="secno">B.1 </bdi>Terms defined by this specification</a></li><li class="tocline"><a class="tocxref" href="#index-defined-elsewhere"><bdi class="secno">B.2 </bdi>Terms defined by reference</a></li></ol></li><li class="tocline"><a class="tocxref" href="#references"><bdi class="secno">C. </bdi>References</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#normative-references"><bdi class="secno">C.1 </bdi>Normative references</a></li><li class="tocline"><a class="tocxref" href="#informative-references"><bdi class="secno">C.2 </bdi>Informative references</a></li></ol></li></ol></nav>
    

    <section id="sec-intro"><div class="header-wrapper"><h2 id="x1-introduction"><bdi class="secno">1. </bdi>Introduction</h2><a class="self-link" href="#sec-intro" aria-label="Permalink for Section 1."></a></div>
      
      <p>The <cite><a data-matched-text="[[[SPARQL12-QUERY]]]" href="https://w3c.github.io/sparql-query/spec/">SPARQL 1.2 Query Language</a></cite> [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql12-query" title="SPARQL 1.2 Query Language">SPARQL12-QUERY</a></cite>] defines the evaluation of a basic graph pattern by means of subgraph matching. This form of basic graph pattern
      evaluation is also called simple entailment since it can equally be defined in terms of the <a href="https://w3c.github.io/rdf-semantics/spec/#dfn-simply-entail" id="ref-for-index-term-simple-entailment-relation-between-rdf-graphs-1">simple entailment relation between RDF graphs</a>. In
      order to use more elaborate entailment relations, which also allow for retrieving solutions that implicitly follow from the queried graph, this document defines several <em>entailment
      regimes</em>. An entailment regime specifies how an entailment relation such as RDF Schema entailment can be used to redefine the evaluation of basic graph patterns from a SPARQL query making
      use of SPARQL's extension point for basic graph pattern matching. In order to satisfy the conditions that SPARQL places on extensions to basic graph pattern matching, an entailment regime
      specifies conditions that limit the number of entailments that contribute solutions for a basic graph pattern. For example, only a finite number of the infinitely many axiomatic triples can
      contribute solutions under the RDF Schema entailment regime. The entailment relations used in this document are common semantic web entailment relations:
      <a href="https://w3c.github.io/rdf-semantics/spec/#rdf_entail" id="ref-for-index-term-rdf-entailment-1">RDF entailment</a>,
      <a href="https://w3c.github.io/rdf-semantics/spec/#rdfs_entailment" id="ref-for-index-term-rdf-schema-entailment-1">RDF Schema entailment</a>,
      <a href="https://w3c.github.io/rdf-semantics/spec/#D_entailment" id="ref-for-index-term-d-entailment-1">D-Entailment</a>,
      <a href="https://validator.w3.org/checklink?hide_type=all&depth=&check=Check&uri=https://www.w3.org/TR/2023/WD-sparql12-entailment-20230606/" id="ref-for-index-term-owl-2-rdf-based-semantics-entailment-1">OWL 2 RDF-Based Semantics entailment</a>,
      <a href="https://www.w3.org/TR/owl2-direct-semantics/#Inference_Problems" id="ref-for-index-term-owl-2-direct-semantics-entailment-1">OWL 2 Direct Semantics entailment</a>, and
      <a href="https://www.w3.org/TR/rif-rdf-owl/#def-simple-entails" id="ref-for-index-term-rif-simple-entailment-1">RIF-Simple entailment</a>.</p>

      <p>References to RDF or RDFS entailment rules from the <cite><a data-matched-text="[[[RDF12-SEMANTICS]]]" href="https://w3c.github.io/rdf-semantics/spec/">RDF 1.2 Semantics</a></cite> specification are used in Section
        <a href="#entEffects">1.2</a>, <a href="#bnodes">3.1</a>, <a href="#axiomaticTriples">3.2</a>, and <a href="#inconsistencies">4.1</a> in an informative way and implementations are not expected to
        implement these rules as they are used here.</p>
      <section id="Conventions"><div class="header-wrapper"><h3 id="x1-1-document-conventions"><bdi class="secno">1.1 </bdi>Document Conventions</h3><a class="self-link" href="#Conventions" aria-label="Permalink for Section 1.1"></a></div>
        
        <p>Throughout the document, certain conventions are used, which are outlined below.</p>
        <section id="syntax"><div class="header-wrapper"><h4 id="x1-1-1-graph-syntax"><bdi class="secno">1.1.1 </bdi>Graph Syntax</h4><a class="self-link" href="#syntax" aria-label="Permalink for Section 1.1.1"></a></div>
          
          <p>This document uses the Turtle [<cite><a class="bibref" data-link-type="biblio" href="#bib-rdf12-turtle" title="RDF 1.2 Turtle">RDF12-TURTLE</a></cite>] data format to show triples explicitly. This notation uses a node identifier (nodeID) convention to indicate blank nodes in
          the triples of a graph. While node identifiers such as <code>_:xxx</code> serve to identify blank nodes in the surface syntax, these expressions are not considered to be the label of the
          graph node they identify; they are not names, and do not occur in the actual graph. In particular, the RDF graphs described by two Turtle documents which differ only by renaming their blank
          node identifiers will be understood to be equivalent. This renaming convention should be understood as applying only to whole documents, since renaming the node identifiers in part of a
          document may result in a document describing a different RDF graph. A blank node may also anonymously (without an explicit identifier) be denoted with <code>[]</code>.</p>
          <p>IRIs are written enclosed in <code>&lt;</code> and <code>&gt;</code> and may be absolute RDF IRI References or relative to the current base IRI. IRIs may also be abbreviated by using
          Turtle's <code>@prefix</code> directive that allows declaring a short prefix name for a long prefix of repeated IRIs. Once a prefix such as <code>@prefix foo: &lt;http://example.org/ns#&gt;
          .</code> is defined, any mention of an IRI later in the document may use a qualified name that starts <code>foo:</code> to stand for the longer IRI. For example, the qualified name
          <code>foo:bar</code> is a shorthand for the IRI <code>&lt;http://example.org/ns#bar&gt;</code>.</p>
          <p>For example, the following triples use prefixes and abbreviated IRIs and also the non-abbreviated IRI <code>&lt;book2&gt;</code>, which is relative to the base IRI of the document.</p>
          <pre class="data" aria-busy="false"><code class="hljs">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
:book1  dc:title "SPARQL Tutorial" . 
&lt;book2&gt; dc:title "Turtle Tutorial" .</code></pre>
          <p>Standard <a href="https://w3c.github.io/rdf-turtle/spec/#" id="ref-for-index-term-turtle-abbreviations-1">Turtle abbreviations</a> are taken to be expanded into their full form in the queried graph and the query. Since the entailment regimes
          use the vocabulary of the queried graph to constrain the solutions, this means that, e.g., when <code>a</code> is used in a predicate position it is considered to be expanded to
          <code>rdf:type</code> before the query is answered. Similarly, abbreviations for lists etc. in the queried graph are considered to be expanded into their full form. For example, if a Turtle
          document contains a list of the form <code>( ex:a ex:b )</code>, it is assumed that vocabulary of the queried graph contains <code>rdf:first</code>, <code>rdf:rest</code>, and
          <code>rdf:nil</code> because the expanded form of the list is <code>[ rdf:first ex:a; rdf:rest [ rdf:first ex:b; rdf:rest rdf:nil ] ]</code>.</p>
        </section>
        <section id="namespaces"><div class="header-wrapper"><h4 id="x1-1-2-namespaces"><bdi class="secno">1.1.2 </bdi>Namespaces</h4><a class="self-link" href="#namespaces" aria-label="Permalink for Section 1.1.2"></a></div>
          
          <p>Examples assume the following namespace prefix bindings unless otherwise stated:</p>
          <div style="text-align: left;">
            <table style="border-color: rgb(0, 0, 0); border-collapse: collapse; border-spacing:5px; border-width: 1px">
              <tbody>
                <tr>
                  <th>Prefix</th>
                  <th>IRI</th>
                </tr>
                <tr>
                  <td><code>rdf:</code></td>
                  <td><code>&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;</code></td>
                </tr>
                <tr>
                  <td><code>rdfs:</code></td>
                  <td><code>&lt;http://www.w3.org/2000/01/rdf-schema#&gt;</code></td>
                </tr>
                <tr>
                  <td><code>owl:</code></td>
                  <td><code>&lt;http://www.w3.org/2002/07/owl#&gt;</code></td>
                </tr>
                <tr>
                  <td><code>xsd:</code></td>
                  <td><code>&lt;http://www.w3.org/2001/XMLSchema#&gt;</code></td>
                </tr>
                <tr>
                  <td><code>rif:</code></td>
                  <td><code>&lt;www.w3.org/2007/rif#&gt;</code></td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>In the interests of brevity, the prefix <code>ex:</code> is also used in the examples. The prefix is assumed to be bound to an exemplary IRI such as
          <code>&lt;http://www.example.org/&gt;</code>.</p>
        </section>
        <section id="prelims"><div class="header-wrapper"><h4 id="x1-1-3-preliminary-definitions"><bdi class="secno">1.1.3 </bdi>Preliminary Definitions</h4><a class="self-link" href="#prelims" aria-label="Permalink for Section 1.1.3"></a></div>
          
          <p>This document uses the same <a href="https://w3c.github.io/sparql-query/spec/#initDefinitions" id="ref-for-index-term-definitions-1">definitions</a> as the
            <cite><a data-matched-text="[[[SPARQL12-QUERY]]]" href="https://w3c.github.io/sparql-query/spec/">SPARQL 1.2 Query Language</a></cite> specification. Important terms are recaptured below for clarity. In the case of any differences, the SPARQL Query Language definitions are the normative ones.</p>
          <p>The term <em>I</em> denotes the set of all IRIs, <em>RDF-L</em> the set of all <a href="https://w3c.github.io/rdf-concepts/spec/#dfn-literal" id="ref-for-index-term-rdf-literals-1">RDF Literals</a>,
          and <em>RDF-B</em> the set of all <a href="https://w3c.github.io/rdf-concepts/spec/#dfn-blank-node" id="ref-for-index-term-blank-nodes-1">blank nodes</a> in RDF graphs.</p>
          <p>The set of <span class="definedTerm">RDF Terms</span>, <em>RDF-T</em>, is <em>I ∪ RDF-L ∪ RDF-B</em>.</p>
          <p>The set of query variables is denoted as <em>V</em> and <em>V</em> is assumed to be countable, infinite, and disjoint from <em>RDF-T</em>. A triple pattern is a member of the set:</p>
          <blockquote>
            <em>(RDF-T ∪ V) x (I ∪ V) x (RDF-T ∪ V),</em>
          </blockquote>
          <p>A basic graph pattern (BGP) is a set of triple patterns.</p>
          <p>A <em>pattern instance mapping</em> P is the combination of an RDF instance mapping σ and solution mapping μ. For a BGP <code>x</code>, <em>P</em>(<code>x</code>) denotes the result of
          replacing blank nodes <code>b</code> in <code>x</code> for which σ is defined with σ(<code>b</code>) and all variables <code>v</code> in <code>x</code> for which μ is defined with
          μ(<code>v</code>), denoted <em>P</em>(<code>x</code>) = μ(σ(<code>x</code>)).</p>
        </section>
        <section id="resultDesc"><div class="header-wrapper"><h4 id="x1-1-4-result-descriptions"><bdi class="secno">1.1.4 </bdi>Result Descriptions</h4><a class="self-link" href="#resultDesc" aria-label="Permalink for Section 1.1.4"></a></div>
          
          <p>Result sets are illustrated in tabular form.</p>
          <div class="result">
            <span class="doc-ref" id="table0"></span>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>y</th>
                  <th>z</th>
                </tr>
                <tr>
                  <td>"Alice"</td>
                  <td><code>&lt;http://example/a&gt;</code></td>
                  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>A 'binding' is a pair (<a href="https://w3c.github.io/sparql-query/spec/#defn_QueryVariable" id="ref-for-index-term-variable-1">variable</a>, <a href="https://w3c.github.io/rdf-concepts/spec/#dfn-rdf-term" id="ref-for-index-term-rdf-term-1">RDF term</a>). In this
          result set, there are three variables: <code>x</code>, <code>y</code>, and <code>z</code> (shown as column headers). Each solution is shown as one row in the body of the table. Here, there
          is a single solution, in which variable <code>x</code> is bound to <code>"Alice"</code>, variable <code>y</code> is bound to <code>&lt;http://example/a&gt;</code>, and variable
          <code>z</code> is not bound to an RDF term. Variables are not required to be bound in a solution.</p>
          <p>Sometimes solutions are annotated with the name of a solution mapping so that the explanatory text can refer to the solution mapping and explain or justify certain solutions. For
          example, in the results table below, the only solution is given by the solution mapping μ<sub>1</sub>:</p>
          <div class="result">
            <span class="doc-ref" id="table01"></span>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th class="annotation"></th>
                  <th>x</th>
                  <th>y</th>
                  <th>z</th>
                </tr>
                <tr>
                  <td class="annotation">μ<sub>1</sub></td>
                  <td>"Alice"</td>
                  <td><code>&lt;http://example/a&gt;</code></td>
                  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
      </section>
      <section id="entEffects"><div class="header-wrapper"><h3 id="x1-2-effects-of-different-entailment-regimes"><bdi class="secno">1.2 </bdi>Effects of Different Entailment Regimes</h3><a class="self-link" href="#entEffects" aria-label="Permalink for Section 1.2"></a></div>
        
        <p>The SPARQL Query specification already envisages that SPARQL can be used with entailment regimes other than simple entailment. To illustrate the differences between simple, RDF, and RDFS
        entailment, consider the following data:</p>
        <pre class="data" aria-busy="false"><code class="hljs">(1) ex:book1 rdf:type ex:Publication .
(2) ex:book2 rdf:type ex:Article .
(3) ex:Article rdfs:subClassOf ex:Publication .
(4) ex:publishes rdfs:range ex:Publication .
(5) ex:MITPress ex:publishes ex:book3 .</code></pre>
        <p><img src="./semantics.png" alt="RDF graph for the example on effects of different entailment regimes"><br>
        <strong>Figure 1</strong>: A graphical representation of the RDF graph for the example where green dashed lines indicate RDF-entailed triples and red dashed lines indicate triples that are
        also RDFS-entailed.</p>
        <p>Consider, for example, the following query:</p>
        <pre class="query" aria-busy="false"><code class="hljs">SELECT ?prop WHERE { ?prop rdf:type rdf:Property }</code></pre>
        <p>Under simple entailment the query has an empty answer when querying the above graph. Under RDF entailment, the
          RDF rule <a href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfd1" id="ref-for-index-term-rdfd1-1">rdfD1</a> be used on (5) to derive the triple <code>ex:publishes rdf:type rdf:Property</code> which means that
        <code>ex:publishes</code> is a valid binding for <code>?prop</code> and will be returned as an answer for the query from a system that uses RDF entailment.</p>
        <p>The following query asks for a list of all publications:</p>
        <pre class="query" aria-busy="false"><code class="hljs">SELECT ?pub WHERE { ?pub rdf:type ex:Publication }</code></pre>
        <p>Clearly, <code>ex:book1</code> is an answer due to triple (1). Intuitively, we can expect that <code>ex:book2</code> is also a publication because it is an article (2) and all articles are
        publications (3). Even <code>ex:book3</code> is a publication because it is published by MIT Press (5) and everything that is published is a publication (4). Under simple and RDF entailment,
        <code>ex:book1</code> is the only answer because a system that uses simple entailment will not perform any of the reasoning steps that were required to find that <code>ex:book2</code> and
        <code>ex:book3</code> are publications. Under simple entailment, the basic graph pattern <code>?pub rdf:type ex:Publication</code> is mapped to the queried graph and variables act as a kind
        of wild-card, e.g., by mapping <code>?pub</code> to <code>ex:book1</code> the BGP matches. RDF already supports a few inferences, but not those that are required to derive that
        <code>ex:book2</code> and <code>ex:book3</code> are publications. In order to retrieve <code>ex:book2</code> and <code>ex:book3</code>, one would need a system that supports at least RDFS
        entailment. <a href="https://w3c.github.io/rdf-semantics/spec/#rdf_entailment_patterns" id="ref-for-index-term-rdfs-entailment-rules-1">RDFS entailment rules</a> can be used to illustrate which new consequences can be
        derived from the given data. For example, the rule <a href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfs9" id="ref-for-index-term-rdfs9-1">rdfs9</a> can be applied to the triples (3) and (2) to derive</p>
        <pre class="data" aria-busy="false"><code class="hljs">(6) ex:book2 rdf:type ex:Publication .</code></pre>
        <p>The rule <a href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfs3" id="ref-for-index-term-rdfs3-1">rdfs3</a> can be applied to (4) and (5) to derive</p>
        <pre class="data" aria-busy="false"><code class="hljs">(7) ex:book3 rdf:type ex:Publication .</code></pre>
        <p>The triples (6) and (7) can then be used to find that <code>ex:book2</code> and <code>ex:book3</code> are also answers to the query under an RDFS entailment regime.
          The <cite><a data-matched-text="[[[?OWL2-OVERVIEW]]]" href="https://www.w3.org/TR/owl2-overview/">OWL 2 Web Ontology Language Document Overview (Second Edition)</a></cite> [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-overview" title="OWL 2 Web Ontology Language Document Overview (Second Edition)">OWL2-OVERVIEW</a></cite>] allows for even more inferences and the Rule Interchange Format RIF allows for customizing the inferences by specifying
        custom rule sets. The remainder of this document specifies correct answers for different entailment regimes using SPARQL's extension mechanism for Basic Graph Pattern Matching.</p>
      </section>
      <section id="bgpMatchingExtensions"><div class="header-wrapper"><h3 id="x1-3-extensions-to-basic-graph-pattern-matching"><bdi class="secno">1.3 </bdi>Extensions to Basic Graph Pattern Matching</h3><a class="self-link" href="#bgpMatchingExtensions" aria-label="Permalink for Section 1.3"></a></div>
        
        <p>The SPARQL Query specification [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql12-query" title="SPARQL 1.2 Query Language">SPARQL12-QUERY</a></cite>] gives a set of <a href="https://w3c.github.io/sparql-query/spec/#sparqlBGPExtend" id="ref-for-index-term-conditions-1">conditions</a> that have to be met
        when extending the basic graph pattern matching beyond simple entailment:</p>
        <p>An entailment regime specifies</p>
        <ol class="enumar">
          <li>A subset of RDF graphs called well-formed for the regime</li>
          <li>An entailment relation between subsets of well-formed graphs and well-formed graphs.</li>
        </ol>
        <p>Since the OWL 2 Direct Semantics is, for example, only defined for certain well-formed RDF graphs, the first condition can be used to define an OWL 2 Direct Semantics entailment regime
        only over those RDF graphs that represent an OWL 2 DL ontology. For the entailment relations mentioned in the second condition, this specification uses entailment relations that are already
        specified and used on the semantic web such as RDF(S) entailment or OWL Direct Semantics entailment.</p>
        <p>SPARQL Query further defines <a href="https://w3c.github.io/sparql-query/spec/#sparqlBGPExtend" id="ref-for-index-term-conditions-2">a set of conditions</a> for extensions of the basic graph pattern matching. These conditions do
        not cover the case of inconsistent graphs. An inconsistent graph is one for which no interpretation exists that satisfies all conditions of the semantics that is used. The issue is discussed
        in more detail in <a href="#inconsistencies">Section 3.1</a>, which also provides an example for an RDFS-inconsistent graph. Since inconsistent graphs entail any triple, special care has to
        be taken to address the situation. The effect of a query on an inconsistent graph is covered by the particular entailment regimes and, for each regime, the relevant details can be found in
        the corresponding section for that entailment regime. The SPARQL Query conditions for using a logical entailment relation E, such as RDFS entailment, instead of subgraph matching for the case
        of a consistent active graph are repeated below for clarity. An overview of how the different entailment regimes satisfy these conditions follows.</p>
        <ol class="enumar">
          <li><span class="doc-ref" id="condition1"></span>The <a href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="ref-for-index-term-scoping-graph-1">scoping graph</a>, SG, corresponding to any E-consistent active graph AG is
          uniquely specified up to <a href="https://w3c.github.io/rdf-concepts/spec/#section-graph-equality" id="ref-for-index-term-rdf-graph-equivalence-1">RDF graph equivalence</a> and is E-equivalent to AG.</li>
          <li><span class="doc-ref" id="condition2"></span>For any basic graph pattern BGP and pattern instance mapping P, P(BGP) is well-formed for E.</li>
          <li>
            <span class="doc-ref" id="condition3"></span>For any <a href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="ref-for-index-term-scoping-graph-2">scoping graph</a> SG and answer set {P<sub>1</sub> ... P<sub>n</sub>} for a
            basic graph pattern BGP, and where {BGP<sub>1</sub> .... BGP<sub>n</sub>} is a set of basic graph patterns all equivalent to BGP, none of which share any blank nodes with any other or
            with SG
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SG E-entails (SG ∪ P<sub>1</sub>(BGP<sub>1</sub>) ∪ ... ∪ P<sub>n</sub>(BGP<sub>n</sub>))</p>These conditions do not fully determine the set
            of possible answers, since RDF allows unlimited amounts of redundancy. In addition, therefore, the following must hold.
          </li>
          <li><span class="doc-ref" id="condition4"></span>Each SPARQL extension <em class="rfc2119">MUST</em> provide conditions on answer sets which guarantee that
          the set of triples obtained by instantiating BGP with each solution μ is uniquely specified up to RDF graph equivalence,
          and <em class="rfc2119">SHOULD</em> provide further conditions to prevent trivial infinite answers as appropriate to the regime.</li>
        </ol>
        <p>This specification does not change any of the existing entailment relations, but rather defines the vocabulary from which possible answers can be taken and defines certain conditions which
        guarantee that query answers are finite for most entailment regimes herein (with the exception of RIF, where finiteness is not always guaranteed, see details below in
        <a href="#RIFFiniteAnswers">Section 8.3</a>). The set of legal graphs, i.e., graphs that can be queried, is also unrestricted apart from the restriction to graphs that are legal under the entailment
        regime in question. For example, under the RDFS entailment regime, one can query all legal RDF graphs, while under OWL 2 Direct Semantics, one can query all graphs that correspond to legal
        OWL 2 DL ontologies. Further, it is defined which queries are legal and how illegal queries, illegal graphs, and inconsistencies are handled. All defined entailment regimes satisfy the above
        conditions as follows:</p>
        <ol class="enumar">
          <li>All entailment regimes specified here use the same definition of a <a href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="ref-for-index-term-scoping-graph-3">scoping graph as given for simple entailment</a>. Thus,
          the required equivalence is immediate.</li>
          <li>Only mappings that, when applied to the BGP, yield a set of RDF triples that are well-formed for E are legal solution mappings and included in the answer. For example, under RDFS
          entailment, any SPARQL query is legal, but queries that require literals as a binding for a variable in a subject position have no answer because all mappings that result in a set of RDFS
          entailed triples are not well-formed RDF since RDF forbids literals in the subject position. Similarly, for OWL 2 Direct Semantics entailment, a query might have no answer because all
          possible bindings might result in RDF triples that are not well-formed for <cite><a data-matched-text="[[[OWL2-MAPPING-TO-RDF]]]" href="https://www.w3.org/TR/owl2-mapping-to-rdf/">OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition)</a></cite>.</li>
          <li>This condition prevents the reuse of blank nodes between query answers unless those blank nodes are really the same in the queried graph. Under this restriction no accidental
          co-references among blank nodes are introduced. All entailment regimes use the same definition of a <a href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="ref-for-index-term-scoping-graph-4">scoping graph</a> as
          simple entailment. The condition is satisfied since a form of Skolemization is used to restrict the answers containing blank nodes.</li>
          <li>This point is very important since infinite answers are easily possible under all the considered regimes. For example, already under RDF and RDFS entailment, even the empty graph
          entails an infinite number of axiomatic triples such as <code>rdf:_1 rdf:type rdf:Property</code>, <code>rdf:_2 rdf:type rdf:Property</code>, ... Thus, a query with BGP <code>{&nbsp;?x
          rdf:type rdf:Property . }</code> would, without further restrictions, have infinitely many answers. Such answers are to be understood as trivial infinite answers. Other sources of trivial
          infinite answers are answers that only differ in blank node labels. In order to exclude such sources of infinity, the entailment regimes will define a (finite) vocabulary from which
          bindings can be taken. These restrictions are explained in greater detail in the following sections.</li>
        </ol>
      </section>
      <section id="entRegimeParts"><div class="header-wrapper"><h3 id="x1-4-parts-of-an-entailment-regime"><bdi class="secno">1.4 </bdi>Parts of an Entailment Regime</h3><a class="self-link" href="#entRegimeParts" aria-label="Permalink for Section 1.4"></a></div>
        Each entailment regime is defined in a table describing the following items:
        <ul>
          <li><strong>Name</strong>: A name for the entailment regime, usually the same as the entailment relation used to define the evaluation of a basic graph pattern.</li>
          <li><strong>IRI</strong>: The IRI for the regime, which can be used in the <cite><a data-matched-text="[[[?SPARQL12-SERVICE-DESCRIPTION]]]" href="https://w3c.github.io/sparql-service-description/spec/">SPARQL 1.2 Service Description</a></cite> of a SPARQL endpoint. The IRI
          for a SPARQL endpoint can be related via the property <code>sd:defaultEntailmentRegime</code> to the IRI of an entailment regime which applies per default to graphs queried via this
          endpoint. Additionally, the property <code>sd:entailmentRegime</code> can be used to relate a particular named graph with an entailment regime that is different from the otherwise used
          default entailment regime.</li>
          <li><strong>Legal Graphs</strong>: Describes which graphs are legal for the regime.</li>
          <li><strong>Legal Queries</strong>: Describes which queries are legal for the regime.</li>
          <li><strong>Illegal Handling</strong>: Describes what happens in case of an illegal graph or query.</li>
          <li><strong>Entailment</strong>: Specifies which entailment relation is used in the evaluation of basic graph patterns.</li>
          <li><strong>Inconsistency</strong>: Defines what happens if the queried graph is inconsistent under the used semantics.</li>
          <li><strong>Query Answers</strong>: Defines how a basic graph pattern is evaluated, i.e., what the solutions are for a given graph and basic graph pattern of a query.</li>
        </ul>
      </section>
    </section>
    <section id="RDFEntRegime"><div class="header-wrapper"><h2 id="x2-rdf-entailment-regime"><bdi class="secno">2. </bdi>RDF Entailment Regime</h2><a class="self-link" href="#RDFEntRegime" aria-label="Permalink for Section 2."></a></div>
      
      <p>RDF entailment is closest to simple entailment in that it provides only few additional answers and RDF is not expressive enough to express inconsistencies. RDF does, however, entail an
      infinite set of axiomatic triples and the entailment regime specifies conditions that address the fourth condition on extensions of basic graph pattern matching. Further explanations are given
      in the informative sections following the main definition of the regime.</p>
      <div style="text-align: left;">
        <table style="border-color: rgb(0, 0, 0); border-collapse: collapse; border-spacing: 5px; border-width: 1px">
          <tbody>
            <tr>
              <th>Name</th>
              <td>RDF</td>
            </tr>
            <tr>
              <th>IRI</th>
              <td><a href="http://www.w3.org/ns/entailment/RDF">http://www.w3.org/ns/entailment/RDF</a></td>
            </tr>
            <tr>
              <th>Legal Graphs</th>
              <td>Any legal RDF graph.</td>
            </tr>
            <tr>
              <th>Legal Queries</th>
              <td>Any legal SPARQL query.</td>
            </tr>
            <tr>
              <th>Illegal Handling</th>
              <td>In case the query is illegal (syntax errors), the system <em class="rfc2119">MUST</em> raise a
                <a href="https://w3c.github.io/sparql-protocol/spec/#select-malformed" id="ref-for-index-term-malformedquery-1">MalformedQuery</a> fault. In case the queried graph is illegal (syntax errors), the system <em class="rfc2119">MUST</em> raise a <a href="https://w3c.github.io/sparql-protocol/spec/#select-refused" id="ref-for-index-term-queryrequestrefused-1">QueryRequestRefused</a> fault.</td>
            </tr>
            <tr>
              <th>Entailment</th>
              <td><a href="https://w3c.github.io/rdf-semantics/spec/#rdf_entail" id="ref-for-index-term-rdf-entailment-2">RDF Entailment</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-rdf12-semantics" title="RDF 1.2 Semantics">RDF12-SEMANTICS</a></cite>]</td>
            </tr>
            <tr>
              <th>Inconsistency</th>
              <td>RDF graphs are always RDF consistent and no inconsistency handling is required.</td>
            </tr>
            <tr>
              <th>Query Answers</th>
              <td>
                <p>Let G be the queried RDF graph, BGP be a basic graph pattern, V(BGP) the set of variables in BGP, B(BGP) the set of blank nodes in BGP, SG the
                  <a href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="ref-for-index-term-scoping-graph-5">scoping graph</a> for G and BGP, sk(SG) a <a href="https://w3c.github.io/rdf-semantics/spec/#skolemization" id="ref-for-index-term-skolemization-1">Skolemization</a> of SG with
                respect to a vocabulary disjoint from the vocabulary of SG and BGP. Applying sk to a term t, written sk(t), yields sk(t) if sk is defined for t and t otherwise; applying sk to a BGP,
                written sk(BGP), replaces each blank node b in BGP for which sk is defined with sk(b). The set rdfV contains the URI references of the
                <a href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdf-vocabulary" id="ref-for-index-term-rdf-vocabulary-1">RDF vocabulary</a> and rdfV-Minus is the set of URI references in rdfV minus URI references of the form <code>rdf:_n</code>
                with <code>n</code> in <code>{1, 2, ... }</code>.</p>
                <p>A solution mapping μ is a <em>possible solution for BGP from G under RDF entailment</em> if dom(μ) = V(BGP) and there is an RDF instance mapping σ from B(BGP) to RDF-T such that
                dom(σ)=B(BGP) and the pattern instance mapping P=(μ, σ) is such that P(BGP) are well-formed RDF triples that are RDF entailed by SG.</p>
                <p>A possible solution μ is a <em>solution for BGP from SG under RDF entailment</em> if:</p>
                <p>(C1) The RDF triples sk(P(BGP)) are ground and RDF entailed by sk(SG).</p>
                <p>(C2) For each variable x in V(BGP), μ(x) occurs in SG or in rdfV-Minus.</p>
                <p>The multiplicity of μ in the multiset of solutions is the maximal number of distinct RDF instance mappings σ that yield a pattern instance mapping P = (μ, σ) for which μ is a
                solution.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>Please note that legal answers under RDF entailment are defined in a two-stage process. Intuitively, the possible answers are all answers that one would expect under RDF entailment, i.e.,
      all mappings such that instantiating the basic graph patterns with them results in RDF triples that are RDF entailed by the queried graph. The set of possible answers is, however, not
      necessarily finite. The next step defines which of the possible answers are actually returned as answers to the query. In this step, we restrict answers to those that correspond to ground
      triples that are entailed by the Skolemized scoping graph (C1). This limits infinite answers from blank nodes, while still preserving most users' expectations of the cardinality of the answers.
      Condition (C2) further makes sure that the query answer contains only finitely many of the axiomatic triples. The two restrictions are further explained in the next section.</p>
    </section>
    <section id="GeneralNotes"><div class="header-wrapper"><h2 id="x3-general-notes-on-entailment-regimes-informative"><bdi class="secno">3. </bdi>General Notes on Entailment Regimes (Informative)</h2><a class="self-link" href="#GeneralNotes" aria-label="Permalink for Section 3."></a></div>
      
      <p>The entailment regimes defined in this document are all defined analogously to the RDF entailment regime above. This section explains, therefore, the rationale behind the definition and the
      conditions (C1) and (C2), which are to a large extent shared among all the defined entailment regimes. Possible differences or additional constraints for the following regimes are defined in
      the respective sections.</p>
      <section id="bnodes"><div class="header-wrapper"><h3 id="x3-1-blank-nodes-in-the-queried-graph"><bdi class="secno">3.1 </bdi>Blank Nodes in the Queried Graph</h3><a class="self-link" href="#bnodes" aria-label="Permalink for Section 3.1"></a></div>
        <span id="C1-Restriction"></span>
        <p>The <a href="#condition3">third condition for extensions of basic graph pattern matching</a> requires that if blank node names are returned as bindings for a variable, then the same blank
        node name occurs in different solutions only if it corresponds to the same blank node in the graph. To illustrate why this is required, consider the following graphs, which are also
        illustrated in Figure 2:</p>
        <div style="border: thin solid #88AA88; background-color: #E8F0E8; padding: 1em 1em 1em 1em ; margin: 1em 3em 1em 0em ;">
          <table style="border-collapse: collapse;">
            <tbody>
              <tr>
                <td style="border-width:0px;font-family:monospace;">G:</td>
                <td style="border-width:0px;font-family:monospace;">ex:a ex:b _:c . &nbsp;&nbsp;</td>
                <td style="border-width:0px;font-family:monospace;">G<sub>1</sub>:</td>
                <td style="border-width:0px;font-family:monospace;">ex:a ex:b _:b1 . &nbsp;&nbsp;</td>
                <td style="border-width:0px;font-family:monospace;">G<sub>2</sub>:</td>
                <td style="border-width:0px;font-family:monospace;">ex:a ex:b _:b2 . &nbsp;&nbsp;</td>
                <td style="border-width:0px;font-family:monospace;">G<sub>3</sub>:</td>
                <td style="border-width:0px;font-family:monospace;">ex:a ex:b _:b1 .</td>
              </tr>
              <tr>
                <td style="border-width:0px;font-family:monospace;">&nbsp;</td>
                <td style="border-width:0px;font-family:monospace;">_:d ex:e ex:f .</td>
                <td style="border-width:0px;font-family:monospace;">&nbsp;</td>
                <td style="border-width:0px;font-family:monospace;">_:b2 ex:e ex:f .</td>
                <td style="border-width:0px;font-family:monospace;">&nbsp;</td>
                <td style="border-width:0px;font-family:monospace;">_:b1 ex:e ex:f .</td>
                <td style="border-width:0px;font-family:monospace;">&nbsp;</td>
                <td style="border-width:0px;font-family:monospace;">_:b1 ex:e ex:f .</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p><img src="./bnodeExample.png" alt="RDF graph for the example on bank node handling by entailment regimes"><br>
        <strong>Figure 2</strong>: A graphical representation of the RDF graphs for the example on blank nodes in the queried graph.</p>
        <p>The graph <code>G</code> simply entails <code>G<sub>1</sub></code> and <code>G<sub>2</sub></code>, but not <code>G<sub>3</sub></code> where the two blank nodes are identified. Now consider
        a basic graph pattern BGP:</p>
        <pre class="query" aria-busy="false"><code class="hljs">ex:a ex:b ?x . ?y ex:e ex:f .</code></pre>
        <p>When taking just the possible answers, without applying condition (C1) and (C2), a solution multiset for BGP would include</p>
        <div class="result">
          <span class="doc-ref" id="tablenoc1c2"></span>
          <table class="resultTable">
            <tbody>
              <tr>
                <th class="annotation"></th>
                <th>x</th>
                <th>y</th>
              </tr>
              <tr>
                <td class="annotation">μ<sub>1</sub></td>
                <td>_:b1</td>
                <td>_:b2</td>
              </tr>
              <tr>
                <td class="annotation">μ<sub>2</sub></td>
                <td>_:b2</td>
                <td>_:b1</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>Thus, we have μ<sub>1</sub>(BGP)=<code>G<sub>1</sub></code> and μ<sub>2</sub>(BGP)=<code>G<sub>2</sub></code>, and both solutions are entailed by <code>G</code>. In fact, the set of
        possible solutions is clearly infinite in this case, which is problematic with respect to <a href="#condition4">condition 4</a> from the SPARQL Query specification since the use of different
        blank node labels is considered a trivial source of infinite answers. Furthermore, <a href="#condition3">condition 3</a> requires that <code>G</code> ∪ μ<sub>1</sub>(BGP) ∪ μ<sub>2</sub>(BGP)
        is also entailed by <code>G</code>, and this is not the case in the example since this union contains <code>G<sub>3</sub></code>. The reason is that the solutions have unintended
        co-references of blank nodes that <a href="#condition3">condition 3</a> does not allow. SPARQL’s basic subgraph matching semantics respects these conditions by requiring solution mappings to
        refer to blank nodes that actually occur in the active graph, which essentially treats blank nodes as (Skolem) constants.</p>
        <p>The use of Skolemization in the definition of an entailment regime makes this understanding of blank nodes explicit while still allowing for inferred triples that are not necessarily
        present in the queried graph. For the above example, condition (C1) works as follows: let <code>skol</code> be a prefix that denotes a fresh IRI not occurring in <code>G</code> and let
        sk(<code>G</code>) be the following (Skolemized) graph:</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:a ex:b skol:c .
skol:d ex:e ex:f .</code></pre>
        <p>The Skolem function maps <code>_:c</code> to <code>skol:c</code> and <code>_:d</code> to <code>skol:d</code>. In order to satisfy (C1), the only blank nodes that can be used in the range
        of μ are <code>_:c</code> and <code>_:d</code>, since other blank nodes will either cause sk(μ(BGP)) to be non-ground since sk is not defined for the blank nodes or they might be Skolemized
        to terms not occurring in <code>G</code>, leading to non-entailed triples sk(μ(BGP)). Furthermore, we can only use a solution mapping that maps <code>x</code> to <code>_:c</code> and
        <code>y</code> to <code>_:d</code> because otherwise the entailment does not hold, assuming that <code>G</code> is actually the scoping graph. Note, however, that the scoping graph
        <code>SG</code> could equally be a graph that is RDF-equivalent to <code>G</code>, but possibly with renamed blank nodes. In this case, the solution could contain a blank node other than
        <code>_:c</code>, but importantly there is just one solution under condition (C1). Clearly, the Skolemized blank nodes should not occur in query results themselves, i.e., instead of
        <code>skol:c</code> it is expected that <code>_:c</code> is returned in the solution sequence; the Skolemization is just a way of defining conditions on possible solutions.</p>
        <p>Note that (C1) still permits derived solutions. If we assume <a href="https://w3c.github.io/rdf-semantics/spec/#rdfs_entailment" id="ref-for-index-term-rdf-schema-entailment-2">RDFS entailment</a> (RDF entailment is too weak to infer any meaningful
        consequences) and assume that <code>G</code> additionally contains the triple</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:b rdfs:subPropertyOf ex:b' .</code></pre>
        <p>the BGP</p>
        <pre class="query" aria-busy="false"><code class="hljs">ex:a ex:b' ?x . ?y ex:e ex:f .</code></pre>
        <p>still yields the same one solution.</p>
        <p>Materialization is a common implementation technique (e.g., for the RDF or RDFS regime) and it is worth pointing out that new blank nodes introduced in the saturation process are not to be
        returned in the solutions. Consider the following graph and RDFS entailment</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:s ex:p "&lt;a/&gt;"^^rdf:XMLLiteral .</code></pre>
        <p>If the system were to follow the <a href="https://w3c.github.io/rdf-semantics/spec/#rdfs_patterns" id="ref-for-index-term-rdfs-inference-rules-1">RDFS inference rules</a> the saturation process would result in the triples</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:s ex:p _:lit .
_:lit rdf:type rdfs:Literal .</code></pre>
        <p>being added to the graph, where <code>_:lit</code> is a fresh blank node associated with the literal <code>"&lt;a/&gt;"^^rdf:XMLLiteral</code>. The BGP <code>?x rdf:type rdfs:Literal</code> would
        have an empty answer. The blank node <code>_:lit</code> is not returned because it is not part of the queried graph. The Skolem function is, therefore, not defined for <code>_:lit</code> and
        a solution that maps <code>x</code> to <code>_:lit</code> will not yield a ground triple as required by (C1). Note, however, that the entailment regimes do not prescribe any particular
        implementation technique. Thus, one can use materialization in which the saturated graph contains literals in the subject position of triples or blank nodes in the predicate position in order
        to implement complete RDFS reasoning [<cite><a class="bibref" data-link-type="biblio" href="#bib-horst05" title="Completeness, Decidability and Complexity of Entailment for RDF Schema and a Semantic Extension Involving the OWL Vocabulary">HORST05</a></cite>], although only mappings that instantiate the BGP into well-formed such RDF triples can constitute
        solutions. Instead of materializing inferences, techniques based on query rewriting are equally possible to implement the regime.</p>
      </section>
      <section id="axiomaticTriples"><div class="header-wrapper"><h3 id="x3-2-answers-from-axiomatic-triples"><bdi class="secno">3.2 </bdi>Answers from Axiomatic Triples</h3><a class="self-link" href="#axiomaticTriples" aria-label="Permalink for Section 3.2"></a></div>
        
        <p>The following example mainly illustrates the use of condition (C2). Consider the query</p>
        <pre class="query" aria-busy="false"><code class="hljs">SELECT ?x WHERE { ?x rdf:type rdf:Property }</code></pre>
        <p>against a (scoping) graph containing only the triples</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:a ex:b ex:c . 
ex:d rdf:type rdf:Bag .
ex:d rdf:_1 ex:a .</code></pre>
        <p>One of the possible solutions is</p>
        <div class="result">
          <span class="doc-ref" id="table3"></span>
          <table class="resultTable">
            <tbody>
              <tr>
                <th class="annotation"></th>
                <th>x</th>
              </tr>
              <tr>
                <td class="annotation">μ<sub>1</sub></td>
                <td>ex:b</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>since <code>ex:a ex:b ex:c</code> RDF entails <code>ex:b a rdf:Property</code> (see also the <a href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfd1" id="ref-for-index-term-rdfd1-2">RDF entailment rule</a> <em>rdfD1</em>). Further, the axiomatic triples give possible solutions such as</p>
        <div class="result">
          <span class="doc-ref" id="table4"></span>
          <table class="resultTable">
            <tbody>
              <tr>
                <th class="annotation"></th>
                <th>x</th>
              </tr>
              <tr>
                <td class="annotation">μ<sub>2</sub></td>
                <td>rdf:type</td>
              </tr>
              <tr>
                <td class="annotation">μ<sub>3</sub></td>
                <td>rdf:subject</td>
              </tr>
              <tr>
                <td class="annotation">μ<sub>4</sub></td>
                <td>rdf:_1</td>
              </tr>
              <tr>
                <td class="annotation">μ<sub>5</sub></td>
                <td>rdf:_2</td>
              </tr>
              <tr>
                <td class="annotation"></td>
                <td>...</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>There are even more possible answers since <code>ex:b rdf:type rdf:Property</code> RDF entails <code>_:exb1 rdf:type rdf:Property</code> for <code>_:exb1</code> a fresh blank node, i.e., <code>_:exb1</code> is a possible solution. As shown above, condition (C1) prevents such possible
        solutions from newly introduced blank nodes to be returned as solutions. To limit the answers from the axiomatic triples condition (C2) is used:</p>
        <p>(C2) For each variable x in V(BGP), μ(x) occurs in SG or in rdfV-Minus.</p>
        <p>The possible answers μ<sub>2</sub> to μ<sub>5</sub> are considered here in greater detail. Since all these solution mappings lead to (ground) axiomatic triples when instantiating the BGP,
        (C1) is trivially satisfied.</p>
        <ol>
          <li>For the possible solution μ<sub>2</sub>, since μ<sub>2</sub>(x)=<code>rdf:type</code> occurs in SG (and also in rdfV-Minus), condition (C2) is also satisfied and this solution mapping
          is a solution.</li>
          <li>For the possible solution μ<sub>3</sub>, although μ<sub>3</sub>(x)=<code>rdf:subject</code> does not occur in SG, it occurs in rdfV-Minus and this possible solution mapping is,
          therefore, also returned as an answer.</li>
          <li>For the possible solution μ<sub>4</sub>, since μ<sub>4</sub>(x)=<code>rdf:_1</code> occurs in SG, this is a solution.</li>
          <li>For the possible solution μ<sub>5</sub>, since μ<sub>5</sub>(x)=<code>rdf:_2</code> occurs neither in SG nor in rdfV-Minus, this solution mapping is not a solution.</li>
        </ol>
        <p>Similar arguments as for <code>rdf:_2</code> can be used for <code>rdf:_n</code> with n &gt; 2. Thus the query answer contains <code>ex:b</code>, <code>rdf:_1</code>, and the subjects of
        RDF axiomatic triples of the form <code>X rdf:type rdf:Property</code> with <code>X</code> in rdfV-Minus.</p>
      </section>
      <section id="literalSubjects"><div class="header-wrapper"><h3 id="x3-3-literals-in-the-subject-position"><bdi class="secno">3.3 </bdi>Literals in the Subject Position</h3><a class="self-link" href="#literalSubjects" aria-label="Permalink for Section 3.3"></a></div>
        
        <p>Please note that solution mappings that map variables that occur in the subject position of the basic graph pattern BGP to literals will not be returned as solutions. Indeed, although
        there might be a pattern instance mapping P for the solution mapping such that P(BGP) is RDF entailed by the queried graph, but P(BGP) is not well-formed as required
        (see also <a href="https://w3c.github.io/sparql-query/spec/#sparqlTriplePatterns" id="ref-for-index-term-the-sparql-triple-patterns-definition-1">the SPARQL triple patterns definition</a>). For example, given a
        query</p>
        <pre class="query" aria-busy="false"><code class="hljs">SELECT ?x WHERE { ?x rdf:type rdf:XMLLiteral }</code></pre>
        <p>even the empty graph would RDF entail all statements</p>
        <pre class="data" aria-busy="false"><code class="hljs">xxx rdf:type rdf:XMLLiteral</code></pre>
        <p>for <code>xxx</code> a well-formed RDF XML literal, but any solution that maps <code>x</code> to an XML literal such as <code>"&lt;a&gt;abc&lt;/a&gt;"^^rdf:XMLLiteral</code> would result
        in a triple that is not a valid RDF triple.</p>
        <p>Please note that triples with literals in the subject positions are currently not considered well-formed RDF, but this
          <a href="https://w3c.github.io/sparql-query/spec/#sparqlTriplePatterns" id="ref-for-index-term-the-sparql-triple-patterns-definition-2">might change in future versions of RDF</a>. If literals were allowed in the subject position, condition (C2) would still
        guarantee finite answers.</p>
      </section>
      <section id="booleanQueries"><div class="header-wrapper"><h3 id="x3-4-boolean-queries"><bdi class="secno">3.4 </bdi>Boolean Queries</h3><a class="self-link" href="#booleanQueries" aria-label="Permalink for Section 3.4"></a></div>
        
        <p>The two conditions (C1) and (C2) also have an effect on the answers to Boolean queries. For Boolean queries that contain variables, e.g.,</p>
        <pre class="query" aria-busy="false"><code class="hljs">ASK { ?x rdf:type rdf:Property }</code></pre>
        <p>The query answer is <code>yes</code> (true) if there is at least one solution mapping (i.e., a solution that satisfies also conditions (C1) and (C2)) and it is <code>no</code> (false)
        otherwise. For example, if the queried graph is the empty graph, the query pattern has four solution triples from rdfV-Minus and hence the answer is true. For Boolean queries without
        variables the situation is slightly different. Consider, for example, the query</p>
        <pre class="query" aria-busy="false"><code class="hljs">ASK { rdf:type rdf:type rdf:Property }</code></pre>
        <p>against the empty graph. Since <code>rdf:type rdf:type rdf:Property</code> is an axiomatic triple, even the empty graph RDF entails the triple. We have two possible outcomes for such a
        Boolean query: there is a solution sequence containing a mapping ( μ ) where μ has an empty domain (it does not map any variable to anything) or there is only an empty solution sequence
        <code>( )</code>. In the first case, the query answer is <code>yes</code> (true), whereas in the second case the query answer is <code>no</code> (false). Since (C2) only operates on the
        variables in the query, only (C1) is relevant in this case. Since neither the BGP nor the queried (empty) graph contains a blank node, also (C1) holds and the query answer is <code>yes</code>
        (true).</p>
        <p>Note that even though <code>rdf:_n</code> is not in rdfV-Minus for any <code>n</code>, this means that queries such as <code>ASK { rdf:_n a rdf:Property }</code> will always be answered
        with <code>yes</code> (true) even if <code>rdf:_n</code> does not occur in the scoping graph.</p>
      </section>
      <section id="aggregates"><div class="header-wrapper"><h3 id="x3-5-aggregates-and-blank-nodes"><bdi class="secno">3.5 </bdi>Aggregates and Blank Nodes</h3><a class="self-link" href="#aggregates" aria-label="Permalink for Section 3.5"></a></div>
        
        <p>SPARQL 1.1 Query allows for aggregates in queries such as <code>COUNT</code>, <code>MIN</code>, etc. Aggregates apply expressions over groups of solutions, e.g., by counting the number of
        solutions. Thus, aggregation is layered on top of basic graph pattern matching and all solutions computed for the basic graph pattern of the query and the entailment regime in use are passed
        on to the algebra functions. For the RDF (and RDFS) entailment regime this means that since blank nodes are treated as Skolem constants due to condition (C1), each blank node contributes one
        value for the aggregates. Assume, for example, the query</p>
        <pre class="query" aria-busy="false"><code class="hljs">SELECT ?publication (COUNT(?author) AS ?numAuthors)
WHERE { ?author ex:writes ?publication . }
GROUP BY ?publication</code></pre>
        <p>evaluated over the data:</p>
        <pre class="data" aria-busy="false"><code class="hljs">_:a1 ex:writes ex:book1 . 
ex:author2 ex:writes ex:book1 .
_:a1 ex:writesBook ex:book2 .
ex:author3 ex:writesBook ex:book2 .
_:a4 ex:writesBook ex:book2 .
ex:writesBook rdfs:subPropertyOf ex:writes .</code></pre>
        <p>Under simple and RDF entailment, basic graph pattern matching finds two solutions:</p>
        <div class="result">
          <span class="doc-ref" id="aggregateExample"></span>
          <table class="resultTable">
            <tbody>
              <tr>
                <th class="annotation"></th>
                <th>author</th>
                <th>publication</th>
              </tr>
              <tr>
                <td class="annotation">μ<sub>1</sub></td>
                <td>_:a1</td>
                <td>ex:book1</td>
              </tr>
              <tr>
                <td class="annotation">μ<sub>2</sub></td>
                <td>ex:author2</td>
                <td>ex:book1</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>The results are then grouped and aggregated by algebra operators. In this case, there is only one group for <code>ex:book1</code> and the authors for the group are counted due to the
        <code>COUNT</code> aggregate over <code>author</code> resulting in the query answer:</p>
        <div class="result">
          <span class="doc-ref" id="table3_1"></span>
          <table class="resultTable">
            <tbody>
              <tr>
                <th>publication</th>
                <th>numAuthors</th>
              </tr>
              <tr>
                <td>ex:book1</td>
                <td>2</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>RDFS further gives semantics to <code>rdfs:subPropertyOf</code> and the basic graph pattern matching under RDFS entailment finds five solution mappings:</p>
        <div class="result">
          <span class="doc-ref" id="aggregateExample2"></span>
          <table class="resultTable">
            <tbody>
              <tr>
                <th class="annotation"></th>
                <th>author</th>
                <th>publication</th>
              </tr>
              <tr>
                <td class="annotation">μ<sub>1</sub></td>
                <td>_:a1</td>
                <td>ex:book1</td>
              </tr>
              <tr>
                <td class="annotation">μ<sub>2</sub></td>
                <td>ex:author2</td>
                <td>ex:book1</td>
              </tr>
              <tr>
                <td class="annotation">μ<sub>3</sub></td>
                <td>_:a1</td>
                <td>ex:book2</td>
              </tr>
              <tr>
                <td class="annotation">μ<sub>4</sub></td>
                <td>ex:author3</td>
                <td>ex:book2</td>
              </tr>
              <tr>
                <td class="annotation">μ<sub>5</sub></td>
                <td>_:a4</td>
                <td>ex:book2</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>These solutions are then processed by the algebra operators. Again, the authors for each book (now there are two groups) are counted due to the <code>COUNT</code> aggregate over
        <code>author</code>, which leads to the following result for the query under RDFS entailment:</p>
        <div class="result">
          <span class="doc-ref" id="table3_2"></span>
          <table class="resultTable">
            <tbody>
              <tr>
                <th>publication</th>
                <th>numAuthors</th>
              </tr>
              <tr>
                <td>ex:book1</td>
                <td>2</td>
              </tr>
              <tr>
                <td>ex:book2</td>
                <td>3</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>Note that the algebra operator just takes the solutions returned by the basic graph pattern matching mechanism. If, for example, blank nodes should not be counted or counted only once,
        this would mean that in general the entailment regimes must be modified to return no blank nodes or collapse blank nodes in results. A consequence of this would be that, for instance, under a
        such modified entailment regime for RDF(S) one could get less results than with simple entailment. For example, if no blank nodes were to be returned, then the books would have just one
        author under non-simple entailment.</p>
      </section>
    </section>
    <section id="RDFSEntRegime"><div class="header-wrapper"><h2 id="x4-rdfs-entailment-regime"><bdi class="secno">4. </bdi>RDFS Entailment Regime</h2><a class="self-link" href="#RDFSEntRegime" aria-label="Permalink for Section 4."></a></div>
      
      <p>Under RDFS entailment there are not only more entailments than with just RDF, which result in possibly more query answers, but RDF graphs can also be inconsistent under RDFS interpretations.
      Without any restrictions, this can result in infinite solutions since an inconsistent graph RDFS entails any consequence. The restrictions to guarantee finite query answers are the same as for
      RDF and they are repeated here so that the description of the entailment regime is self-contained. Note that, as apposed to the general <a href="#condition1">condition 1</a>, in this entailment
      regime the definition of the scoping graph also covers the case when the queried graph is RDFS-inconsistent.</p>
      <div style="text-align: left;">
        <table style="border-color: rgb(0, 0, 0); border-collapse: collapse; border-spacing: 5px; border-width: 1px">
          <tbody>
            <tr>
              <th>Name</th>
              <td>RDFS</td>
            </tr>
            <tr>
              <th>IRI</th>
              <td><a href="http://www.w3.org/ns/entailment/RDFS">http://www.w3.org/ns/entailment/RDFS</a></td>
            </tr>
            <tr>
              <th>Legal Graphs</th>
              <td>Any legal RDF graph.</td>
            </tr>
            <tr>
              <th>Legal Queries</th>
              <td>Any legal SPARQL query.</td>
            </tr>
            <tr>
              <th>Illegal Handling</th>
              <td>In case the query is illegal (syntax errors), the system <em class="rfc2119">MUST</em> raise a
                <a href="https://w3c.github.io/sparql-protocol/spec/#select-malformed" id="ref-for-index-term-malformedquery-2">MalformedQuery</a> fault. In case the queried graph is illegal (syntax errors), the system
                <em class="rfc2119">MUST</em> raise a <a href="https://w3c.github.io/sparql-protocol/spec/#select-refused" id="ref-for-index-term-queryrequestrefused-2">QueryRequestRefused</a> fault.</td>
            </tr>
            <tr>
              <th>Entailment</th>
              <td><a href="https://w3c.github.io/rdf-semantics/spec/#rdfs_entailment" id="ref-for-index-term-rdf-schema-entailment-3">RDFS Entailment</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-rdf12-semantics" title="RDF 1.2 Semantics">RDF12-SEMANTICS</a></cite>]</td>
            </tr>
            <tr>
              <th>Inconsistency</th>
              <td>The scoping graph is graph-equivalent to the active graph even if the active graph is <a href="https://w3c.github.io/rdf-concepts/spec/#dfn-inconsistent" id="ref-for-index-term-rdfs-inconsistent-1">RDFS-inconsistent</a>. If the active graph is
              <a href="https://w3c.github.io/rdf-concepts/spec/#dfn-inconsistent" id="ref-for-index-term-rdfs-inconsistent-2">RDFS-inconsistent</a>, an implementation <em class="rfc2119">MAY</em> raise a
              <a href="https://w3c.github.io/sparql-protocol/spec/#select-refused" id="ref-for-index-term-queryrequestrefused-3">QueryRequestRefused</a> fault or issue a warning and it <em class="rfc2119">SHOULD</em> generate such a fault or warning if, in the course of processing, it determines that the data or query is not compatible with the request. In
              the presence of an inconsistency the conditions on solutions still guarantee that answers are finite.</td>
            </tr>
            <tr>
              <th>Query Answers</th>
              <td>
                <p>Let G be the queried RDF graph, BGP be a basic graph pattern, V(BGP) the set of variables in BGP, B(BGP) the set of blank nodes in BGP, SG the
                  <a href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="ref-for-index-term-scoping-graph-6">scoping graph</a> for G and BGP, sk(SG) a <a href="https://w3c.github.io/rdf-semantics/spec/#skolemization" id="ref-for-index-term-skolemization-2">Skolemization</a> of SG with
                respect to a vocabulary disjoint from the vocabulary of SG and BGP. Applying sk to a term t, written sk(t), yields sk(t) if sk is defined for t and t otherwise; applying sk to a BGP,
                written sk(BGP), replaces each blank node b in BGP for which sk is defined with sk(b). The set rdfsV contains the URI references of the
                <a href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfs-vocabulary" id="ref-for-index-term-rdfs-vocabulary-1">RDFS vocabulary</a> and rdfsV-Minus is the set of URI references in rdfsV minus URI references of the form
                <code>rdf:_n</code> with <code>n</code> in <code>{1, 2, ... }</code>.</p>
                <p>A solution mapping μ is a <em>possible solution for BGP from G under RDFS entailment</em> if dom(μ) = V(BGP) and there is an RDF instance mapping σ from B(BGP) to RDF-T such that
                dom(σ)=B(BGP) and the pattern instance mapping P=(μ, σ) is such that P(BGP) are well-formed RDF triples that are RDFS entailed by SG.</p>
                <p>A possible solution μ is a <em>solution for BGP from SG under RDFS entailment</em> if:</p>
                <p>(C1) The RDF triples sk(P(BGP)) are ground and RDFS entailed by sk(SG).</p>
                <p>(C2) For each variable x in V(BGP), μ(x) occurs in SG or in rdfsV-Minus.</p>
                <p>The multiplicity of μ in the multiset of solutions is the maximal number of distinct RDF instance mappings σ that yield a pattern instance mapping P = (μ, σ) for which μ is a
                solution.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>As under RDF entailment, answers under RDFS entailment are defined in a two-stage process. Possible answers are all answers that one would expect under RDFS entailment, i.e., all mappings
      such that instantiating the basic graph patterns with them results in RDF triples that are RDFS entailed by the queried graph. To obtain always a finite set of answers, analogous conditions
      (C1) and (C2) as for the RDF entailment regime are used.</p>
      <section id="inconsistencies"><div class="header-wrapper"><h3 id="x4-1-inconsistencies-informative"><bdi class="secno">4.1 </bdi>Inconsistencies (Informative)</h3><a class="self-link" href="#inconsistencies" aria-label="Permalink for Section 4.1"></a></div>
        
        <p>An RDFS-inconsistent graph <a href="https://w3c.github.io/rdf-semantics/spec/#rdfs_entailment" id="ref-for-index-term-rdf-schema-entailment-4">RDFS entails</a> any graph, but there are limited
        possibilities to express an inconsistency in RDFS. Every inconsistency is due to a literal of type rdf:XMLLiteral, where the lexical form is a malformed XML string, e.g.,</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:a ex:b "&lt;"^^rdf:XMLLiteral .</code></pre>
        <p>in combination with a range restriction on the property, e.g.,</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:b rdfs:range rdf:XMLLiteral .</code></pre>
        <p>The first triple alone does not cause an inconsistency. It only requires that the literal <code>"&lt;"^^rdf:XMLLiteral</code> is interpreted as something that is not in the extension of
        <code>rdfs:Literal</code>. Since <code>rdfs:Literal</code> contains <code>rdf:XMLLiteral</code>, the second triple together with the first one results in an inconsistency. The following
        example illustrates that an inconsistency is not always as directly visible as in the example above and one might need to apply some inference rules to detect it. For example, consider the
        following triples (numbers are only given to explain the inferences later):</p>
        <pre class="data" aria-busy="false"><code class="hljs">(1) ex:a rdfs:subClassOf rdfs:Literal .
(2) ex:b rdfs:range ex:a .
(3) ex:c rdfs:subPropertyOf ex:b.
(4) ex:d ex:c "&lt;"^^rdf:XMLLiteral .</code></pre>
        <p>Here we can derive an inconsistency as follows:</p>
        <pre class="data" aria-busy="false"><code class="hljs">(5) ex:d ex:b "&lt;"^^rdf:XMLLiteral .    (e.g., by applying rule rdfs7 to (3) and (4))
(6) "&lt;"^^rdf:XMLLiteral rdf:type ex:a.   (e.g., by applying rule rdfs3 to (2) and (5))
(7) "&lt;"^^rdf:XMLLiteral rdf:type rdfs:Literal .   (e.g., by applying rule rdfs9 to (1) and (6))</code></pre>
        <p>At this point, the inconsistency can be detected since <code>"&lt;"</code> is not a valid lexical form for an RDF XML literal and has to be interpreted as some element that is NOT in
        <code>rdfs:Literal</code>, but at the same time it should be of type <code>rdfs:Literal</code>. The triple derived last is characteristic for an RDFS inconsistency.</p>
        <section id="uncheckedInconsistencies"><div class="header-wrapper"><h4 id="x4-1-1-effects-of-unchecked-inconsistencies"><bdi class="secno">4.1.1 </bdi>Effects of Unchecked Inconsistencies</h4><a class="self-link" href="#uncheckedInconsistencies" aria-label="Permalink for Section 4.1.1"></a></div>
          
          <p>Please note that the above definition of the RDFS entailment regimes does not require that systems <em class="rfc2119">MUST</em> generate an error or
          a warning in the case of an inconsistency, but systems <em class="rfc2119">MAY</em> generate an error or warning.
          A system <em class="rfc2119">SHOULD</em> generate such an error or warning if, in the course of processing, it determines that the data or query is not compatible with the request.</p>
          <p>If a system did not raise an error for an inconsistent active graph, it will most likely just return answers that would be answers from a consistent subgraph of the active graph. Since
          the scoping graph is taken to be equivalent to the active graph irrespective of inconsistencies, a query could still have infinitely many possible answers because an inconsistent graph
          (trivially) entails any RDF triple. Conditions (C1) and (C2) guarantee, however, finiteness even when a system tries to generate all answers without checking for consistency. In particular
          condition (C2) restricts query answers such that only answers over the (finite) vocabulary of the queried graph plus the finite subset of the RDFS vocabulary in rdfsV-Minus are
          returned.</p>
          <p>The above definition of the RDFS entailment regime is chosen such that it can be implemented efficiently. Consider, for example, a default graph containing the following triples</p>
          <pre class="data" aria-busy="false"><code class="hljs">ex:b ex:s ex:y1 .
ex:b ex:s ex:y2 .
...
ex:b ex:s ex:y10000 .
ex:a ex:d "&lt;"^^rdf:XMLLiteral .
ex:d rdfs:range rdf:XMLLiteral .</code></pre>
          <p>and a query</p>
          <pre class="query" aria-busy="false"><code class="hljs">SELECT * WHERE { ex:b ex:r ?x . ?x ex:s ?y }</code></pre>
          <p>which requires a join operation in the query processor. This graph is RDFS-inconsistent due to the last two triples, but the query processor might know (after parsing) that there is no
          <code>ex:r</code> property at all in the graph. Thus, the processor knows that it does not have to evaluate the query. However, if a consistency check was required, the processor would have
          to parse and process the query nevertheless and return an error. Such a test could be very costly (there could be more than 10,000 <code>ex:b ex:s ex:y<sub>n</sub></code> tuples).</p>
          <p>Another motivation comes from queries that require a union. For example, the query</p>
          <pre class="query" aria-busy="false"><code class="hljs">SELECT * WHERE { {BGP1} UNION {BGP2} }</code></pre>
          <p>can be executed by dispatching BGP1 and BGP2 in parallel to some processing element, streaming results back to the caller from either side of the UNION as they become available. The use
          of HTTP for streaming results places some constraints on what can be done, e.g., the error or success code must be transmitted before starting streaming the results. However, discovering
          the inconsistency from the dispatched processors might be too late for the main processor to communicate the error back to the client in a conformant manner.</p>
        </section>
      </section>
    </section>
    <section id="DEntRegime"><div class="header-wrapper"><h2 id="x5-d-entailment-regime"><bdi class="secno">5. </bdi>D-Entailment Regime</h2><a class="self-link" href="#DEntRegime" aria-label="Permalink for Section 5."></a></div>
      <span id="d-entailment"></span>
      <p>The D-entailment regime is defined for datatyped interpretations, which give semantics to datatypes. A <a href="https://w3c.github.io/rdf-concepts/spec/#section-Datatypes" id="ref-for-index-term-datatype-1">datatype</a> is an
      entity characterized by a set of character strings called lexical forms and a mapping from that set to a set of values. Formally, a datatype d is defined by three items:</p>
      <ol class="enumar">
        <li>a non-empty set of character strings called the lexical space of d;</li>
        <li>a non-empty set called the value space of d;</li>
        <li>a mapping from the lexical space of d to the value space of d, called the lexical-to-value mapping of d.</li>
      </ol>
      <p>Datatyped interpretations for an RDF graph are relativized to a <a href="https://w3c.github.io/rdf-semantics/spec/#dfn-datatype-map" id="ref-for-index-term-datatype-map-1">datatype map</a>: A datatype map D is a set of pairs consisting of a URI
      reference and a datatype such that no URI reference appears twice in the set, i.e., D can be regarded as a function from a set of URI references to a set of datatypes.</p>
      <p>While the datatypes often have a single lexical representation for each data value (i.e., each value in the datatype's value space is denoted by a single representation in its lexical
      space), this is not always the case. A <em>canonical mapping</em> is a prescribed subset of the inverse of a lexical mapping, which is one-to-one and whose domain (where possible) is the entire
      range of the lexical mapping (the value space). Thus a canonical mapping selects one lexical representation for each value in the value space. The <em>canonical representation</em> of a value
      in the value space of a datatype is the lexical representation associated with that value by the datatype's canonical mapping.</p>
      <section id="CanonicalLit"><div class="header-wrapper"><h3 id="x5-1-the-d-entailment-regime"><bdi class="secno">5.1 </bdi>The D-Entailment Regime</h3><a class="self-link" href="#CanonicalLit" aria-label="Permalink for Section 5.1"></a></div>
        <span id="CanonicalLiteral"></span>
        <p>It is possible to define one datatype as a refinement of another one. For example, in the <cite><a data-matched-text="[[[?XMLSCHEMA11-2]]]" href="https://www.w3.org/TR/xmlschema11-2/">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a></cite> specification [<cite><a class="bibref" data-link-type="biblio" href="#bib-xmlschema11-2" title="W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes">XMLSCHEMA11-2</a></cite>], the datatype
        <code>long</code> is derived from the datatype <code>integer</code>, which is itself derived from <code>decimal</code>. The datatype <code>decimal</code> is a primitive type, i.e., it is not
        a refinement of another datatype. The canonical representation of a data value does, however, not define a datatype. For example, the two literals <code>"2"^^xsd:integer</code> and
        <code>"2"^^xsd:long</code> both represent the data value 2. This raises the question which literals should be returned in query answers. Let D be a datatype map containing
        <code>xsd:decimal</code>, <code>xsd:integer</code> and <code>xsd:long</code>. We further assume the queried graph to contains the triple</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:s ex:p "01"^^xsd:long .</code></pre>
        <p>and a query</p>
        <pre class="query" aria-busy="false"><code class="hljs">SELECT * WHERE { ex:s ex:p ?x }</code></pre>
        <p>The graph D-entails any triple <code>ex:s ex:p "l"^^dt</code> where <code>dt</code> is a datatype for which the value space contains 1 and where <code>l</code> is a valid lexical form for
        the value 1. Thus, even if we restrict to the canonical represenations, we still get at least the 3 solutions <code>"1.0"^^xsd:decimal</code>, <code>"1"^^xsd:integer</code>, and
        <code>"1"^^xsd:long</code>. If D contains further datatypes that contain 1 in their value space, we would get further solutions.</p>
        <p>The D-entailment regime assumes, therefore, that for each literal there is a well-defined canonical literal. For D a datatype map, a canonical datatype mapping maps each data value
        <code>v</code> that occurs in the data space of a datatype <code>dt</code> from D to a unique datatype <code>dc</code> such that the value space of <code>dc</code> contains <code>v</code>.
        Given a literal <code>"l"^^dt</code>, the canonical literal for <code>"l"^^dt</code> is <code>"lc"^^dc</code>, where <code>lc</code> is the canonical representation for the data value that
        <code>"l"</code> represents and <code>dc</code> is the canonical datatype for the data value. For the XML Schema Datatypes one can, for example, use the primitive type as the canonical
        datatype.</p>
      </section>
      <p>Apart from the datatype support, the entailment regime is a straightforward extension of the RDF and RDFS entailment regimes and the same conditions are used to guarantee the finiteness of
      the result set, only adapted such that the vocabulary also includes the datatype URIs from the datatype map. Furthermore, all literals in solutions must be the canonical representation of the
      corresponding data value. The use of D-entailment means that further inconsistencies could arise due to datatype clashes and the same mechanisms as for handling inconsistencies as in the RDFS
      entailment regime are applied.</p>
      <div style="text-align: left;">
        <table style="border-color: rgb(0, 0, 0); border-collapse: collapse; border-spacing: 5px; border-width: 1px">
          <tbody>
            <tr>
              <th>Name</th>
              <td>D-Entailment</td>
            </tr>
            <tr>
              <th>IRI</th>
              <td><a href="http://www.w3.org/ns/entailment/D">http://www.w3.org/ns/entailment/D</a></td>
            </tr>
            <tr>
              <th>Legal Graphs</th>
              <td>Any legal RDF graph.</td>
            </tr>
            <tr>
              <th>Legal Queries</th>
              <td>Any legal SPARQL query.</td>
            </tr>
            <tr>
              <th>Illegal Handling</th>
              <td>In case the query is illegal (syntax errors), the system <em class="rfc2119">MUST</em> raise a
                <a href="https://w3c.github.io/sparql-protocol/spec/#select-malformed" id="ref-for-index-term-malformedquery-3">MalformedQuery</a> fault. In case the queried graph is illegal (syntax errors), the system <em class="rfc2119">MUST</em> raise a <a href="https://w3c.github.io/sparql-protocol/spec/#select-refused" id="ref-for-index-term-queryrequestrefused-4">QueryRequestRefused</a> fault.</td>
            </tr>
            <tr>
              <th>Entailment</th>
              <td><a href="https://w3c.github.io/rdf-semantics/spec/#D_entailment" id="ref-for-index-term-d-entailment-2">D-Entailment</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-rdf12-semantics" title="RDF 1.2 Semantics">RDF12-SEMANTICS</a></cite>]</td>
            </tr>
            <tr>
              <th>Inconsistency</th>
              <td>The scoping graph is graph-equivalent to the active graph even if the active graph is <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#def-owlconsistency" id="ref-for-index-term-d-inconsistent-1">D-inconsistent</a>.
              If the active graph is <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#def-owlconsistency" id="ref-for-index-term-d-inconsistent-2">D-inconsistent</a> with respect to the datatype map D, an implementation <em class="rfc2119">MAY</em> raise a <a href="https://w3c.github.io/sparql-protocol/spec/#select-refused" id="ref-for-index-term-queryrequestrefused-5">QueryRequestRefused</a> fault or issue a
              warning and it <em class="rfc2119">SHOULD</em> generate such a fault or warning if, in the course of processing, it determines that the data or query
              is not compatible with the request. In the presence of an inconsistency the conditions on solutions still guarantee that answers are finite.</td>
            </tr>
            <tr>
              <th>Query Answers</th>
              <td>
                <p>Systems <em class="rfc2119">MUST</em> provide a means to determine which datatype map they assume and whether they impose any limits on datatype
                lexical forms; such information could, for example, be listed in supporting documentation. A canonical literal <em class="rfc2119">MUST</em> be
                defined for all literals that use a datatype from the datatype map.</p>
                <p>Let D be the supported datatype map, G the queried RDF graph, BGP be a basic graph pattern, V(BGP) the set of variables in BGP, B(BGP) the set of blank nodes in BGP, SG the
                <a href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="ref-for-index-term-scoping-graph-7">scoping graph</a> for G and BGP, sk(SG) a <a href="https://w3c.github.io/rdf-semantics/spec/#skolemization" id="ref-for-index-term-skolemization-3">Skolemization</a> of
                SG with respect to a vocabulary disjoint from the vocabulary of SG and BGP. Applying sk to a term t, written sk(t), yields sk(t) if sk is defined for t and t otherwise; applying sk to
                a BGP, written sk(BGP), replaces each blank node b in BGP for which sk is defined with sk(b). The set Lit(SG) is the set of all literals <code>"lc"^^dc</code> such that
                <code>"l"^^dt</code> occurs in SG and <code>"lc"^^dc</code> is the canonical literal for <code>"l"^^dt</code>. The set dV contains the URI references of the
                <a href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfs-vocabulary" id="ref-for-index-term-rdfs-vocabulary-2">RDFS vocabulary</a> plus the datatype names, i.e., the URI references, for the datatypes in D; dV-Minus is the set of URI
                references in dV minus URI references of the form <code>rdf:_n</code> with <code>n</code> in <code>{1, 2, ... }</code>.</p>
                <p>A solution mapping μ is a <em>possible solution for BGP from G under D-entailment</em> if dom(μ) = V(BGP) and there is an RDF instance mapping σ from B(BGP) to RDF-T such that
                dom(σ)=B(BGP) and the pattern instance mapping P=(μ, σ) is such that P(BGP) are well-formed RDF triples that are D-entailed by SG.</p>
                <p>A possible solution μ is a <em>solution for BGP from SG under D-entailment</em> if:</p>
                <p>(C1) The RDF triples sk(P(BGP)) are ground and D-entailed by sk(SG).</p>
                <p>(C2) For each variable x in V(BGP), if μ(x) is a literal with <code>"lc"^^dc</code> the canonical literal for μ(x), then <code>"lc"^^dc</code> is in Lit(SG) and μ(x) occurs in SG
                or in dV-Minus otherwise.</p>
                <p>The multiplicity of μ in the multiset of solutions is the maximal number of distinct RDF instance mappings σ that yield a pattern instance mapping P = (μ, σ) for which μ is a
                solution.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <section id="canonicalRep"><div class="header-wrapper"><h3 id="x5-2-xml-schema-datatypes-and-canonical-lexical-representations"><bdi class="secno">5.2 </bdi>XML Schema Datatypes and Canonical Lexical Representations</h3><a class="self-link" href="#canonicalRep" aria-label="Permalink for Section 5.2"></a></div>
        
        <p>Most XML Schema Datatypes [<cite><a class="bibref" data-link-type="biblio" href="#bib-xmlschema11-2" title="W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes">XMLSCHEMA11-2</a></cite>] can be used with the D-Entailment regime. The canonical mapping, which is defined for all XML Schema Datatypes, is used
        as a means to achive finite answers. Infinite answers can otherwise occur if a datatype has infinitely many different lexical forms for a data value. For example, in the
        <a href="https://www.w3.org/TR/xmlschema11-2/#decimal" id="ref-for-index-term-decimal-1">decimal</a> datatype from the XML Schema Datatypes all of the following lexical forms represent the same value:</p>
        <ul>
          <li>100.5</li>
          <li>+100.5</li>
          <li>0100.5</li>
          <li>100.50</li>
          <li>100.500</li>
          <li>100.5000</li>
        </ul>
        <p>For the above data values, the <a href="https://www.w3.org/TR/xmlschema11-2/#decimal" id="ref-for-index-term-decimal-2">canonical lexical form</a> is: 100.5. For the values</p>
        <ul>
          <li>100</li>
          <li>+100</li>
          <li>0100</li>
          <li>100.0</li>
          <li>100.00</li>
          <li>100.000</li>
        </ul>
        <p>the <a href="https://www.w3.org/TR/xmlschema11-2/#decimal" id="ref-for-index-term-decimal-3">canonical lexical form</a> is: 100 according to <a href="https://www.w3.org/TR/xmlschema11-2/#decimal" id="ref-for-index-term-decimal-4">XSD 1.1</a>.
          <a href="https://www.w3.org/TR/xmlschema11-2/#decimal" id="ref-for-index-term-decimal-5">XSD 1.1</a> defines that, for data values that are integers, the canonical representation has no decimal point and no fractional part. This is
        different in <a href="https://www.w3.org/TR/xmlschema11-2/#decimal" id="ref-for-index-term-decimal-6">XSD 1.0</a>. <a href="https://www.w3.org/TR/xmlschema11-2/#decimal" id="ref-for-index-term-decimal-7">XSD 1.0</a> always requires a decimal point for the canonical
        representation of a decimal value. Thus, although <code>1.0</code> and <code>1</code> denote the same value, the canonical form would be <code>1.0</code> for a decimal. For integer, however,
        <a href="https://www.w3.org/TR/xmlschema11-2/#integer" id="ref-for-index-term-xsd-1-0-1">XSD 1.0</a> requires that the canonical form has no fraction digits and no decimal point. Thus, the canonical representation must be
        <code>1</code>, which is strange since <code>1</code> and <code>1.0</code> denote the same value and integers are decimals. For this reason,
        <a href="https://www.w3.org/TR/xmlschema11-2/#decimal" id="ref-for-index-term-decimal-8">XSD 1.1</a> seems better suited for use with SPARQL entailment regimes.</p>
        <p>Non-primitive datatypes in the XSD are always based on some primitive datatype, e.g., integer, byte, and short are all based on decimal and are obtained by restricting the value space to
        values without decimal point for integer and by further specifying minimal and maximal values for byte and short. Thus, if <code>"2"^^xsd:integer</code>, <code>"+02"^^xsd:short</code>, and
        <code>"+2"^^xsd:byte</code> occur in SG and we assume that the canonical datatype is the primitive type according to XSD 1.1, then all three literals contribute <code>"2"^^xsd:decimal</code>
        to Lit(SG).</p>
        <p>Condition (C2) uses the set Lit(SG) to make sure that only the canonical literals can occur in solutions, which guarantees finiteness of the answers. For example, if the queried graph
        contains</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:s ex:p "0100.50"^^xsd:decimal .
ex:s ex:p "100.00"^^xsd:decimal .
ex:s ex:p "+100"^^xsd:short .</code></pre>
        <p>and the BGP is</p>
        <pre class="query" aria-busy="false"><code class="hljs">ex:s ex:p ?x</code></pre>
        <p>then Lit(SG) contains <code>"100.5"^^xsd:decimal</code> (from the first triple) and <code>"100"^^xsd:decimal</code> (from the second and third triple since the primitive type underlying
        short is decimal and 100.00 is the same value as 100). The BGP evaluation yields two answers with <code>?x</code> binding once to <code>"100.5"^^xsd:decimal</code> and once to
        <code>"100"^^xsd:decimal</code>. Without such a restriction, one could get infinitely many answers since solutions that bind <code>?x</code> <code>"0100"^^xsd:decimal</code>,
        <code>"00100"^^xsd:decimal</code>, etc. or to <code>"100"^^xsd:integer</code> or<code>"00100"^^xsd:short</code> equally result in entailed triples.</p>
        <p>Implementations will typically achieve the desired behavior by transforming the lexical forms of data values into a canonicalized form when loading an RDF graph.</p>
      </section>
    </section>
    <section id="OWLRDFBSEntRegime"><div class="header-wrapper"><h2 id="x6-owl-2-rdf-based-semantics-entailment-regime"><bdi class="secno">6. </bdi>OWL 2 RDF-Based Semantics Entailment Regime</h2><a class="self-link" href="#OWLRDFBSEntRegime" aria-label="Permalink for Section 6."></a></div>
      
      <p>In contrast to the RDF and RDFS semantics, an RDF graph does no longer admit a unique canonical model that can be used to compute answers under the RDF-Based and Direct Semantics of OWL,
      i.e., one can no longer imagine queries to act on a unique "completed" version of the active graph. This affects the reasoning algorithms, but has only little effect on the definition of the
      OWL entailment regimes.</p>
      <p>The OWL 2 RDF-Based Semantics entailment regime assumes that queries are answered with respect to an <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#def-owldatatypemap" id="ref-for-index-term-owl-2-rdf-based-datatype-map-1">OWL 2
      RDF-Based datatype map</a> D.</p>
      <div style="text-align: left;">
        <table style="border-color: rgb(0, 0, 0); border-collapse: collapse; border-spacing: 5px; border-width: 1px">
          <tbody>
            <tr>
              <th>Name</th>
              <td>OWL 2 RDF-Based Semantics</td>
            </tr>
            <tr>
              <th>IRI</th>
              <td><a href="http://www.w3.org/ns/entailment/OWL-RDF-Based">http://www.w3.org/ns/entailment/OWL-RDF-Based</a></td>
            </tr>
            <tr>
              <th>Legal Graphs</th>
              <td>Any legal RDF graph.</td>
            </tr>
            <tr>
              <th>Legal Queries</th>
              <td>Any legal SPARQL query.</td>
            </tr>
            <tr>
              <th>Illegal Handling</th>
              <td>In case the query is illegal (syntax errors), the system <em class="rfc2119">MUST</em> raise a
                <a href="https://w3c.github.io/sparql-protocol/spec/#select-malformed" id="ref-for-index-term-malformedquery-4">MalformedQuery</a> fault. In case the queried graph is illegal (syntax errors),
                the system <em class="rfc2119">MUST</em> raise a <a href="https://w3c.github.io/sparql-protocol/spec/#select-refused" id="ref-for-index-term-queryrequestrefused-6">QueryRequestRefused</a> fault.</td>
            </tr>
            <tr>
              <th>Entailment</th>
              <td><a href="https://validator.w3.org/checklink?hide_type=all&depth=&check=Check&uri=https://www.w3.org/TR/2023/WD-sparql12-entailment-20230606/" id="ref-for-index-term-owl-2-rdf-based-entailment-1">OWL 2 RDF-Based Entailment</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-rdf-based-semantics" title="OWL 2 Web Ontology Language RDF-Based Semantics (Second Edition)">OWL2-RDF-BASED-SEMANTICS</a></cite>]</td>
            </tr>
            <tr>
              <th>Inconsistency</th>
              <td>The scoping graph is graph-equivalent to the active graph even if the active graph is <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#def-owlconsistency" id="ref-for-index-term-d-inconsistent-3">OWL 2 RDF-Based
              inconsistent</a>. If the active graph is <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#def-owlconsistency" id="ref-for-index-term-d-inconsistent-4">OWL 2 RDF-Based inconsistent</a> with respect to D, an
              implementation <em class="rfc2119">MAY</em> raise a
              <a href="https://w3c.github.io/sparql-protocol/spec/#select-refused" id="ref-for-index-term-queryrequestrefused-7">QueryRequestRefused</a> fault or issue a warning and it <em class="rfc2119">SHOULD</em> generate such a fault or warning if, in the course of processing, it determines that the data or query is not compatible with the request. In
              the presence of an inconsistency the conditions on solutions still guarantee that answers are finite.</td>
            </tr>
            <tr>
              <th>Query Answers</th>
              <td>
                <p>Systems <em class="rfc2119">MUST</em> provide a means to determine which datatype map they assume and whether they impose any limits on datatype
                lexical forms; such information could, for example, be listed in supporting documentation. A canonical literal <em class="rfc2119">MUST</em> be
                defined for all literals that use a datatype from the datatype map.</p>
                <p>Let D be a finite <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#def-owldatatypemap" id="ref-for-index-term-owl-2-rdf-based-datatype-map-2">OWL 2 RDF-Based datatype map</a>, G the queried RDF graph, BGP be a basic graph
                pattern, V(BGP) the set of variables in BGP, B(BGP) the set of blank nodes in BGP, SG the <a href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="ref-for-index-term-scoping-graph-8">scoping graph</a> for G and
                BGP, sk(SG) a <a href="https://w3c.github.io/rdf-semantics/spec/#skolemization" id="ref-for-index-term-skolemization-4">Skolemization</a> of SG with respect to a vocabulary disjoint from the vocabulary of SG and BGP. Applying sk to
                a term t, written sk(t), yields sk(t) if sk is defined for t and t otherwise; applying sk to a BGP, written sk(BGP), replaces each blank node b in BGP for which sk is defined with
                sk(b). The set Lit(SG) is the set of all literals <code>"lc"^^dc</code> such that <code>"l"^^dt</code> occurs in SG and <code>"lc"^^dc</code> is the canonical literal for
                <code>"l"^^dt</code>. The set owl2V contains the URI references of the <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#table-vocab-owl" id="ref-for-index-term-owl-2-rdf-based-vocabulary-1">OWL 2 RDF-based vocabulary</a>, which
                is taken to include the RDF and RDFS vocabularies and the OWL 2 <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Datatype_Names" id="ref-for-index-term-datatype-names-1">datatype names</a> and
                <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Facet_Names" id="ref-for-index-term-facet-names-1">facet names</a>; owl2V-Minus is the set of URI references in owl2V minus URI references of the form <code>rdf:_n</code>
                with <code>n</code> in <code>{1, 2, ... }</code>.</p>
                <p>A solution mapping μ is a <em>possible solution for BGP from G under OWL 2 RDF-Based entailment</em> if dom(μ) = V(BGP) and there is an RDF instance mapping σ from B(BGP) to RDF-T
                such that dom(σ)=B(BGP) and the pattern instance mapping P=(μ, σ) is such that P(BGP) are well-formed RDF triples that are OWL 2 RDF-Based entailed by SG with respect to owl2V and
                D.</p>
                <p>A possible solution μ is a <em>solution for BGP from SG under OWL 2 RDF-Based entailment with respect owl2V and D</em> if:</p>
                <p>(C1) The RDF triples sk(P(BGP)) are ground and OWL 2 RDF-Based entailed by sk(SG) with respect to D.</p>
                <p>(C2) For each variable x in V(BGP), if μ(x) is a literal, then μ(x) is in Lit(SG) and μ(x) occurs in SG or in owl2V-Minus otherwise.</p>
                <p>The multiplicity of μ in the multiset of solutions is the maximal number of distinct RDF instance mappings σ that yield a pattern instance mapping P = (μ, σ) for which μ is a
                solution.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>The OWL 2 RDF-Based entailment regime is a straightforward extension of the RDF, RDFS, and D-entailment regimes and the same conditions (adapted to work with the a finite subset of the OWL 2
      RDF-Based vocabulary) are used to guarantee the finiteness of the result set.</p>
      <section id="OWLRDFBSEntailments"><div class="header-wrapper"><h3 id="x6-1-entailments-under-the-owl-2-rdf-based-semantics-informative"><bdi class="secno">6.1 </bdi>Entailments under the OWL 2 RDF-Based Semantics (Informative)</h3><a class="self-link" href="#OWLRDFBSEntailments" aria-label="Permalink for Section 6.1"></a></div>
        
        <p>Before the restrictions on solutions are explained, a general note about the RDF-Based Semantics is given. The OWL 2 RDF-Based Semantics treats classes as individuals that refer to
        elements of the domain. Each such element is then associated with a subset of the domain, called the class extension. This means that semantic conditions on class extensions are only
        applicable to those classes that are actually represented by an element of the domain which can lead to less consequences than expected. An example is given by the following graph G</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:a rdf:type ex:C</code></pre>
        <p>and basic graph pattern BGP</p>
        <pre class="query" aria-busy="false"><code class="hljs">?x a [ rdf:type owl:Class ; owl:unionOf ( ex:C ex:D ) ]</code></pre>
        <p>The graph G states that <code>ex:a</code> has type <code>ex:C</code>, while the BGP asks for instances of the complex class denoting the union of <code>ex:C</code> and <code>ex:D</code>.
        One might expect that a solution mapping μ that maps <code>x</code> to <code>ex:a</code> is a solution, but this is not the case under the OWL 2 RDF-Based Semantics
        (see also [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-rdf-based-semantics" title="OWL 2 Web Ontology Language RDF-Based Semantics (Second Edition)">OWL2-RDF-BASED-SEMANTICS</a></cite>], <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Example_on_Semantic_Differences" id="ref-for-index-term-sec-7-1-1">Sec. 7.1</a>). It is guaranteed that the union of the
        class extensions for <code>ex:C</code> and <code>ex:D</code> exists as a subset of the domain; no statement in G implies, however, that this union is the class extension of any domain
        element. Thus, μ(BGP) is not entailed by G. The entailment holds, however, when the statement</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:E owl:unionOf ( ex:C ex:D )</code></pre>
        <p>is added to G. In the OWL 2 Direct Semantics, in contrast, classes denote sets and not domain elements, so G entails μ(BGP) under the Direct Semantics where, formally, G must first be
        extended with an ontology header to become well-formed.</p>
      </section>
      <section id="OWLRDFBSRestrictions"><div class="header-wrapper"><h3 id="x6-2-restriction-on-solutions"><bdi class="secno">6.2 </bdi>Restriction on Solutions</h3><a class="self-link" href="#OWLRDFBSRestrictions" aria-label="Permalink for Section 6.2"></a></div>
        <span id="C2-RDF-Based"></span>
        <p>In this section the restrictions on solutions are explained. As the previously defined regimes, a Skolemization of the queried graph and the BGP is used to limit answers that just differ
        in blank node labels (C1). An explanation for this restriction is given in the <a href="#C1-Restriction">General Notes</a> section. Under OWL 2 RDF-Based Semantics the axiomatic triples are
        not included and owl2V-Minus could equally be replaced by owl2V. The lexical representation for data values are restricted as explained for the case of
        <a href="#canonicalRep">D-entailment</a>. Infiniteness can, however, not only arise due to different lexical representations of one and the same data value as in the case of the D-entailment regime.
        Consider, for example, an ontology containing the following axiom:</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:x owl:sameAs "5"^^xsd:decimal .</code></pre>
        <p>A query, which asks for all things that are different to <code>ex:x</code> then has infinitely many possible answers since any literal different from 5 will satisfy the constraints. This
        can be formulated by the following query:</p>
        <pre class="query" aria-busy="false"><code class="hljs">SELECT ?l WHERE { ex:x owl:differentFrom ?l .}</code></pre>
        <p>Note that triples which are seemingly unrelated to the query can still influence the query results. For example, if we add to the queried ontology the triple:</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:Mary ex:hasAge "6"^^xsd:int .</code></pre>
        <p>Then the query no longer has an empty answer but returns one answer with binding <code>"6"^^xsd:int</code> for <code>l</code>.</p>
      </section>
      <section id="OWLRDFBSComputing"><div class="header-wrapper"><h3 id="x6-3-computing-query-answers-under-the-rdf-based-semantics-informative"><bdi class="secno">6.3 </bdi>Computing Query Answers under the RDF-Based Semantics (Informative)</h3><a class="self-link" href="#OWLRDFBSComputing" aria-label="Permalink for Section 6.3"></a></div>
        
        <p>The standard reasoning problems in OWL under the OWL 2 RDF-Based Semantics are semidecidable, which means that although the query answers are guaranteed to be finite, it cannot be
        guaranteed that the computation of the query results will finish in a finite amount of time. Guaranteed termination might be achieved by returning an incomplete solution sequence for certain
        queries.</p>
      </section>
      <section id="OWL2-RDFBS-Profiles"><div class="header-wrapper"><h3 id="x6-4-owl-2-profiles-and-entailment-checkers"><bdi class="secno">6.4 </bdi>OWL 2 Profiles and Entailment Checkers</h3><a class="self-link" href="#OWL2-RDFBS-Profiles" aria-label="Permalink for Section 6.4"></a></div>
        
        <p>The OWL 2 Profiles specification [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-profiles" title="OWL 2 Web Ontology Language Profiles (Second Edition)">OWL2-PROFILES</a></cite>] describes several syntactic restrictions for OWL ontologies. For ontologies that fall into these fragments,
        specialized implementation techniques can be used, which often result in a better performance.</p>
        <section id="OWL2DL"><div class="header-wrapper"><h4 id="x6-4-1-owl-2-dl"><bdi class="secno">6.4.1 </bdi>OWL 2 DL</h4><a class="self-link" href="#OWL2DL" aria-label="Permalink for Section 6.4.1"></a></div>
          
          <p>OWL 2 DL describes the largest subset of RDF graphs for which the OWL 2 Direct Semantics is defined. Systems that support OWL 2 DL can also handle ontologies that satisfy the
          restrictions of the OWL 2 EL, QL, and RL profiles because these profiles are even more restrictive.</p>
        </section>
        <section id="OWL2EL"><div class="header-wrapper"><h4 id="x6-4-2-the-owl-2-el-profile"><bdi class="secno">6.4.2 </bdi>The OWL 2 EL Profile</h4><a class="self-link" href="#OWL2EL" aria-label="Permalink for Section 6.4.2"></a></div>
          
          <p>OWL 2 EL is particularly useful in applications employing ontologies that contain very large numbers of properties and/or classes. The profile captures the expressive power used by many
          ontologies and is a subset of OWL 2 DL for which the basic reasoning problems can be performed in time that is polynomial with respect to the size of the ontology.</p>
        </section>
        <section id="OWL2QL"><div class="header-wrapper"><h4 id="x6-4-3-the-owl-2-ql-profile"><bdi class="secno">6.4.3 </bdi>The OWL 2 QL Profile</h4><a class="self-link" href="#OWL2QL" aria-label="Permalink for Section 6.4.3"></a></div>
          
          <p>OWL 2 QL is aimed at applications that use very large volumes of instance data, and where query answering is the most important reasoning task. In OWL 2 QL, conjunctive query answering
          can be implemented using conventional relational database systems. Using a suitable reasoning technique, sound and complete conjunctive query answering can be performed in LOGSPACE with
          respect to the size of the data (assertions). As in OWL 2 EL, polynomial time algorithms can be used to implement the ontology consistency and class expression subsumption reasoning
          problems.</p>
        </section>
        <section id="OWL2RLDS"><div class="header-wrapper"><h4 id="x6-4-4-the-owl-2-rl-profile"><bdi class="secno">6.4.4 </bdi>The OWL 2 RL Profile</h4><a class="self-link" href="#OWL2RLDS" aria-label="Permalink for Section 6.4.4"></a></div>
          <span id="OWL2RL"></span>
          <p>OWL 2 RL defines a syntactic subset of OWL 2 DL, which is amenable to <a href="https://www.w3.org/TR/owl2-profiles/#Profile_Specification_3" id="ref-for-index-term-implementation-using-rule-based-technologies-1">implementation using rule-based
          technologies</a>.</p>
        </section>
        <p>The OWL 2 RDF-Based Semantics can, in general, be used with arbitrary RDF graphs (OWL 2 Full ontologies) and, therefore, with all above described profiles. Taking this into account, the
        OWL 2 Conformance [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-conformance" title="OWL 2 Web Ontology Language Conformance (Second Edition)">OWL2-CONFORMANCE</a></cite>] document specifies five different kinds of <a href="http://www.w3.org/TR/owl2-test/#Entailment_Checker">entailment
        checkers</a>, which can all be used with the RDF-Based Semantics:</p>
        <ol>
          <li>OWL 2 Full entailment checkers, which take OWL 2 Full ontology documents as input;</li>
          <li>OWL 2 DL entailment checkers, which takes OWL 2 DL ontology documents as input;</li>
          <li>OWL 2 EL entailment checkers, which takes OWL 2 EL ontology documents as input;</li>
          <li>OWL 2 QL entailment checkers, which takes OWL 2 QL ontology documents as input;</li>
          <li>OWL 2 RL entailment checkers, which takes OWL 2 Full ontology documents as input.</li>
        </ol>
        <p>The OWL 2 RL entailment checker is slightly different in that OWL 2 RL entailment checkers work, as OWL 2 Full entailment checkers, on OWL 2 Full Ontologies, whereas the others make
        restrictions on the allowed input. The first four entailment checkers should not return <code>Unknown</code> when checking entailment on the respective allowed inputs. OWL 2 RL entailment
        checkers should not return <code>Unknown</code> under the RDF-Based Semantics if it is possible to derive <code>True</code> using the OWL 2 RL/RDF rules.</p>
        <p><cite><a data-matched-text="[[[?SPARQL12-SERVICE-DESCRIPTION]]]" href="https://w3c.github.io/sparql-service-description/spec/">SPARQL 1.2 Service Description</a></cite> can be used to describe what kind of entailment checker is used in the backgroud to answer
        SPARQL queries. In addition to specifying the used semantics by relating the IRI of the endpoint via the property <code>sd:defaultEntailmentRegime</code> or <code>sd:entailmentRegime</code>
        to the IRI of the entailment regime, one can relate the endpoint IRI via the property <code>sd:defaultSupportedEntailmentProfile</code> or <code>sd:supportedEntailmentProfile</code> to one of
        the following profile IRIs:</p>
        <ol>
          <li><a href="http://www.w3.org/ns/owl-profile/DL">http://www.w3.org/ns/owl-profile/Full</a> for OWL 2 Full entailment checkers;</li>
          <li><a href="http://www.w3.org/ns/owl-profile/DL">http://www.w3.org/ns/owl-profile/DL</a> for OWL 2 DL entailment checkers;</li>
          <li><a href="http://www.w3.org/ns/owl-profile/EL">http://www.w3.org/ns/owl-profile/EL</a> for OWL 2 EL entailment checkers;</li>
          <li><a href="http://www.w3.org/ns/owl-profile/QL">http://www.w3.org/ns/owl-profile/QL</a> for OWL 2 QL entailment checkers;</li>
          <li><a href="http://www.w3.org/ns/owl-profile/RL">http://www.w3.org/ns/owl-profile/RL</a> for OWL 2 RL entailment checkers.</li>
        </ol>
        <p>The property <code>sd:supportedEntailmentProfile</code> is used to indicate that a different profile applies to a certain named graph. Together with the semantics, this indictaes which
        type of OWL entailment checker is used to answer the queries.</p>
        <section id="OWL2RLRDFBSComputing"><div class="header-wrapper"><h4 id="x6-4-5-computing-query-answers-for-the-owl-2-rl-profile-with-rdf-based-semantics-informative"><bdi class="secno">6.4.5 </bdi>Computing Query Answers for the OWL 2 RL Profile with RDF-Based Semantics (Informative)</h4><a class="self-link" href="#OWL2RLRDFBSComputing" aria-label="Permalink for Section 6.4.5"></a></div>
          
          <p>For the OWL 2 RL profile, the OWL 2 RL/RDF rules can be used to compute the answers to a query. In this case, the above definition of query answers can be simplified:</p>
          <p>Let G be the queried RDF graph, BGP a basic graph pattern, SG the scoping graph for G and BGP, R the OWL 2 RL/RDF rules [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-profiles" title="OWL 2 Web Ontology Language Profiles (Second Edition)">OWL2-PROFILES</a></cite>], and FO(SG) the
          translation of SG into a first-order theory according to the OWL 2 Profiles specification [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-profiles" title="OWL 2 Web Ontology Language Profiles (Second Edition)">OWL2-PROFILES</a></cite>], i.e., each triple <code>s p o</code> in SG is
          represented by a predicate <code>T(s, p, o)</code> in FO(SG). Let P=(μ, σ) a pattern instance mapping. The solution mapping μ is a <em>possible solution for BGP from G</em> if dom(μ) =
          V(BGP), dom(σ)=B(BGP) and FO(SG) union R entails FO(P(BGP)) under the standard first-order semantics.</p>
          <p>Condition (C1) does not need to be applied in this case because blank nodes are treated as constants under the first-order semantics anyway. OWL 2 RL implementations are not required to
          include the axiomatic triples of RDF and RDFS, but they may do so. Thus, in most cases, condition (C2) does not have to be applied. Imposing (C2) does not, however, do any harm and
          guarantees finiteness should the problematic axiomatic triples be inferred and also guards the behavior on inconsistent ontologies.</p>
          <p>The fact that (C2) also takes the OWL 2 RDF-Based vocabulary into account means that query answers that use terms not present in the scoping graph may be returned, too. Consider, for
          example, an ontology containing only the triples:</p>
          <pre class="data" aria-busy="false"><code class="hljs">_:o1 rdf:type owl:ontology .
ex:C rdf:type owl:Class . 
ex:D rdf:type owl:Class .
ex:C rdfs:subClassOf ex:D .
ex:D rdfs:subClassOf ex:C .</code></pre>
          <p>The first three triples are required for a valid OWL 2 RL ontology and introduce an identifier for the ontology (<code>_:o1</code>) and typing information (<code>ex:C</code> and
          <code>ex:D</code> are classes). The ontology entails <code>ex:C owl:equivalentClass ex:D</code> and the
          <a href="https://www.w3.org/TR/owl2-profiles/#Reasoning_in_OWL_2_RL_and_RDF_Graphs_using_Rules" id="ref-for-index-term-owl-rl-rule-1">OWL RL rule</a> <code>scm-eqc2</code> derives this consequence from the ontology. Since
          <code>owl:equivalentClass</code> is in owl2V-Minus, the query</p>
          <pre class="query" aria-busy="false"><code class="hljs">SELECT ?rel WHERE { ex:C ?rel ex:D . }</code></pre>
          <p>has the answers:</p>
          <div class="result">
            <span class="doc-ref" id="table10"></span>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>rel</th>
                </tr>
                <tr>
                  <td>rdfs:subClassOf</td>
                </tr>
                <tr>
                  <td>owl:equivalentClass</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
      </section>
    </section>
    <section id="OWLDSEnRegime"><div class="header-wrapper"><h2 id="x7-owl-2-direct-semantics-entailment-regime"><bdi class="secno">7. </bdi>OWL 2 Direct Semantics Entailment Regime</h2><a class="self-link" href="#OWLDSEnRegime" aria-label="Permalink for Section 7."></a></div>
      
      <p>Intuitively, in the OWL 2 Direct Semantics entailment regime the queried graph must correspond to an OWL 2 DL ontology. The basic graph pattern of the query must correspond to an extended
      OWL 2 DL ontology, allowing variables in place of class names, object property names, datatype property names, individual names, or literals. Solutions are mappings of variables into IRIs,
      blank nodes, or literals for which the instantiated basic graph pattern corresponds to a set of OWL 2 DL axioms or an OWL 2 DL ontology that is compatible with the queried ontology and also
      entailed by it under the OWL 2 Direct Semantics.</p>
      <section id="OWLDSIntro"><div class="header-wrapper"><h3 id="x7-1-introduction"><bdi class="secno">7.1 </bdi>Introduction</h3><a class="self-link" href="#OWLDSIntro" aria-label="Permalink for Section 7.1"></a></div>
        
        <p>For the OWL 2 Direct Semantics entailment regime, semantic conditions are defined with respect to ontology structures (i.e., instances of the <strong>Ontology</strong> class as defined in
        the OWL 2 structural specification [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-syntax" title="OWL 2 Web Ontology Language Structural Specification and Functional-Style Syntax (Second Edition)">OWL2-SYNTAX</a></cite>]). Given an RDF graph G, the ontology structure for G, denoted O(G), is obtained by
        <a href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Mapping_from_RDF_Graphs_to_the_Structural_Specification" id="ref-for-index-term-mapping-the-queried-rdf-graph-into-an-owl-2-ontology-1">mapping the queried RDF graph into an OWL 2 ontology</a>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-mapping-to-rdf" title="OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition)">OWL2-MAPPING-TO-RDF</a></cite>]. This mapping is only defined for OWL 2 DL ontologies, i.e., ontologies that satisfy certain syntactic conditions.</p>
        <p>An OWL 2 DL ontology contains a set of axioms. In this section, OWL axioms are stated both in Turtle and in the functional-style syntax (FSS) that is used in the OWL 2 structural
        specification [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-syntax" title="OWL 2 Web Ontology Language Structural Specification and Functional-Style Syntax (Second Edition)">OWL2-SYNTAX</a></cite>]. A FSS axiom can correspond to several RDF triples, and the RDF triples might contain auxiliary blank nodes that are not
        part of the corresponding OWL objects and are not visible in the corresponding FSS axiom. For example, the triples</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:Peter rdf:type _:x . 
_:x rdf:type owl:Restriction ;
    owl:onProperty ex:hasFather ;
    owl:someValuesFrom ex:Person .</code></pre>
        <p>corresponds to FSS syntax axiom</p>
        <pre class="data" aria-busy="false"><code class="hljs">ClassAssertion(ObjectSomeValuesFrom(ex:hasFather ex:Person) ex:Peter)</code></pre>
        <p>The FSS may still contain blank nodes, but these correspond to OWL individuals that have no explicit names and are called
          <a href="https://www.w3.org/TR/owl2-syntax/#Anonymous_Individuals" id="ref-for-index-term-anonymous-individuals-1">anonymous individuals</a>. For example, the triple</p>
        <pre class="data" aria-busy="false"><code class="hljs">ex:Peter ex:hasBrother _:y .</code></pre>
        <p>corresponds to the FSS axiom</p>
        <pre class="data" aria-busy="false"><code class="hljs">ObjectPropertyAssertion(ex:hasBrother ex:Peter _:y)</code></pre>
        <p>While parsing an input document (containing RDF triples) into an OWL ontology, it can be necessary to rename blank nodes/anonymous individuals and there is no guarantee that the blank node
        identifier <code>_:y</code> from the above triple is used as an identifier for Peter's brother in the ontology structure. Thus, the above RDF triple could also be represented by the OWL
        axiom</p>
        <pre class="data" aria-busy="false"><code class="hljs">ObjectPropertyAssertion(ex:hasBrother ex:Peter _:somethingelse)</code></pre>
        <p>Some RDF triples that are well-formed for OWL 2 DL are mapped to OWL 2 DL axioms that carry no semantics. Axioms (triples) that carry no semantics are</p>
        <ol class="enumar">
          <li>Annotations,</li>
          <li>Entity Declarations,</li>
          <li>Ontology Properties (imports, ontology IRIs).</li>
        </ol>
        <p>Such axioms are called <em>non-logical axioms</em>, whereas axioms that do carry semantics under OWL 2 Direct Semantics are called <em>logical axioms</em>.</p>
        <section id="OWLDSImports"><div class="header-wrapper"><h4 id="x7-1-1-owl-import-directives"><bdi class="secno">7.1.1 </bdi>OWL Import Directives</h4><a class="self-link" href="#OWLDSImports" aria-label="Permalink for Section 7.1.1"></a></div>
          <span id="OWLImports"></span>
          <p>OWL provides an import directive, which allows one ontology to incorporate axioms from another ontology. Thus, if the queried RDF graph G contains a triple of the form</p>
          <pre class="data" aria-busy="false"><code class="hljs">ont owl:imports imported .</code></pre>
          <p>where <code>ont</code> is the ontology IRI or a blank node that identifies the ontology, and <code>imported</code> is the IRI of the imported ontology, then the
            <a href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Extracting_Declarations_and_the_IRIs_of_the_Directly_Imported_Ontology_Documents" id="ref-for-index-term-canonical-parsing-process-1">canonical parsing process</a> defined for OWL 2 ontologies makes
          sure that the axioms from directly and indirectly imported ontologies are taken into account.</p>
          <p>As said above, an import directive is a non-logical statement under the OWL 2 Direct Semantics, i.e., whether the statement is present in the ontology obtained by the parsing process or
          not has no effect on the logical consequences of the ontology. The statement does, however, influence the outcome of mapping an RDF graph into an OWL ontology. In the process of mapping a
          graph G into the ontology structure O(G) the directly and indirectly imported axioms are taken into account.</p>
        </section>
        <section id="OWLDSExtGrammar"><div class="header-wrapper"><h4 id="x7-1-2-extended-grammar-for-owl-2-direct-semantics-bgps"><bdi class="secno">7.1.2 </bdi>Extended Grammar for OWL 2 Direct Semantics BGPs</h4><a class="self-link" href="#OWLDSExtGrammar" aria-label="Permalink for Section 7.1.2"></a></div>
          <span id="extendedStructuralSpec"></span>
          <p>SPARQL 1.1 Query [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql12-query" title="SPARQL 1.2 Query Language">SPARQL12-QUERY</a></cite>] is only defined for basic graph patterns using a triple-based syntax. For OWL 2 Direct Semantics, an alternative syntax for
          BGPs based on the functional-style syntax or other popular OWL syntaxes seems natural, but is not part of this specification.</p>
          <p>Since the OWL 2 Direct Semantics is defined in terms of OWL objects, it is necessary to map from the triple-based BGP representation into an OWL object representation that additionally
          allows for variables. The <a href="#OWL2parsingBGPs">appendix</a> precisely specifies how the OWL 2 mapping from RDF graphs [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-mapping-to-rdf" title="OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition)">OWL2-MAPPING-TO-RDF</a></cite>] can
          be extended to basic graph patterns. The result of this mapping is an instance of an extended OWL 2 DL grammar, where the productions for <strong>Class</strong>,
          <strong>ObjectProperty</strong>, <strong>DataProperty</strong>, <strong>Individual</strong>, and <strong>Literal</strong> of the
          <a href="https://www.w3.org/TR/owl2-syntax/#Appendix:_Complete_Grammar_.28Normative.29" id="ref-for-index-term-owl-2-functional-style-syntax-grammar-1">OWL 2 functional-style syntax grammar</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-syntax" title="OWL 2 Web Ontology Language Structural Specification and Functional-Style Syntax (Second Edition)">OWL2-SYNTAX</a></cite>] are extended to
          alternatively produce variables, i.e., instances of the <a href="https://w3c.github.io/sparql-query/spec/#rVar" id="ref-for-index-term-var-1">Var</a> production from the
          <a href="https://w3c.github.io/sparql-query/spec/#grammar" id="ref-for-index-term-sparql-grammar-1">SPARQL grammar</a>.</p>
          <div>
            <p><strong>Class</strong>&nbsp;:= <strong>IRI</strong> | <strong>Var</strong><br>
            <br>
            <strong>ObjectProperty</strong>&nbsp;:= <strong>IRI</strong> | <strong>Var</strong><br>
            <br>
            <strong>DataProperty</strong>&nbsp;:= <strong>IRI</strong> | <strong>Var</strong><br>
            <br>
            <strong>Individual</strong>&nbsp;:= <strong>NamedIndividual</strong> | <strong>AnonymousIndividual</strong> | <strong>Var</strong><br>
            <br>
            <strong>Literal</strong>&nbsp;:= <strong>typedLiteral</strong> | <strong>stringLiteralNoLanguage</strong> | <strong>stringLiteralWithLanguage</strong> | <strong>Var</strong><br></p>
          </div>
        </section>
        <section id="VarTyping"><div class="header-wrapper"><h4 id="x7-1-3-variable-typing"><bdi class="secno">7.1.3 </bdi>Variable Typing</h4><a class="self-link" href="#VarTyping" aria-label="Permalink for Section 7.1.3"></a></div>
          
          <p>The Direct Semantics entailment regime requires extra triples in a basic graph pattern that give typing information for the variables. Let <code>x</code> be a variable from BGP. If BGP
          contains a triple <code>?x rdf:type TYPE</code>, where <code>TYPE</code> is one of <code>owl:Class</code>, <code>owl:ObjectProperty</code>, <code>owl:DatatypeProperty</code>, or
          <code>owl:NamedIndividual</code>, <code>?x</code> is declared to be of type <code>TYPE</code>. BGP satisfies the <em>typing constraints</em> of the entailment regime if no variable is
          declared as being of more than one type. Without type declarations for variables, parsing a BGP into ontology structures would be very difficult. Consider the following query</p>
          <pre class="query" aria-busy="false"><code class="hljs">SELECT ?s ?p ?o WHERE { ?s ?p ?o }</code></pre>
          <p>Without any restrictions this query could be a query for</p>
          <ol class="enumar">
            <li>object property assertions of the form <code>ObjectPropertyAssertion(?p ?s ?o)</code></li>
            <li>data property assertions of the form <code>DataPropertyAssertion(?p ?s ?o)</code></li>
            <li>inverse object properties, i.e., the BGP maps to <code>ObjectInverseOf(?o)</code> where <code>s</code> maps to a blank node and <code>p</code> to <code>owl:inverseOf</code>,</li>
            <li>subclasses, i.e., the BGP maps to <code>SubClassOf( ?s ?o )</code> where <code>p</code> binds to <code>rdfs:subClassOf</code>,</li>
            <li>equivalent classes, i.e., the BGP maps to <code>EquivalentClasses(?s ?o)</code> where <code>p</code> binds to <code>owl:equivalentClass</code>,</li>
            <li>disjoint classes, i.e., the BGP maps to <code>DisjointClasses(?s ?o)</code> where <code>p</code> binds to <code>owl:disjointWith</code>,</li>
            <li>...</li>
          </ol>
          <p>In order to answer the query without any typing constraints, all possible ways of mapping the BGP into ontology structures have to be considered. Even if variables can only occur in the
          position of function parameters of the functional-style syntax, the BGP from the above query can still be mapped to <code>ObjectPropertyAssertion(?p ?s ?o)</code>,
          <code>DataPropertyAssertion(?p ?s ?o)</code>, or <code>AnnotationAssertion(?p ?s ?o)</code> without variable typing information.</p>
          <p>The inclusion of type declarations from the queried ontology means that at least the non-variable terms in the query can be disambiguated without additional typing information in the
          query. For example, the BGP of the query</p>
          <pre class="query" aria-busy="false"><code class="hljs">SELECT ?x WHERE { ?x ex:p ?y }</code></pre>
          <p>is parsed into</p>
          <pre class="query" aria-busy="false"><code class="hljs">ObjectPropertyAssertion(ex:p ?x ?y)</code></pre>
          <p>if <code>ex:p</code> is declared as an object property in the queried ontology and into</p>
          <pre class="query" aria-busy="false"><code class="hljs">DataPropertyAssertion(ex:p ?x ?y)</code></pre>
          <p>if <code>ex:p</code> is declared as a data property.</p>
          <p>Note that variable declarations are local to a basic graph pattern, i.e., a declaration in one BGP is not visible within another BGP and, within different BGPs, variables can also be
          declared to be of different types.</p>
        </section>
      </section>
      <section id="OWLDSEntRegime"><div class="header-wrapper"><h3 id="x7-2-the-owl-2-direct-semantics-entailment-regime"><bdi class="secno">7.2 </bdi>The OWL 2 Direct Semantics Entailment Regime</h3><a class="self-link" href="#OWLDSEntRegime" aria-label="Permalink for Section 7.2"></a></div>
        
        <div style="text-align: left;">
          <table style="border-color: rgb(0, 0, 0); border-collapse: collapse; border-spacing: 5px; border-width: 1px">
            <tbody>
              <tr>
                <th>Name</th>
                <td>OWL 2 Direct Semantics</td>
              </tr>
              <tr>
                <th>IRI</th>
                <td><a href="http://www.w3.org/ns/entailment/OWL-Direct">http://www.w3.org/ns/entailment/OWL-Direct</a></td>
              </tr>
              <tr>
                <th>Legal Graphs</th>
                <td>Any RDF graph which can be mapped into an <a href="https://www.w3.org/TR/owl2-conformance/#Syntactic_Conformance" id="ref-for-index-term-owl-2-dl-ontology-document-1">OWL 2 DL ontology document</a>.</td>
              </tr>
              <tr>
                <th>Legal Queries</th>
                <td>Let Q be a legal SPARQL query, BGP a basic graph pattern in Q, G the queried graph, and O(G) the ontology for G. A basic graph pattern is legal for O(G) if it satisfies the typing
                constraints of the entailment regime and can be <a href="#OWL2parsingBGPs">mapped</a> into an OWL ontology or a set of OWL axioms from the <a href="#extendedStructuralSpec">extended
                OWL structural specification</a> using the declarations from O(G). The query Q is legal for the regime and O(G) if all basic graph patterns in Q are legal for O(G).</td>
              </tr>
              <tr>
                <th>Illegal Handling</th>
                <td>In case the query is illegal due to syntax errors, the system <em class="rfc2119">MUST</em> raise a
                  <a href="https://w3c.github.io/sparql-protocol/spec/#select-malformed" id="ref-for-index-term-malformedquery-5">MalformedQuery</a> fault. In case the queried graph is illegal due to syntax errors, the system <em class="rfc2119">MUST</em> raise a <a href="https://w3c.github.io/sparql-protocol/spec/#select-refused" id="ref-for-index-term-queryrequestrefused-8">QueryRequestRefused</a> fault. If the
                queried ontology is not an OWL 2 DL ontology or the query is not legal for the ontology, the system <em class="rfc2119">MAY</em> refuse the query
                and raise a <a href="https://w3c.github.io/sparql-protocol/spec/#select-refused" id="ref-for-index-term-queryrequestrefused-9">QueryRequestRefused</a> error.</td>
              </tr>
              <tr>
                <th>Entailment</th>
                <td><a href="https://www.w3.org/TR/owl2-direct-semantics/#Inference_Problems" id="ref-for-index-term-owl-2-direct-semantics-entailment-2">OWL 2 Direct Semantics</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-direct-semantics" title="OWL 2 Web Ontology Language Direct Semantics (Second Edition)">OWL2-DIRECT-SEMANTICS</a></cite>]</td>
              </tr>
              <tr>
                <th>Inconsistency</th>
                <td>If the queried ontology is inconsistent under OWL 2 Direct Semantics, the system <em class="rfc2119">MUST</em> raise an error.</td>
              </tr>
              <tr>
                <th>Query Answers</th>
                <td>
                  <p>Systems <em class="rfc2119">MUST</em> provide a means to determine which datatype map they assume and whether they impose any limits on
                  datatype lexical forms; such information could, for example, be listed in supporting documentation. A canonical literal <em class="rfc2119">MUST</em> be defined for all literals that use a datatype from the datatype map.</p>
                  <p>Let G be a legal RDF graph for the entailment regime, BGP a legal basic graph pattern, V(BGP) the set of variables in BGP, SG the
                    <a href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="ref-for-index-term-scoping-graph-9">scoping graph</a> for G and BGP, O(SG) the ontology for SG, sk a total mapping from anonymous individuals in O(SG) to IRIs
                  from a vocabulary disjoint from the vocabulary of O(SG) and BGP, sk(O(SG)) the resulting <a href="https://w3c.github.io/rdf-semantics/spec/#skolemization" id="ref-for-index-term-skolemization-5">Skolemization</a> of O(SG).
                  Applying sk to a term t, written sk(t), yields sk(t) if sk is defined for t and t otherwise; applying sk to a BGP, written sk(BGP), replaces each blank node b in BGP for which sk is
                  defined with sk(b). The set Lit(SG) is the set of all literals <code>"lc"^^dc</code> such that <code>"l"^^dt</code> occurs in SG and <code>"lc"^^dc</code> is the canonical literal
                  for <code>"l"^^dt</code>.</p>
                  <p>Let O<sub>E</sub>(BGP) be the ontology obtained by <a href="#OWL2parsingBGPs">mapping BGP into the extension of the OWL 2 structural specification</a>. Let Ax be a function that
                  takes an ontology O from the extended structural specification and returns all axioms in O. Let Ax(BGP) be the axioms in O<sub>E</sub>(BGP), and AI(BGP) the set of anonymous
                  individuals in O<sub>E</sub>(BGP). The set owl2V contains the URI references of the <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#table-vocab-owl" id="ref-for-index-term-owl-2-rdf-based-vocabulary-2">OWL 2 RDF-Based
                  vocabulary</a>, which is taken to include the RDF and RDFS vocabularies and the OWL 2 <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Datatype_Names" id="ref-for-index-term-datatype-names-2">datatype names</a> and
                  <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Facet_Names" id="ref-for-index-term-facet-names-2">facet names</a>; owl2V-Minus is the set of URI references in owl2V minus URI references of the form
                  <code>rdf:_n</code> with <code>n</code> in <code>{1, 2, ... }</code>.</p>
                  <p>A solution mapping μ is a <em>possible solution for BGP from G under the OWL 2 Direct Semantics</em> if dom(μ) = V(BGP) and there is an RDF instance mapping σ from AI(BGP) to
                  RDF-T such that dom(σ)=AI(BGP) and the pattern instance mapping P=(μ, σ) is such that P(BGP) are well-formed RDF triples that are legal for the regime (i.e., P(BGP) is a
                  variable-free and legal basic graph pattern for O(SG)) and OWL 2 Direct Semantics entailed by O(SG).</p>
                  <p>A possible solution μ is a <em>solution for BGP from SG under OWL 2 Direct Semantics</em> if:</p>
                  <p>(C1) Each logical axiom ax in sk(O<sub>E</sub>(P(BGP))) is ground and entailed by sk(O(SG)) under the OWL 2 Direct Semantics.</p>
                  <p>(C2) For each variable x in V(BGP), if μ(x) is a literal, then μ(x) is in Lit(SG) and μ(x) occurs in O(SG) or in owl2V-Minus otherwise.</p>
                  <p>(C3) Adding all axioms in O<sub>E</sub>(P(BGP)) to O(SG) results in a valid OWL 2 DL ontology.</p>
                  <p>The multiplicity of μ in the multiset of solutions is the maximal number of distinct RDF instance mappings σ that yield a pattern instance mapping P = (μ, σ) for which μ is a
                  solution.</p>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section id="OWLDSRestrictions"><div class="header-wrapper"><h3 id="x7-3-restrictions-on-solutions-informative"><bdi class="secno">7.3 </bdi>Restrictions on Solutions (Informative)</h3><a class="self-link" href="#OWLDSRestrictions" aria-label="Permalink for Section 7.3"></a></div>
        
        <p>In this section the restrictions on solutions are explained. As the previously defined regimes, a Skolemization of the queried graph and the BGP is used to limit answers that just differ
        in blank node labels (C1). An explanation for this restriction is given in the <a href="#C1-Restriction">RDF entailment regime</a> section.</p>
        <p>Condition (C2) is also applied as in the previously defined regimes and guarantees finite answers. The use of owl2V-Minus is purely for consistency with the other regimes, but could be
        omitted completely since under the Direct Semantics there are no axiomatic triples and variables can only bind to built-in terms that are also built-in entities. Built-in entities such as
        <code>owl:Thing</code> are assumed to be present in any ontology
        (see <a href="https://www.w3.org/TR/owl2-syntax/#Entity_Declarations_and_Typing" id="ref-for-index-term-table-5-1">Table 5</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-syntax" title="OWL 2 Web Ontology Language Structural Specification and Functional-Style Syntax (Second Edition)">OWL2-SYNTAX</a></cite>]),
        i.e., O(SG) automatically includes declarations for these built-in entities. As under the OWL 2 RDF-Based Semantics, (C2) prevents infinite answers that could otherwise
        come from the very powerful datatype reasoning. An example that illustrates this is given in the <a href="#C2-RDF-Based">OWL 2 RDF-Based Semantics entailment regime</a> section. An
        explanation for the restriction to canonical forms of literals is given in the <a href="#canonicalRep">D-entailment regime</a>.</p>
        <section id="OWLDSConstraints"><div class="header-wrapper"><h4 id="x7-3-1-bgp-constraints-for-owl-2-dl"><bdi class="secno">7.3.1 </bdi>BGP Constraints for OWL 2 DL</h4><a class="self-link" href="#OWLDSConstraints" aria-label="Permalink for Section 7.3.1"></a></div>
          
          <p>Condition (C3) requires that the axioms from the instantiated BGP satisfy the restrictions for OWL 2 DL ontologies, i.e., if they where added to the queried ontology, then the resulting
          ontology satisfies the restrictions of OWL 2 DL. These restrictions are in place to guarantee that the key reasoning tasks in OWL 2 with Direct Semantics are decidable. For example, for
          <em>owl:topDataProperty</em>, the <a href="https://www.w3.org/TR/owl2-syntax/#The_Restrictions_on_the_Axiom_Closure" id="ref-for-index-term-following-requirement-1">following requirement</a> has to be met in OWL 2 DL:</p>
          <blockquote>
            The <em>owl:topDataProperty</em> property occurs in Ax only in the <strong>superDataPropertyExpression</strong> part of <strong>SubDataPropertyOf</strong> axioms.
          </blockquote>
          <p>(C3) guarantees that the restrictions that are applied to the queried ontology are equally applied to the query. Since an OWL reasoner for the Direct Semantics might have to work with
          the axioms in O(SG) and the axioms from O(BGP) simultaneously, this condition also prevents that, for example, a non-simple property from O(SG) is used in a FunctionalObjectProperty axioms
          or within a cardinality restriction in O(BGP). This would violate the restrictions on non-simple properties.</p>
        </section>
        <section id="OWLDSLiteralVars"><div class="header-wrapper"><h4 id="x7-3-2-queries-with-variables-in-literal-positions"><bdi class="secno">7.3.2 </bdi>Queries with Variables in Literal Positions</h4><a class="self-link" href="#OWLDSLiteralVars" aria-label="Permalink for Section 7.3.2"></a></div>
          
          <p>Individuals can be related to a data value although this is not explicitly stated and the actual value might not occur in any axiom of the ontology. Although the
            <a href="#OWLRDFBSRestrictions">example given for the RDF-Based Semantics</a> cannot be used under the Direct Semantics, other examples can cause infinite answers without condition (C2). For
          example, consider an ontology with a data property <code>ex:dp</code> containing the axiom</p>
          <pre class="data" aria-busy="false"><code class="hljs">ClassAssertion(DataExactCardinality(2 ex:dp DatatypeRestriction(xsd:int xsd:minExclusive "5"^^xsd:int xsd:maxExclusive "8"^^xsd:int)) ex:Peter)</code></pre>
          <p>The axiom states that Peter has exactly 2 <code>ex:dp</code> successors and these successors have to be integers greater than 5 and less than 8, which means that one successor must have
          the value 6 and the other one the value 7. This axiom can be expressed in Turtle as</p>
          <pre class="data" aria-busy="false"><code class="hljs">ex:Peter a [
    a owl:Restriction ;
    owl:onProperty ex:dp ;
    owl:qualifiedCardinality "2"^^xsd:nonNegativeInteger ;
    owl:onDataRange [
        a rdfs:Datatype ;
        owl:onDatatype xsd:int ;
        owl:withRestrictions (
            [ xsd:minExclusive "5"^^xsd:int ]
            [ xsd:maxExclusive "8"^^xsd:int ]
        )
    ]
]</code></pre>
          <p>Under OWL 2 Direct Semantics, an ontology containing the above axiom entails <code>DataPropertyAssertion(ex:dp ex:Peter "6"^^xsd:int)</code> and <code>DataPropertyAssertion(ex:dp
          ex:Peter "7"^^xsd:int)</code>, which is <code>ex:Peter ex:dp "6"^^xsd:int</code> and <code>ex:Peter ex:dp "7"^^xsd:int</code> in Turtle, respectively. If the values 6 and 7 do not occur in
          other axioms, then restriction (C2) prevents such possible answers from actually being part of the solutions since the values occur neither in the ontology nor in the vocabulary
          owl2V-Minus. Consider, for example, the following query against the above ontology:</p>
          <pre class="query" aria-busy="false"><code class="hljs">SELECT ?s ?d WHERE { ?s ex:dp ?d }</code></pre>where the BGP is mapped to the following FSS element:
          <pre class="query" aria-busy="false"><code class="hljs">DataPropertyAssertion(ex:dp ?s ?d)</code></pre>
          <p>This query has an empty answer. Assume now, that the ontology is extended with the assertion:</p>
          <pre class="data" aria-busy="false"><code class="hljs">DataPropertyAssertion(ex:dp ex:Mary "6"^^xsd:int)</code></pre>
          <p>in Turtle:</p>
          <pre class="data" aria-busy="false"><code class="hljs">ex:Mary ex:dp "6"^^xsd:int .</code></pre>
          <p>The same query has now two answers:</p>
          <div class="result">
            <span class="doc-ref" id="table11"></span>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>d</th>
                </tr>
                <tr>
                  <td><code>ex:Peter</code></td>
                  <td><code>"6"^^xsd:int</code></td>
                </tr>
                <tr>
                  <td><code>ex:Mary</code></td>
                  <td><code>"6"^^xsd:int</code></td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>Adding an assertion that is not related to the assertion regarding <code>ex:Peter</code>, causes <code>ex:Peter</code> to also appears among the answers since <code>"6"^^xsd:int</code>
          occurs now in the queried ontology and (C2) is satisfied for both answers.</p>
          <p>Since there are infinitely many data values, (C2) has the advantage that a SPARQL endpoint can compute the answers to a query with BGP <code>ex:Peter ex:dp ?x</code> by replacing all
          possible data values for <code>x</code> with values that occur in the ontology. Since there still might be many literals that have to be tested and no goal directed procedure is currently
          known, systems might choose to use incomplete reasoning regarding literals and only return explicitly asserted literal values (such as <code>DataPropertyAssertion(ex:dp ex:Mary
          "6"^^xsd:int)</code> above) or enrich the explicitly asserted values with subproperty reasoning and sameAs individual reasoning. Systems <em class="rfc2119">SHOULD</em> state in their accompanying documentation when incomplete reasoning is used.</p>
        </section>
      </section>
      <section id="OWLDSHigherOrder"><div class="header-wrapper"><h3 id="x7-4-higher-order-queries-informative"><bdi class="secno">7.4 </bdi>Higher-Order Queries (Informative)</h3><a class="self-link" href="#OWLDSHigherOrder" aria-label="Permalink for Section 7.4"></a></div>
        
        <p>OWL's Direct Semantics is rooted in standard First-Order Logic, but it might seem as if the OWL Direct Semantics entailment regime goes beyond First-Order queries. For example, one can use
        the BGP <code>?x rdfs:subClassOf ?y</code> to query for pairs of sub and superclasses. This is, variables can bind to classes (representing sets of individuals) and not just to individuals or
        data values. Queries in which variables are used in positions of a First-Order Logic quantifier, will, however, be illegal since such queries cannot be mapped to OWL objects as required. For
        example, the following (illegal) query asks whether <em>some</em> or <em>all</em> brothers of Peter are persons:</p>
        <pre class="query" aria-busy="false"><code class="hljs">SELECT ?x WHERE {
    ex:Peter rdf:type [ 
        rdf:type owl:Restriction ;
        owl:onProperty ex:hasBrother ;
        ?x ex:Person . 
   ]
}</code></pre>
        <p>In functional-style syntax the BGP of the query corresponds to the axiom</p>
        <pre class="query" aria-busy="false"><code class="hljs">ClassAssertion( ?x(ex:hasBrother ex:Person) ex:Peter )</code></pre>
        <p>Here the variable occurs in the position of a quantifier and not just in the position of OWL entities such as class names or individual names.</p>
        <p>Due to the restriction that variables can only bind to terms from a finite vocabulary, any query can be reduced to a finite set of Boolean queries that can be answered under OWL's
        First-Order semantics. For example, the subclass query above can be answered, by asking for all pairs of class names from the queried ontology, whether the instantiated (hence, variable-free)
        pattern is entailed by the queried ontology under the OWL Direct Semantics. Thus, the SPARQL queries in the entailment regime still have a First-Order semantics.</p>
      </section>
      <section id="OWL2ProfilesDS"><div class="header-wrapper"><h3 id="x7-5-owl-2-entailment-checkers-and-profiles"><bdi class="secno">7.5 </bdi>OWL 2 Entailment Checkers and Profiles</h3><a class="self-link" href="#OWL2ProfilesDS" aria-label="Permalink for Section 7.5"></a></div>
        
        <p>The OWL 2 Direct Semantics is not defined for arbitrary RDF graphs, but only for graphs that satisfy the OWL 2 DL constraints. The OWL 2 profiles further restrict the allowed inputs.
        <a href="#OWL2-RDFBS-Profiles">As for the RDF-Based Semantics</a>, <cite><a data-matched-text="[[[?SPARQL12-SERVICE-DESCRIPTION]]]" href="https://w3c.github.io/sparql-service-description/spec/">SPARQL 1.2 Service Description</a></cite> can be used to describe
        what kind of <a href="http://www.w3.org/TR/owl2-test/#Entailment_Checker">entailment checkers</a> is used in the backgroud to answer SPARQL queries. In addition to specifying the used
        semantics by relating the IRI of the endpoint via the property <code>sd:defaultEntailmentRegime</code> or <code>sd:entailmentRegime</code> to the IRI of the entailment regime, one can relate
        the endpoint IRI via the property <code>sd:defaultSupportedEntailmentProfile</code> or <code>sd:supportedEntailmentProfile</code> to one of the following profile IRIs:</p>
        <ol>
          <li><a href="http://www.w3.org/ns/owl-profile/DL">http://www.w3.org/ns/owl-profile/DL</a> for OWL 2 DL entailment checkers;</li>
          <li><a href="http://www.w3.org/ns/owl-profile/EL">http://www.w3.org/ns/owl-profile/EL</a> for OWL 2 EL entailment checkers;</li>
          <li><a href="http://www.w3.org/ns/owl-profile/QL">http://www.w3.org/ns/owl-profile/QL</a> for OWL 2 QL entailment checkers;</li>
          <li><a href="http://www.w3.org/ns/owl-profile/RL">http://www.w3.org/ns/owl-profile/RL</a> for OWL 2 RL entailment checkers.</li>
        </ol>
        <p>The profile IRI together with the semantics then indicates what kind of <a href="http://www.w3.org/TR/owl2-test/#Entailment_Checker">entailment checker</a> is used in the backgroud and
        what syntactic restrictions this tool makes.</p>
      </section>
    </section>
    <section id="RIFCoreEnt"><div class="header-wrapper"><h2 id="x8-rif-core-entailment"><bdi class="secno">8. </bdi>RIF Core Entailment</h2><a class="self-link" href="#RIFCoreEnt" aria-label="Permalink for Section 8."></a></div>
      
      <p>The RIF RDF Compatibility document [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-rdf-owl" title="RIF RDF and OWL Compatibility (Second Edition)">RIF-RDF-OWL</a></cite>] specifies the interoperation between RIF and the data and ontology languages RDF, RDF Schema, and OWL. Interoperation is
      defined with respect to the semantics of RIF-RDF combinations. RIF-RDF combinations (or simply, combinations) consist of a RIF document and a set of RDF graphs. For the purpose of RIF Core
      entailment, we will only be concerned with combinations involving the single RDF graph comprised of the Skolemization of the merge of the scoping graph and any graphs imported from the RIF
      document. The scoping graph considered does not include the statement that refers to the RIF document (more on this in <a href="#RIFDocReferences">8.4</a>). The semantics of combinations are
      defined in terms of pairs of RIF and RDF interpretations. Each pairing is governed by a number of conditions that maintain a correspondence between RIF semantic structures (interpretations) and
      RDF interpretations. This maintained correspondence ensures the proper interpretation of names. It also maintains a correspondence between RDF triples of the form <code>s p o</code>, RIF frames
      of the form <code>s[p-&gt;o]</code>, and their respective terms.</p>
      <p>These conditions are enforced on a <em><a href="https://www.w3.org/TR/rif-rdf-owl/#def-common-rif-rdf-interpretation" id="ref-for-index-term-common-rif-rdf-interpretation-1">common RIF-RDF interpretation</a></em> that is the basis
      for the standard model-theoretic notions of satisfiability and entailment with respect to common RIF-RDF interpretations, and when they are a model of a combination. A common RIF-RDF
      interpretation <a href="https://www.w3.org/TR/rif-rdf-owl/#def-rif-rdf-satisfies" id="ref-for-index-term-satisfies-1">satisfies</a> a combination if the semantic multi-structure (the first component of the common
      interpretation) is a RIF BLD <a href="https://www.w3.org/TR/rif-bld/#def-bld-model-formula" id="ref-for-index-term-model-1">model</a> of the RIF document <em>and</em> the simple interpretation satisfies the
      RDF graph(s) in the combination. Such a common RIF-RDF interpretation can also be said to satisfy
      <a href="https://www.w3.org/TR/rif-rdf-owl/#def-generalized-rdf-graph" id="ref-for-index-term-generalized-rdf-graphs-1">generalized RDF graphs</a> that are (intuitively) those RDF graphs satisfied by the simple interpretation modified
      to correspond with the interpretation of the RIF document. The <em>RIF-Simple-entails</em> relationship builds on this and is the basis for the semantics of answers to queries using this
      entailment regime. Other similar RIF entailment relationships can be built for profiles such as those that have already been defined in this document as entailment regimes (RDF, RDFS, OWL
      Direct and RDF-Based Semantics, etc.). In addition and as described in [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-owl-rl" title="OWL 2 RL in RIF (Second Edition)">RIF-OWL-RL</a></cite>], an OWL 2 RL ontology can be mapped to a customized RIF Core rule set.</p>
      <p>The compatibility document defines 3 additional notions of RIF satisfiability with respect to a combination that builds on simple entailment: RIF-RDF, RIF-RDFS, and RIF-D satisfiability. We
      define answers with respect to RDF graphs that are <em>RIF-Simple-entailed</em> by the combination formed from the (Skolemized) scoping graph and a referenced <em>RIF-Core</em>
      [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-core" title="RIF Core Dialect (Second Edition)">RIF-CORE</a></cite>] document. These additional notions of RIF satisfiability can similarly be used as the basis for more expressive RIF Core entailment regimes.</p>
      <section id="SimpeRIFCoreEntRegime"><div class="header-wrapper"><h3 id="x8-1-simple-rif-core-entailment-regime"><bdi class="secno">8.1 </bdi>(Simple) RIF Core Entailment Regime</h3><a class="self-link" href="#SimpeRIFCoreEntRegime" aria-label="Permalink for Section 8.1"></a></div>
        
        <table style="border-color: rgb(0, 0, 0); border-collapse: collapse; border-spacing: 5px; border-width: 1px">
          <tbody>
            <tr>
              <th>Name</th>
              <td>(Simple) RIF Core Entailment Regime</td>
            </tr>
            <tr>
              <th>IRI</th>
              <td><a href="http://www.w3.org/ns/entailment/RIF">http://www.w3.org/ns/entailment/RIF</a></td>
            </tr>
            <tr>
              <th>Legal Graphs</th>
              <td>RDF graphs containing a triple with <code>rif:usedWithProfile</code> as predicate (see <a href="#RIFDocReferences">8.4</a>) and where the imported RIF document is safe and does not
              include a binary Import statement with a profile other than Simple. If the RIF document imports RDF graphs, they must also use the Simple profile and these graphs are considered along
              with a version of the scoping graph formed without this single triple.</td>
            </tr>
            <tr>
              <th>Legal Queries</th>
              <td>Any legal SPARQL query.</td>
            </tr>
            <tr>
              <th>Illegal Handling</th>
              <td>In case the query is illegal (syntax errors), the system <em class="rfc2119">MUST</em> raise a
                <a href="https://w3c.github.io/sparql-protocol/spec/#select-malformed" id="ref-for-index-term-malformedquery-6">MalformedQuery</a> fault. In case the queried graph is illegal (syntax errors), the system <em class="rfc2119">MUST</em> raise a <a href="https://w3c.github.io/sparql-protocol/spec/#select-refused" id="ref-for-index-term-queryrequestrefused-10">QueryRequestRefused</a> fault.</td>
            </tr>
            <tr>
              <th>Entailment</th>
              <td><a href="https://www.w3.org/TR/rif-rdf-owl/#def-simple-entails" id="ref-for-index-term-rif-simple-entailment-2">RIF-Simple entailment</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-rdf-owl" title="RIF RDF and OWL Compatibility (Second Edition)">RIF-RDF-OWL</a></cite>]</td>
            </tr>
            <tr>
              <th>Inconsistency</th>
              <td>As with the RDF entailment regime, any legal RDF graph (by itself) is satisfiable; no explicit inconsistency handling is required.</td>
            </tr>
            <tr>
              <th>Query Answers</th>
              <td>
                <p>Let G be the merge of the queried RDF graph (without the <code>rif:usedWithProfile</code> statement) along with any RDF graphs included in the referenced RIF Core document, BGP be
                a basic graph pattern, V(BGP) the set of variables in BGP, B(BGP) the set of blank nodes in BGP, SG the <a href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="ref-for-index-term-scoping-graph-10">scoping
                graph</a> for G and BGP, and sk(SG) a <a href="https://w3c.github.io/rdf-semantics/spec/#skolemization" id="ref-for-index-term-skolemization-6">Skolemization</a> of SG with respect to a vocabulary disjoint from the vocabulary of SG
                and BGP. Applying sk to a term t, written sk(t), yields sk(t) if sk is defined for t and t otherwise; applying sk to a BGP, written sk(BGP), replaces each blank node b in BGP for
                which sk is defined with sk(b).</p>
                <p>A solution mapping μ is a <em>solution for BGP from G under RIF-Simple entailment</em> if dom(μ) = V(BGP) and there is an RDF instance mapping σ from B(BGP) to RDF-T such that
                dom(σ)=B(BGP) and the pattern instance mapping P=(μ, σ) is such that sk(P(BGP)) are ground, well-formed RDF triples that are RIF-Simple entailed by the
                <a href="https://www.w3.org/TR/rif-rdf-owl/#def-rif-rdf-combination" id="ref-for-index-term-rif-rdf-combination-1">RIF-RDF combination</a> formed with the safe RIF Core document referenced from SG via the object of the
                <code>rif:usedWithProfile</code> statement.</p>
                <p>The multiplicity of μ in the multiset of solutions is the maximal number of distinct RDF instance mappings σ that yield a pattern instance mapping P = (μ, σ) for which μ is a
                solution.</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>For example, consider the <a href="http://www.w3.org/2005/rules/wiki/Class_Membership">Class_Membership</a> test case from the RIF test cases repository comprised of the following RDF
        graph and imported RIF Core document (in the <a href="https://www.w3.org/TR/rif-bld/#EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-BLD_.28Informative.29" id="ref-for-index-term-presentation-syntax-1">presentation syntax</a>):</p>
        <pre class="data" aria-busy="false"><code class="hljs">(1) ex:Adrian ex:isChildOf ex:Uwe .
(2) ex:Adrian rdf:type ex:Male .
(3) ex:Uwe rdf:type ex:Male  .
(4) &lt;Class_Membership_rule.rifps&gt; rif:usedWithProfile &lt;http://www.w3.org/ns/entailment/Simple&gt; .</code></pre>
        <pre class="query" aria-busy="false"><code class="hljs">Group ( 
        Forall ?X ?Y ( 
               ?Y [ ex:isFatherOf -&gt; ?X ] :- And( ?X [ ex:isChildOf -&gt; ?Y  ] 
                                                  ?Y [ rdf:type -&gt; ex:Male ] 
        )  
    )
)</code></pre>
        <p>The SPARQL query below can be dispatched against the graph using the (Simple) RIF Core Entailment Regime:</p>
        <pre class="query" aria-busy="false"><code class="hljs">SELECT ?father ?child WHERE { ?father ex:isFatherOf ?child . }</code></pre>
        <p>producing the single solution:</p>
        <div class="result">
          <span class="doc-ref" id="table11RIF"></span>
          <table class="resultTable">
            <tbody>
              <tr>
                <th class="annotation"></th>
                <th>father</th>
                <th>child</th>
              </tr>
              <tr>
                <td class="annotation">μ<sub>1</sub></td>
                <td><code>ex:Uwe</code></td>
                <td><code>ex:Adrian</code></td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>This follows from the fact that the result of applying a pattern instance mapping comprised of the solution μ<sub>1</sub> above and an empty mapping for blank nodes against the BGP in the
        query, i.e., sk(P(?father ex:isFatherOf ?child)), is RIF-Simple entailed by the RIF-RDF combination formed from the RIF Core document and a graph comprised of just statements (1)-(3).</p>
      </section>
      <section id="RIFCustomRuleSets"><div class="header-wrapper"><h3 id="x8-2-custom-rulesets-for-common-vocabulary-interpretations-informative"><bdi class="secno">8.2 </bdi>Custom Rulesets for Common Vocabulary Interpretations (Informative)</h3><a class="self-link" href="#RIFCustomRuleSets" aria-label="Permalink for Section 8.2"></a></div>
        
        <p>RDF vocabulary such as RDFS and OWL 2 RL can be interpreted within this entailment regime through the use of custom rulesets. For example, RDFS entailment can be implemented by using the
        <em>R<sup>RDFS</sup></em> ruleset specified in [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-rdf-owl" title="RIF RDF and OWL Compatibility (Second Edition)">RIF-RDF-OWL</a></cite>]. Similarly, the RIF Core rules in [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-owl-rl" title="OWL 2 RL in RIF (Second Edition)">RIF-OWL-RL</a></cite>] can be used to capture an
        axiomatization of OWL 2 RL.</p>
      </section>
      <section id="RIFFiniteAnswers"><div class="header-wrapper"><h3 id="x8-3-finite-answer-set-conditions-informative"><bdi class="secno">8.3 </bdi>Finite Answer Set Conditions (Informative)</h3><a class="self-link" href="#RIFFiniteAnswers" aria-label="Permalink for Section 8.3"></a></div>
        
        <p>Traditionally, one of the ways to ensure that the underlying decision problems associated with a Horn clause knowledge representation are decidable is to prevent the use of function
        symbols. RIF-Core's syntax permits built-in functions in the body of a rule. A Horn Clause query is said to be safe it it has a finite set of answers. In order to ensure that a Horn Clause
        logic programming language is complete (i.e., it guarantees all answers to every query) it is necessary to test whether a given query is safe [<cite><a class="bibref" data-link-type="biblio" href="#bib-safety" title="Saftety of recursive horn clauses with infinite relations">SAFETY</a></cite>].</p>
        <p>Certain <a href="https://www.w3.org/TR/rif-core/#Safeness" id="ref-for-index-term-safety-conditions-1"><strong>safety conditions</strong></a> on logic programs permit the use of cyclic references between built-in function symbols
        defined by an external procedure. RIF-Core's notion of strong safety facilitates the ability to construct a <em>finite grounding</em> which addresses both components of condition C4 regarding
        SPARQL extensions and their solution sets: uniqueness and finiteness.</p>
        <p>Consider the following strongly safe RIF Core document, scoping graph, and query, for which an answer set can be determined from the unique, minimal, and finite RIF-RDF model of the
        combination (despite the use of a built-in predicate). In this query, the user asks for all hospital episodes (or visits) and the various health care events they subsume (as indicated by the
        <em>ex:hasHospitalization</em> predicate). The <em>ex:hasHospitalization</em> predicate is defined (in the strongly safe RIF Core document) as a relation between a health care event with the
        larger hospital encounter event it is a part of based on the ordering of the dates associated with the events. The ordering constraint is enforced through the use of the
        pred:dateTime-greater-than and pred:dateTime-less-than external built-in predicates.</p>
        <pre class="query" aria-busy="false"><code class="hljs">Forall ?x ?y ?z ?u
  ( ?EVT[ ex:hasHospitalization -&gt; ?HOSP] 
     :- And( ?HOSP # ex:HospitalEncounter
             ?HOSP [ ex:startsNoEarlierThan -&gt; ?ENCOUNTER_START
                     ex:stopsNoLaterThan    -&gt; ?ENCOUNTER_STOP  ]
             ?EVT # ex:HealthCareEvent
             ?EVT [ ex:startsNoEarlierThan -&gt; ?EVT_START_MIN ]
             pred:dateTime-greater-than(xsd:dateTime(?EVT_START_MIN) xsd:dateTime(?ENCOUNTER_START))
             pred:dateTime-less-than(xsd:dateTime(?EVT_START_MIN) xsd:dateTime(?ENCOUNTER_STOP)))
  )</code></pre>
        <pre class="data" aria-busy="false"><code class="hljs">(1) &lt;.. path to above document ..&gt; rif:usedWithProfile &lt;http://www.w3.org/ns/entailment/Simple&gt;.
(2) ex:Operation1 rdf:type ex:HealthCareEvent;
(3)               ex:startsNoEarlierThan "2000-12-01T05:00:00"^^xsd:dateTime ;
(4)               ex:startsNoEarlierThan "2000-12-11T16:31:00"^^xsd:dateTime .
(5) ex:Episode1   rdf:type ex:HospitalEncounter;
(6)               ex:startsNoEarlierThan "2000-11-31T12:00:00"^^xsd:dateTime ;
(7)               ex:stopsNoEarlierThan  "2000-12-26T05:36:00"^^xsd:dateTime .
(8) ex:XRay1      rdf:type ex:HealthCareEvent;
(9)               ex:startsNoEarlierThan "1960-01-10T03:00:00"^^xsd:dateTime ;
(10)              ex:stopsNoEarlierThan  "1960-01-11T07:00:00"^^xsd:dateTime .</code></pre>
        <pre class="query" aria-busy="false"><code class="hljs">SELECT ?EVT ?HOSP WHERE { ?EVT ex:hasHospitalization ?HOSP }</code></pre>
        <p>This should result in the following bindings as a result of the rules and the triples (2)-(7) from a SPARQL service that implements the RIF Core entailment regime:</p>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>EVT</th>
                <th>HOSP</th>
              </tr>
              <tr>
                <td>ex:Operation1</td>
                <td>ex:Episode1</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section id="RIFDocReferences"><div class="header-wrapper"><h3 id="x8-4-referencing-a-rif-document"><bdi class="secno">8.4 </bdi>Referencing a RIF Document</h3><a class="self-link" href="#RIFDocReferences" aria-label="Permalink for Section 8.4"></a></div>
        
        <p>RIF RDF and OWL Compatibility [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-rdf-owl" title="RIF RDF and OWL Compatibility (Second Edition)">RIF-RDF-OWL</a></cite>] defines the entailments of combinations (R, G) where R (a RIF rule set) includes an import of G (an RDF graph).</p>
        <p>For the inverse of such a reference, i.e., the import of a RIF document into an RDF graph the designated RDF predicate <code>rif:usedWithProfile</code> enables an import to be specified
        from the graph G instead of from R.</p>
        <p>In the simple usage the graph G is a plain RDF graph and <code>rif:usedWithProfile</code> is used to combine that graph with one or more externally defined RIF rule sets. In this usage
        each subject of a <code>rif:usedWithProfile</code> assertion should be the URI for a RIF rule set (which may be encoded in RIF-XML or RIF-in-RDF) and the object should be an import profile as
        defined in RIF RDF and OWL Compatibility [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-rdf-owl" title="RIF RDF and OWL Compatibility (Second Edition)">RIF-RDF-OWL</a></cite>].</p>
        <p>The semantics of <code>rif:usedWithProfile</code> is explained in the following subsection.</p>
        <section id="RIFUsedWithProfile"><div class="header-wrapper"><h4 id="x8-4-1-semantics-of-rif-usedwithprofile"><bdi class="secno">8.4.1 </bdi>Semantics of <code>rif:usedWithProfile</code></h4><a class="self-link" href="#RIFUsedWithProfile" aria-label="Permalink for Section 8.4.1"></a></div>
          
          <p>A RIF-aware processor shall treat any RDF graph <strong>G</strong> as a RIF-RDF or RIF-OWL combination (see [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-rdf-owl" title="RIF RDF and OWL Compatibility (Second Edition)">RIF-RDF-OWL</a></cite>]) as follows:</p>
          <p>Let <strong>G'</strong> be the graph obtained from <strong>G</strong> by removing all triples with predicate <code>rif:usedWithProfile</code>. Then <strong>G</strong> is to be treated by
          a RIF-aware processor as the ruleset <strong>R</strong>:</p>
          <pre class="query">Document (
  Imports(<code aria-busy="false" class="hljs">R1'</code>) 
  ...
  Imports(<code aria-busy="false" class="hljs">Rn'</code>)
  Imports(G' <code aria-busy="false" class="hljs">P1</code>)
  ...
  Imports(G' <code aria-busy="false" class="hljs">Pn</code>)
)</pre>
          <p>where <code>R<sub>i</sub></code> and <code>P<sub>i</sub></code> are the subjects/objects respectively of triples of form:</p>
          <pre class="data"><code aria-busy="false" class="hljs">Ri</code> rif:usedWithProfile <code aria-busy="false" class="hljs">Pi</code> .</pre>
          <p>and <code>R<sub>i</sub>'</code> is the RIF document corresponding to an IRI Reference <code>R<sub>i</sub></code>.</p>
          <p><strong>Remark:</strong> Note that the fact that <strong>G'</strong> is treated as being imported with all profiles <code>P<sub>1</sub></code> ... <code>P<sub>n</sub></code> enforces
          <strong>G'</strong> to be treated according to the highest profiles among <code>P<sub>1</sub></code> ... <code>P<sub>n</sub></code>, see also Section 5.2 of
          [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-rdf-owl" title="RIF RDF and OWL Compatibility (Second Edition)">RIF-RDF-OWL</a></cite>].</p>
        </section>
        <section id="RIFDereferencing"><div class="header-wrapper"><h4 id="x8-4-2-dereferencing-rif-documents-informative"><bdi class="secno">8.4.2 </bdi>Dereferencing RIF Documents (Informative)</h4><a class="self-link" href="#RIFDereferencing" aria-label="Permalink for Section 8.4.2"></a></div>
          
          <p>Note that this specification does not define how an RDF store refers to or stores the RIF document <code>R<sub>i</sub>'</code> corresponding to a IRI Reference
          <code>R<sub>i</sub></code>. Alternative methods include, but are not limited to:</p>
          <ol>
            <li>HTTP dereferencing</li>
            <li>Encoding RIF documents within named graphs within the dataset</li>
          </ol>
          <p>We will sketch both methods in the following.</p>
          <section id="RIFHTTPDereferencing"><div class="header-wrapper"><h5 id="x8-4-2-1-http-dereferencing"><bdi class="secno">8.4.2.1 </bdi>HTTP Dereferencing</h5><a class="self-link" href="#RIFHTTPDereferencing" aria-label="Permalink for Section 8.4.2.1"></a></div>
            
            <p>This method assumes that <code>R<sub>i</sub></code> is an HTTP dereferenceable IRI which returns a RIF/XML document <code>R<sub>i</sub>'</code>.</p>
          </section>
          <section id="RIFDocsAsNamedGraphs"><div class="header-wrapper"><h5 id="x8-4-2-2-encoding-rif-documents-within-named-graphs-in-the-dataset"><bdi class="secno">8.4.2.2 </bdi>Encoding RIF documents within named graphs in the dataset</h5><a class="self-link" href="#RIFDocsAsNamedGraphs" aria-label="Permalink for Section 8.4.2.2"></a></div>
            
            <p>In some scenarios, one may want to access RIF rulesets from the same RDF store where the queried RDF graphs are stored.</p>
            <p>This method therefore needs an encoding of RIF documents into an RDF graph, such as for instance the one sketched in [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-in-rdf" title="RIF In RDF (Second Edition)">RIF-in-RDF</a></cite>], which allows to store RIF
            documents as RDF graphs within the data store and retrieve the RIF ruleset encoded in an RDF graph by a respective mapping (such as the inverse mapping XTr described in Section 6 of
            [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-in-rdf" title="RIF In RDF (Second Edition)">RIF-in-RDF</a></cite>]). Since <a href="https://w3c.github.io/sparql-query/spec/#rdfDataset" id="ref-for-index-term-rdf-datasets-1">RDF datasets</a> already provide a mechanism for accessing an RDF graph by an
            identifying IRI, in this setting, RDF encoded RIF documents <code>R<sub>i</sub>'</code> can simply be made available as named graphs with graph name <code>R<sub>i</sub></code> within the
            dataset.</p>
            <p>For instance, assuming that the IRI reference <code>&lt;http://example.org/r1&gt;</code> denotes an RDF encoded RIF document consisting of the single RIF rule as follows</p>
            <pre class="query" aria-busy="false"><code class="hljs">Document(
 Prefix(foaf &lt;http://xmlns.com/foaf/0.1/&gt;)
 Prefix(rel &lt;http://purl.org/vocab/relationship/&gt;)

 Group
 (
   Forall ?S ?O (
       ?S [ foaf:knows ?O ] :- ?S [ rel:worksWith ?O ]
   )
 )
)</code></pre>
            <p>which can be encoded in RDF according to [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-in-rdf" title="RIF In RDF (Second Edition)">RIF-in-RDF</a></cite>] as follows:</p>
            <pre class="data" aria-busy="false"><code class="hljs">@prefix : &lt;http://www.w3.org/2007/rif#&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix rel: &lt;http://purl.org/vocab/relationship/&gt; .

&lt;http://example.org/r1&gt; a :Document;
 :directives () ;
 :payload [  rdf:type :Group ;
    :sentences  ( 
       [ rdf:type :Forall; 
         :formula  [ a :Implies ;
          :if  [ rdf:type :Frame ; 
                 :object [ rdf:type :Var; :varname "S" ] ; 
                 :slots  ( [ rdf:type :Slot; :slotkey   [ 
                                 rdf:type :Const ; 
                                 :constIRI "http://purl.org/vocab/relationship/worksWith" ];
                             :slotvalue [ rdf:type :Var; :varname "O" ] ] )
               ];
          :then [ rdf:type :Frame ; 
                 :object [ rdf:type :Var; :varname "S" ] ; 
                 :slots  ( [ rdf:type :Slot; :slotkey   [  
                                 rdf:type :Const ; 
                                 :constIRI "http://xmlns.com/foaf/0.1/knows" ];
                             :slotvalue [ rdf:type :Var; :varname "O" ] ] )
               ] ] ;
          :vars  ( [rdf:type :Var;  :varname "S" ] [ rdf:type :Var; :varname "O" ] ) ] ) 
] .</code></pre>
            <p>Let the dataset consist of the single named graph <code>&lt;http://example.org/r1&gt;</code> and the default graph consist of the two triples</p>
            <pre class="data" aria-busy="false"><code class="hljs">@prefix : &lt;http://www.example.org/&gt; . 
@prefix rel: &lt;http://purl.org/vocab/relationship/&gt; . 
@prefix rif: &lt;http://www.w3.org/2007/rif#&gt; .

:bob rel:worksWith :alice .
&lt;http://example.org/r1&gt; rif:usedWithProfile &lt;http://www.w3.org/ns/entailment/Simple&gt; .</code></pre>
            <p>then the SPARQL query</p>
            <pre class="query" aria-busy="false"><code class="hljs">SELECT * 
WHERE { ?S ?P ?O }</code></pre>
            <p>returns</p>
            <div class="result">
              <span class="doc-ref" id="tableRESULTRIF"></span>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>S</th>
                    <th>P</th>
                    <th>O</th>
                  </tr>
                  <tr>
                    <td><code>:bob</code></td>
                    <td><code>foaf:knows</code></td>
                    <td><code>:alice</code></td>
                  </tr>
                  <tr>
                    <td><code>:bob</code></td>
                    <td><code>rel:worksWith</code></td>
                    <td><code>:alice</code></td>
                  </tr>
                </tbody>
              </table>
            </div>Note that in such a setting, where the RDF-encoded RIF rulesets are stored as named graphs in the dataset, one can also pose queries against the RDF encoding of the RIF ruleset
            itself, e.g. asking for variable names used in the ruleset <code>&lt;r1&gt;</code>:
            <pre class="query" aria-busy="false"><code class="hljs">PREFIX rif:  &lt;http://www.example.org/&gt;
SELECT DISTINCT ?N 
WHERE { GRAPH &lt;r1&gt; {  [ rif:varname ?N ] } }</code></pre>
            <div class="result">
              <span class="doc-ref" id="tableRESULTRIFmeta"></span>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>N</th>
                  </tr>
                  <tr>
                    <td><code>"S"</code></td>
                  </tr>
                  <tr>
                    <td><code>"O"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>
      </section>
    </section>
    <section id="DataSets"><div class="header-wrapper"><h2 id="x9-entailment-regimes-and-data-sets-informative"><bdi class="secno">9. </bdi>Entailment Regimes and Data Sets (Informative)</h2><a class="self-link" href="#DataSets" aria-label="Permalink for Section 9."></a></div>
      
      <p>Many RDF data stores hold multiple RDF graphs and applications can make queries that involve information from more than one graph. This section clarifies how entailment regimes behave in the
      presence of named graphs.</p>
      <p>As defined in the SPARQL specification, a SPARQL query is executed against an <a href="https://w3c.github.io/sparql-query/spec/#rdfDataset" id="ref-for-index-term-rdf-datasets-2">RDF Dataset</a> which represents a collection of
      graphs. An RDF Dataset comprises one graph, the default graph, which does not have a name, and zero or more named graphs, where each named graph is identified by an IRI. The graph that is used
      for matching a basic graph pattern is the active graph. Under an entailment regime E other than simple entailment, we do not only consider the triples that are in the graph, but also triples
      that are E-entailed by the graph. The entailed triples must, however, be E-entailed by the active graph and not by a merge of the triples in all graphs. This follows from conditions 1 and 3 of
      the <a href="https://w3c.github.io/sparql-query/spec/#sparqlBGPExtend" id="ref-for-index-term-conditions-3">conditions on extensions for basic graph matching</a>.</p>
      <p>For example, we consider a data set which consists of an empty default graph, a named graph graphA with IRI <code>http://example.org/a.rdf</code>, and a named graph graphB with IRI
      <code>http://example.org/b.rdf</code>. The named graphs contain the following data:</p>
      <p><code>http://example.org/a.rdf:</code></p>
      <pre class="data" aria-busy="false"><code class="hljs">ex:p rdfs:domain ex:A .</code></pre>
      <p><code>http://example.org/b.rdf:</code></p>
      <pre class="data" aria-busy="false"><code class="hljs">ex:x ex:p ex:y .</code></pre>
      <p>If we ask the following query under RDFS entailment</p>
      <pre class="query" aria-busy="false"><code class="hljs">SELECT ?g WHERE { GRAPH ?g { ?inst rdf:type ex:A } }</code></pre>
      <p>the answer sequence is empty because neither the default graph, nor the named graphs on their own entail a triple that would provide the required binding for&nbsp;?inst.</p>
      <p>In order to evaluate a query over the merge of the triples in the named graphs, one can use several <code>FROM</code> clauses, which result in the creation of a fresh default graph for the
      query that contains a merge of the triples, e.g.,</p>
      <pre class="query" aria-busy="false"><code class="hljs">SELECT ?inst FROM &lt;http://example.org/a.rdf&gt; FROM &lt;http://example.org/b.rdf&gt; WHERE { ?inst rdf:type ex:A }</code></pre>
      <p>has the answer <code>{ (inst, ex:x) }</code>. One cannot merge triples from several sources into a named graph (they will always be merged into a fresh default graph) and such an extension
      would require changes to the conditions for extensions of basic graph pattern matching in the existing SPARQL query language specification.</p>
    </section>
    <section id="PropertyPaths"><div class="header-wrapper"><h2 id="x10-entailment-regimes-and-property-paths-informative"><bdi class="secno">10. </bdi>Entailment Regimes and Property Paths (Informative)</h2><a class="self-link" href="#PropertyPaths" aria-label="Permalink for Section 10."></a></div>
      <span id="property-path"></span>
      <p>SPARQL 1.1 introduces <a href="https://w3c.github.io/sparql-query/spec/#propertypaths" id="ref-for-index-term-property-paths-1">property paths</a>, which allow for using path expressions in place of the predicate of a triple pattern.
      Such path expressions describe a possible route through the active graph. For an example, assume the following data in the default graph:</p>
      <pre class="data" aria-busy="false"><code class="hljs">ex:a rdf:type ex:C .
ex:C rdfs:subClassOf ex:D .
ex:a ex:p1 ex:b . 
ex:b ex:p2 ex:c .
ex:p2 rdfs:subPropertyOf ex:p3 .</code></pre>
      <p>and the following query:</p>
      <pre class="query" aria-busy="false"><code class="hljs">SELECT ?type ?c WHERE { ex:a rdf:type ?x . ?x rdfs:subClassOf* ?type . ex:a ex:p1/ex:p3 ?c }</code></pre>
      <p>The WHERE clause of the above query contains one triple pattern and two property path patterns. For the query processing, the property path patterns are first
        <a href="https://w3c.github.io/sparql-query/spec/#sparqlTranslatePathExpressions" id="ref-for-index-term-translated-to-algebra-objects-1">translated to algebra objects</a> and then, where possible,
        <a href="https://w3c.github.io/sparql-query/spec/#sparqlTranslatePathPatterns" id="ref-for-index-term-simplified-1">simplified</a>, i.e., they are rewritten with the purpose of eliminating path expressions in a semantics preserving way. For
      the above query, the algebra translation of the two property path expressions <code>rdfs:subClassOf*</code> and <code>ex:p1/ex:p3</code> yields:</p>
      <pre class="query" aria-busy="false"><code class="hljs">ZeroOrMorePath(link(rdfs:subClassOf))</code></pre>and
      <pre class="query" aria-busy="false"><code class="hljs">seq(link(ex:p1), link(ex:p3))</code></pre>the translation and simplification then yields:
      <pre class="query" aria-busy="false"><code class="hljs">Path(?x, ZeroOrMorePath(link(rdfs:subClassOf)), ?type)</code></pre>and the triple pattern
      <pre class="query" aria-busy="false"><code class="hljs">ex:a ex:p1 ?tmp1 . ?tmp1 ex:p3 ?c .</code></pre>
      <p>with <code>?tmp1</code> a fresh variable. The latter property path has been simplified into two triples patterns, whereas the first one remained a property path pattern. Since the extension
      point for redefining basic graph pattern matching is only for basic graph patterns, the entailment regimes do not specify any behavior for property path algebra objects such as
      <code>Path(.)</code> and the specific operators such as <code>ZeroOrMorePath(.)</code>. Thus, systems that employ an entailment regime can either reject queries with property path expressions
      that cannot be eliminated or employ the evaluation as defined in the <a href="https://w3c.github.io/sparql-query/spec/#sparqlAlgebraEval" id="ref-for-index-term-evaluation-semantics-1">evaluation semantics</a> of the SPARQL 1.1 Query
      specification. For the latter case, evaluating <code>Path(?x, ZeroOrMorePath(link(rdfs:subClassOf)), ?type)</code> yields</p>
      <div class="result">
        <span class="doc-ref" id="resultUnion"></span>
        <table class="resultTable">
          <tbody>
            <tr>
              <th>x</th>
              <th>type</th>
            </tr>
            <tr>
              <td><code>ex:a</code></td>
              <td><code>ex:a</code></td>
            </tr>
            <tr>
              <td><code>ex:b</code></td>
              <td><code>ex:b</code></td>
            </tr>
            <tr>
              <td><code>ex:c</code></td>
              <td><code>ex:c</code></td>
            </tr>
            <tr>
              <td><code>ex:C</code></td>
              <td><code>ex:C</code></td>
            </tr>
            <tr>
              <td><code>ex:D</code></td>
              <td><code>ex:D</code></td>
            </tr>
            <tr>
              <td><code>ex:C</code></td>
              <td><code>ex:D</code></td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>The evaluation of <code>Bgp(ex:a rdf:type ?x)</code> now depends on the entailment regime that is used. We assume, for this example, that RDFS entailment is used. Thus, the evaluation
      yields</p>
      <div class="result">
        <span class="doc-ref" id="resultBgpOne"></span>
        <table class="resultTable">
          <tbody>
            <tr>
              <th>x</th>
            </tr>
            <tr>
              <td><code>ex:C</code></td>
            </tr>
            <tr>
              <td><code>ex:D</code></td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>We can now compute the join to obtain</p>
      <div class="result">
        <span class="doc-ref" id="firstJoin"></span>
        <table class="resultTable">
          <tbody>
            <tr>
              <th>x</th>
              <th>type</th>
            </tr>
            <tr>
              <td><code>ex:C</code></td>
              <td><code>ex:C</code></td>
            </tr>
            <tr>
              <td><code>ex:D</code></td>
              <td><code>ex:D</code></td>
            </tr>
            <tr>
              <td><code>ex:C</code></td>
              <td><code>ex:D</code></td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>Evaluating <code>Bgp(ex:a ex:p1 ?tmp1 . ?tmp1 ex:p3 ?c)</code> would yield an empty solution set under simple entailment (i.e., standard subgraph matching). Under RDFS entailment we get,
      however,</p>
      <div class="result">
        <span class="doc-ref" id="bgp2"></span>
        <table class="resultTable">
          <tbody>
            <tr>
              <th>tmp1</th>
              <th>c</th>
            </tr>
            <tr>
              <td><code>ex:b</code></td>
              <td><code>ex:c</code></td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>We can now compute the final result for the query pattern under RDFS entailment by joining the last two solution sets:</p>
      <div class="result">
        <span class="doc-ref" id="secondJoin"></span>
        <table class="resultTable">
          <tbody>
            <tr>
              <th>x</th>
              <th>type</th>
              <th>tmp1</th>
              <th>c</th>
            </tr>
            <tr>
              <td><code>ex:C</code></td>
              <td><code>ex:C</code></td>
              <td><code>ex:b</code></td>
              <td><code>ex:c</code></td>
            </tr>
            <tr>
              <td><code>ex:D</code></td>
              <td><code>ex:D</code></td>
              <td><code>ex:b</code></td>
              <td><code>ex:c</code></td>
            </tr>
            <tr>
              <td><code>ex:C</code></td>
              <td><code>ex:D</code></td>
              <td><code>ex:b</code></td>
              <td><code>ex:c</code></td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>The overall query result can then be obtained by projecting <code>x</code> and <code>tmp1</code> away.</p>
      <div class="result">
        <span class="doc-ref" id="project"></span>
        <table class="resultTable">
          <tbody>
            <tr>
              <th>type</th>
              <th>c</th>
            </tr>
            <tr>
              <td><code>ex:C</code></td>
              <td><code>ex:c</code></td>
            </tr>
            <tr>
              <td><code>ex:D</code></td>
              <td><code>ex:c</code></td>
            </tr>
            <tr>
              <td><code>ex:D</code></td>
              <td><code>ex:c</code></td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>In the presence of a particular entailment regime, path expressions are sometimes redundant as their semantics is already captured by the entailment relation. This is often the case when
      applying path expressions to terms of the special vocabulary for the entailment regime that is used. In the above example, <code>rdfs:subClassOf</code> is already treated as a reflexive and
      transitive relation under RDFS entailment. Thus, the first BGP <code>Bgp(ex:a rdf:type ?x)</code> already yields both the explicitly stated type <code>ex:C</code> as well as the RDFS entailed
      type <code>ex:D</code>. For this reason, the solution that binds <code>type</code> to <code>D</code> occurs twice, whereas under simple entailment, it would only occur once disregarding the
      fact that the second property path from the query has no solutions under simple entailment. In order to avoid the additional solution the query pattern</p>
      <pre class="query" aria-busy="false"><code class="hljs">ex:a rdf:type ?x . ex:a ex:p1/ex:p3 ?c</code></pre>
      <p>can be used. This also avoids the computation of several intermediate results.</p>
      <section id="PropertyPathsLimitations"><div class="header-wrapper"><h3 id="x10-1-limitations-of-property-paths-in-combination-with-entailment-regimes"><bdi class="secno">10.1 </bdi>Limitations of Property Paths in Combination with Entailment Regimes</h3><a class="self-link" href="#PropertyPathsLimitations" aria-label="Permalink for Section 10.1"></a></div>
        
        <p>Since property paths are evaluated without entailment, the evaluation under an entailment regime can yield counter-intuitive results. Assuming the use of the RDFS entailment regime and the
        query</p>
        <pre class="query" aria-busy="false"><code class="hljs">SELECT * WHERE { ?s (ex:p3+) ?o }</code></pre>
        <p>over the above given example data, the result is empty. Although the data contains <code>ex:b ex:p2 ex:c</code> and <code>ex:p2 rdfs:subPropertyOf ex:p3</code>, which under RDFS entailment
        implies <code>ex:b ex:p3 ex:c</code>, this fact is not used since the arbitrary length path expression <code>ex:p+</code> is evaluated with simple entailment, i.e., via subgraph matching on
        the input data.</p>
        <p>Since property path evaluation works directly on the active graph, the OWL Direct Semantics entailment regime is unlikely to support queries where the query pattern contains path
        expressions since systems that apply the Direct Semantics of OWL do not work with the graph directly, but translate the triples into OWL structural objects. Combining the other entailment
        regimes with property path expressions is, however, relatively straightforward.</p>
        <p>Future versions of SPARQL may define further extensions to the handling of property paths together with entailment regimes that handle property paths in a specific way, which is why the
        present section is kept informative.</p>
      </section>
    </section>
    <section id="Updates"><div class="header-wrapper"><h2 id="x11-entailment-regimes-and-updates-informative"><bdi class="secno">11. </bdi>Entailment Regimes and Updates (Informative)</h2><a class="self-link" href="#Updates" aria-label="Permalink for Section 11."></a></div>
      
      <p>SPARQL 1.1 also describes an update language (see [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql12-update" title="SPARQL 1.2 Update">SPARQL12-UPDATE</a></cite>] and [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql12-graph-store-protocol" title="SPARQL 1.2 Graph Store HTTP Protocol">SPARQL12-GRAPH-STORE-PROTOCOL</a></cite>]),
        which can be used to add, modify, or delete data in an RDF graph. Support for [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql12-update" title="SPARQL 1.2 Update">SPARQL12-UPDATE</a></cite>] and [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql12-graph-store-protocol" title="SPARQL 1.2 Graph Store HTTP Protocol">SPARQL12-GRAPH-STORE-PROTOCOL</a></cite>] is optional. SPARQL endpoints that use
      an entailment regime other than simple entailment may support update queries, but the exact behavior of the system for such queries is not covered by this specification. SPARQL endpoints that
      use an entailment regime other than simple entailment and that do support update queries should describe the system behavior in the system's documentation.</p>
    </section>
    <section id="AppendixMapping"><div class="header-wrapper"><h2 id="x12-appendix-mapping-from-bgps-to-the-extended-owl-2-structural-specification"><bdi class="secno">12. </bdi>Appendix: Mapping from BGPs to the extended OWL 2 Structural Specification</h2><a class="self-link" href="#AppendixMapping" aria-label="Permalink for Section 12."></a></div>
      <span id="OWL2parsingBGPs"></span>
      <p>This appendix specifies how a legal basic graph pattern BGP of a SPARQL query can be parsed into the extension of the OWL 2 Structural specification
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-syntax" title="OWL 2 Web Ontology Language Structural Specification and Functional-Style Syntax (Second Edition)">OWL2-SYNTAX</a></cite>].
        Let <code>x</code> be a variable from BGP. If BGP contains a triple <code>?x rdf:type TYPE</code> or <code>$x rdf:type TYPE</code>, where <code>TYPE</code> is one of
      <code>owl:Class</code>, <code>owl:ObjectProperty</code>, <code>owl:DatatypeProperty</code>, or <code>owl:NamedIndividual</code>, <code>x</code> is declared to be of type <code>TYPE</code>. BGP
      satisfies the <em>typing constraints</em> of the entailment regime if no variable is declared as being of more than one type.</p>
      <p>For the purpose of this parsing process, we assume that BGP is seen as an RDF graph G which may also contain variables in any position. A tool <em class="rfc2119">MAY</em> implement these steps in any way it chooses; however, the results <em class="rfc2119">MUST</em> be
        <a href="https://www.w3.org/TR/owl2-syntax/#Structural_Specification" id="ref-for-index-term-structurally-equivalent-1">structurally equivalent</a> to the ones defined in the following sections, where structural equivalence is taken to be extended in
      the natural way to also allow for variables, i.e., the definition of structural equivalence is as follows:</p>
      <p>Objects <em>o<sub>1</sub></em> and <em>o<sub>2</sub></em> from the extended structural specification are <em>structurally equivalent</em> if the following conditions hold:</p>
      <ul>
        <li>If <em>o<sub>1</sub></em> and <em>o<sub>2</sub></em> are atomic values, such as strings or integers, they are structurally equivalent if they are equal according to the notion of equality
        of the respective UML type.</li>
        <li>If <em>o<sub>1</sub></em> and <em>o<sub>2</sub></em> are variables, they are structurally equivalent if they are equal according to the notion of string equality.</li>
        <li>If <em>o<sub>1</sub></em> and <em>o<sub>2</sub></em> are unordered associations without repetitions, they are structurally equivalent if each element of <em>o<sub>1</sub></em> is
        structurally equivalent to some element of <em>o<sub>2</sub></em> and vice versa.</li>
        <li>If <em>o<sub>1</sub></em> and <em>o<sub>2</sub></em> are ordered associations with repetitions, they are structurally equivalent if they contain the same number of elements and each
        element of <em>o<sub>1</sub></em> is structurally equivalent to the element of <em>o<sub>2</sub></em> with the same index.</li>
        <li>If <em>o<sub>1</sub></em> and <em>o<sub>2</sub></em> are instances of UML classes from the structural specification, they are structurally equivalent if
          <ul>
            <li>both <em>o<sub>1</sub></em> and <em>o<sub>2</sub></em> are instances of the same UML class, and</li>
            <li>each association of <em>o<sub>1</sub></em> is structurally equivalent to the corresponding association of <em>o<sub>2</sub></em> and vice versa.</li>
          </ul>
        </li>
      </ul>
      <p>The following table defines the steps that are involved in the mapping process from basic graph patterns to extended OWL objects.</p>
      <table>
        <tbody>
          <tr>
            <td><strong>CP&nbsp;1</strong></td>
            <td>If BGP contains no triple of the form <code>x rdf:type owl:Ontology</code> for <code>x</code> an IRI or a blank node, then extend BGP with <code>_:x rdf:type owl:Ontology</code> for
            <code>_:x</code> a fresh blank node not occurring in BGP and SG.</td>
          </tr>
          <tr>
            <td><strong>CP&nbsp;2</strong></td>
            <td>Compute Decl(BGP) as specified in <a href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Extracting_Declarations_and_the_IRIs_of_the_Directly_Imported_Ontology_Documents" id="ref-for-index-term-canonical-parsing-process-2">Section 3.1</a>
            of the OWL 2 Mapping to RDF graphs specification with the difference that import statements do not result in the addition of triples. Initialize AllDecl(BGP) as the union of Decl(BGP) and
            declarations from O(SG), i.e., AllDecl(D<sub>SG</sub>) where D<sub>SG</sub> is the ontology document from which O(SG) is obtained.</td>
          </tr>
          <tr>
            <td><strong>CP&nbsp;3</strong></td>
            <td>Create an instance O<sub>E</sub>(BGP) that corresponds to an instance of the <a href="https://www.w3.org/TR/owl2-syntax/#def_ontology" id="ref-for-index-term-ontology-1"><strong>Ontology</strong></a> class from the
            extended grammar for the OWL 2 Direct Semantics. That is, the UML classes are taken to be extended such that entities can also be variables.</td>
          </tr>
          <tr>
            <td><strong>CP&nbsp;4</strong></td>
            <td>Analyze BGP and populate O<sub>E</sub>(BGP) by instantiating appropriate classes from the extended structural specification. Use the declarations in AllDecl(BGP) to disambiguate IRIs
            and variables if needed. It <em class="rfc2119">MUST</em> be possible to disambiguate all IRIs and variables. Variables that are not declared as being
            of some type occur either only in individual positions or only in literal positions; otherwise BGP is not legal for the regime.</td>
          </tr>
        </tbody>
      </table>
      <p>A canonical definition for Step <strong>CP&nbsp;4</strong> is given in the following section.</p>
      <section id="OWLParsing"><div class="header-wrapper"><h3 id="x12-1-parsing-bgps-into-objects-of-the-extended-owl-2-structural-specification"><bdi class="secno">12.1 </bdi>Parsing BGPs into Objects of the Extended OWL 2 Structural Specification</h3><a class="self-link" href="#OWLParsing" aria-label="Permalink for Section 12.1"></a></div>
        
        <p>Parsing BGPs into OWL objects as required in <strong>CP&nbsp;4</strong> follows closely the parsing process described in
          <a href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Populating_an_Ontology" id="ref-for-index-term-section-3-2-1">Section 3.2</a> of [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-mapping-to-rdf" title="OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition)">OWL2-MAPPING-TO-RDF</a></cite>]. This document only states where the parsing
        differs from the mapping as defined by OWL 2. The main difference is that IRIs, anonymous individuals, and literals can also be variables. Thus, the notation used in the mapping specification
        is taken to be extended as follows:</p>
        <ul>
          <li><code>*:x</code> denotes an IRI <em>or a variable</em>;</li>
          <li><code>_:x</code> denotes a blank node;</li>
          <li><code>x</code> denotes a blank node, an IRI <em>or a variable</em>;</li>
          <li><code>lt</code> denotes a literal <em>or a variable</em>; and</li>
          <li><code>xlt</code> denotes a blank node, an IRI, a literal, <em>or a variable</em>.</li>
        </ul>
        <p>Note that as for the OWL 2 mapping, variations of the above scheme are also taken to be defined as above, e.g., <code>*:y</code> or <code>*:x<sub>i</sub></code> instead of <code>*:x</code>
        also denote an IRIs or a variables. Further, <code>_:x</code> remains unchanged and does not represent a variable.</p>
        <p>The functions <code>CE(x)</code>, <code>DR(x)</code>, <code>OPE(x)</code>, and <code>DPE(x)</code> extend the respective functions in the section
          <a href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Mapping_from_RDF_Graphs_to_the_Structural_Specification" id="ref-for-index-term-mapping-the-queried-rdf-graph-into-an-owl-2-ontology-2">Mapping to RDF graphs</a> [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-mapping-to-rdf" title="OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition)">OWL2-MAPPING-TO-RDF</a></cite>] to
        map into instances of the extended grammar for OWL 2 Direct Semantics BGPs, i.e., the functions also take variables as input and they map to objects that correspond to the extended structural
        specification for BGPs. The functions are initialized as in Table 9 of [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-mapping-to-rdf" title="OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition)">OWL2-MAPPING-TO-RDF</a></cite>] for non-variable declarations (*:x is not a variable) and
        extended for the case where *:x is a variable as follows:</p>
        <div>
          <table style="text-align: left; border-spacing: 5px; border-width: 2px">
            <tbody>
              <tr>
                <th>If <em>AllDecl(G)</em> contains this declaration...</th>
                <th>...then perform this assignment.</th>
              </tr>
              <tr>
                <td>Declaration( Class( *:x ) )</td>
                <td>CE(*:x)&nbsp;:= <em>a class variable with name *:x</em></td>
              </tr>
              <tr>
                <td>Declaration( Datatype( *:x ) )</td>
                <td>DR(*:x)&nbsp;:= <em>a datatype variable with name *:x</em></td>
              </tr>
              <tr>
                <td>Declaration( ObjectProperty( *:x ) )</td>
                <td>OPE(*:x)&nbsp;:= <em>an object property variable with name *:x</em></td>
              </tr>
              <tr>
                <td>Declaration( DataProperty( *:x ) )</td>
                <td>DPE(*:x)&nbsp;:= <em>a data property variable with name *:x</em></td>
              </tr>
              <tr>
                <td>Declaration( AnnotationProperty( *:x ) )</td>
                <td>AP(*:x)&nbsp;:= <em>an annotation property with name *:x</em></td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>Parsing then continues as described in [OWL2-MAPPING-TO-RDF] with the modification that objects can contain variables. Variables are not allowed in
        the mapping for facet restrictions in the last column of <a href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Parsing_of_Expressions" id="ref-for-index-term-table-12-1">Table 12</a> for <code>*:w<sub>i</sub></code> and the
        <code>n</code> that denotes a non-negative integer in cardinality restrictions is not redefined, i.e., it cannot be replaced by a variable.</p>
      </section>
    </section>
    <section id="AppendixProofs"><div class="header-wrapper"><h2 id="x13-appendix-proofs"><bdi class="secno">13. </bdi>Appendix: Proofs</h2><a class="self-link" href="#AppendixProofs" aria-label="Permalink for Section 13."></a></div>
      
      <p>The SPARQL Query specification [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql12-query" title="SPARQL 1.2 Query Language">SPARQL12-QUERY</a></cite>] lists four conditions that entailment regimes that extend the standard simple entailment must satisfy. The different
      conditions are considered below for all entailment regimes in this document.</p>
      <p>1 -- The <a href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="ref-for-index-term-scoping-graph-11">scoping graph</a>, SG, corresponding to any consistent active graph AG is uniquely specified up to RDF graph
      equivalence and is E-equivalent to AG.</p>
      <p>All entailment regimes use the same definition of scoping graph as simple entailment, i.e., the scoping graph is graph-equivalent to the active graph AG of the data set DS for the query but
      shares no blank nodes with DS or with the basic graph pattern of the query. The same scoping graph is used for all solutions to a single query. Thus, E-equivalence to AG up to RDF graph
      equivalence is immediate. In case AG is inconsistent, it is not required that a scoping graph is defined and although most of the regimes define SG also in the presence of an inconsistency, it
      is not required that the above condition is satisfied.</p>
      <p>2 -- For any basic graph pattern BGP and pattern instance mapping P, P(BGP) is well-formed for E.</p>
      <p>BGPs that can only be instantiated into malformed triples, e.g., because they require a literal in the subject position, do not have a valid pattern instance mapping and the condition is
      satisfied. Only the OWL 2 Direct Semantics regimes restricts the well-formedness of the queried graph and the basic graph patterns further. Since graphs and queries that are malformed for OWL 2
      Direct Semantics are rejected with errors and, thus, do not have pattern instance mappings, the condition is satisfied.</p>
      <p>3 -- For any <a href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="ref-for-index-term-scoping-graph-12">scoping graph</a> SG and answer set {P<sub>1</sub> ... P<sub>n</sub>} for a basic graph pattern BGP, and where
      {BGP<sub>1</sub> .... BGP<sub>n</sub>} is a set of basic graph patterns all equivalent to BGP, none of which share any blank nodes with any other or with SG</p>
      <blockquote>
        SG E-entails (SG union P<sub>1</sub>(BGP<sub>1</sub>) union ... union P<sub>n</sub>(BGP<sub>n</sub>))
      </blockquote>
      <p>Before giving a proof, the following example illustrates how this condition could be violated. Assume SG contains the triples:</p>
      <pre class="data" aria-busy="false"><code class="hljs">ex:s ex:p _:b1 .
_:b2 ex:p ex:o</code></pre>and the BGP of the query is
      <pre class="query" aria-busy="false"><code class="hljs">?x ex:p ?y</code></pre>
      <p>The graph (even simply) entails the triple <code>ex:s ex:p _:1</code> and also the triple <code>_:1 ex:p ex:o</code>. If we were to take P<sub>1</sub>: ?x/<code>ex:s</code>,
      ?y/<code>_:1</code> and P<sub>2</sub>: ?x/<code>_:1</code>, ?y/<code>ex:o</code>, then, since BGP does not contain blank nodes, we can take any two copies BGP<sub>1</sub>, BGP<sub>2</sub> of
      BGP and we would have to show (only considering the two example solutions):</p>
      <blockquote>
        <p>SG E-entails (SG union P<sub>1</sub>(BGP<sub>1</sub>) union P<sub>2</sub>(BGP<sub>2</sub>)) =</p>
      </blockquote>
      <blockquote>
        <p>{ <code>ex:s ex:p _:b1 . _:b2 ex:p ex:o</code> } E-entails { <code>ex:s ex:p _:b1 . _:b2 ex:p ex:o . ex:s ex:p _:1 . _:1 ex:p ex:o</code> }</p>
      </blockquote>
      <p>This is clearly not the case because SG does not entail <code>ex:s ex:p _:1 . _:1 ex:p ex:o</code>. The use of the same blank node identifier across several solutions is only valid if also
      the corresponding blank nodes in SG are identical.</p>
      <p>All the entailment regimes satisfy this restriction since blank nodes are treated as Skolem constants, i.e., although both of the triples in the above example are <em>possible</em>
      solutions, these are not part of the actual solutions.</p>
      <p>4 -- Each SPARQL extension <em class="rfc2119">MUST</em> provide conditions on answer sets which guarantee that the set of triples obtained by
      instantiating BGP with each solution μ is uniquely specified up to RDF graph equivalence, and <em class="rfc2119">SHOULD</em> provide further conditions to
      prevent trivial infinite answers as appropriate to the regime.</p>
      <p>All entailment regimes, but the RIF entailment regime, require that bindings are only taken from a vocabulary defined for the regime. Since the defined vocabularies are finite, it is
      immediate that any BGP over any AG results in finite answers. The answer set is unique up to RDF graph equivalence since the entailed answers can only vary in their blank node identifiers,
      which still preserves graph equivalence. For the RIF entailment regime finiteness and uniqueness follows from the <a href="#RIFFiniteAnswers">safety conditions</a>.</p>
    </section>

    <section id="conformance"><div class="header-wrapper"><h2 id="x14-conformance"><bdi class="secno">14. </bdi>Conformance</h2><a class="self-link" href="#conformance" aria-label="Permalink for Section 14."></a></div><p>As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.</p><p>
        The key words <em class="rfc2119">MAY</em>, <em class="rfc2119">MUST</em>, and <em class="rfc2119">SHOULD</em> in this document
        are to be interpreted as described in
        <a href="https://datatracker.ietf.org/doc/html/bcp14">BCP 14</a>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc2119" title="Key words for use in RFCs to Indicate Requirement Levels">RFC2119</a></cite>] [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc8174" title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">RFC8174</a></cite>]
        when, and only when, they appear in all capitals, as shown here.
      </p>
      <section id="conformance-0"><div class="header-wrapper"><h3 id="x14-1-conformance"><bdi class="secno">14.1 </bdi>Conformance</h3><a class="self-link" href="#conformance-0" aria-label="Permalink for Section 14.1"></a></div>
    </section></section>

    <section id="privacy"><div class="header-wrapper"><h2 id="x15-privacy-considerations"><bdi class="secno">15. </bdi>Privacy Considerations</h2><a class="self-link" href="#privacy" aria-label="Permalink for Section 15."></a></div>
      
      <p>TODO</p>
    </section>

    <section id="security"><div class="header-wrapper"><h2 id="x16-security-considerations"><bdi class="secno">16. </bdi>Security Considerations</h2><a class="self-link" href="#security" aria-label="Permalink for Section 16."></a></div>
      
      <p>TODO</p>
    </section>

    <section id="internationalization"><div class="header-wrapper"><h2 id="x17-internationalization-considerations"><bdi class="secno">17. </bdi>Internationalization Considerations</h2><a class="self-link" href="#internationalization" aria-label="Permalink for Section 17."></a></div>
      
      <p>TODO</p>                
    </section>

    <section class="appendix informative" id="changes-from-sparql11"><div class="header-wrapper"><h2 id="a-change-log"><bdi class="secno">A. </bdi>Change Log</h2><a class="self-link" href="#changes-from-sparql11" aria-label="Permalink for Appendix A."></a></div><p><em>This section is non-normative.</em></p>
      
      <p>TODO</p>
    </section>   

    <section id="index" class="appendix"><div class="header-wrapper"><h2 id="b-index"><bdi class="secno">B. </bdi>Index</h2><a class="self-link" href="#index" aria-label="Permalink for Appendix B."></a></div><section id="index-defined-here"><div class="header-wrapper"><h3 id="b-1-terms-defined-by-this-specification"><bdi class="secno">B.1 </bdi>Terms defined by this specification</h3><a class="self-link" href="#index-defined-here" aria-label="Permalink for Appendix B.1"></a></div>
    
    <ul class="index">
    
  </ul>
  </section><section id="index-defined-elsewhere"><div class="header-wrapper"><h3 id="b-2-terms-defined-by-reference"><bdi class="secno">B.2 </bdi>Terms defined by reference</h3><a class="self-link" href="#index-defined-elsewhere" aria-label="Permalink for Appendix B.2"></a></div>
    
    <ul class="index">
    <li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-conformance">OWL2-CONFORMANCE</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-conformance/#Syntactic_Conformance" id="index-term-owl-2-dl-ontology-document" tabindex="0" aria-haspopup="dialog">OWL 2 DL ontology document</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-direct-semantics">OWL2-DIRECT-SEMANTICS</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-direct-semantics/#Inference_Problems" id="index-term-owl-2-direct-semantics-entailment" tabindex="0" aria-haspopup="dialog">OWL 2 Direct Semantics entailment</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-mapping-to-rdf">OWL2-MAPPING-TO-RDF</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Extracting_Declarations_and_the_IRIs_of_the_Directly_Imported_Ontology_Documents" id="index-term-canonical-parsing-process" tabindex="0" aria-haspopup="dialog">canonical parsing process</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Mapping_from_RDF_Graphs_to_the_Structural_Specification" id="index-term-mapping-the-queried-rdf-graph-into-an-owl-2-ontology" tabindex="0" aria-haspopup="dialog">mapping the queried RDF graph into an OWL 2 ontology</span>
  </li><li>
    <span class="index-term" data-href="https://validator.w3.org/checklink?hide_type=all&depth=&check=Check&uri=https://www.w3.org/TR/2023/WD-sparql12-entailment-20230606/" id="index-term-owl-2-rdf-based-semantics-entailment" tabindex="0" aria-haspopup="dialog">OWL 2 RDF-Based Semantics entailment</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Populating_an_Ontology" id="index-term-section-3-2" tabindex="0" aria-haspopup="dialog">Section 3.2</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Parsing_of_Expressions" id="index-term-table-12" tabindex="0" aria-haspopup="dialog">Table 12</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-profiles">OWL2-PROFILES</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-profiles/#Profile_Specification_3" id="index-term-implementation-using-rule-based-technologies" tabindex="0" aria-haspopup="dialog">implementation using rule-based technologies</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-profiles/#Reasoning_in_OWL_2_RL_and_RDF_Graphs_using_Rules" id="index-term-owl-rl-rule" tabindex="0" aria-haspopup="dialog">OWL RL rule</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-rdf-based-semantics">OWL2-RDF-BASED-SEMANTICS</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-rdf-based-semantics/#def-owlconsistency" id="index-term-d-inconsistent" tabindex="0" aria-haspopup="dialog">D-inconsistent</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Datatype_Names" id="index-term-datatype-names" tabindex="0" aria-haspopup="dialog">datatype names</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Facet_Names" id="index-term-facet-names" tabindex="0" aria-haspopup="dialog">facet names</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-rdf-based-semantics/#def-owldatatypemap" id="index-term-owl-2-rdf-based-datatype-map" tabindex="0" aria-haspopup="dialog">OWL 2 RDF-Based datatype map</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Satisfaction.2C_Consistency_and_Entailment" id="index-term-owl-2-rdf-based-entailment" tabindex="0" aria-haspopup="dialog">OWL 2 RDF-Based Entailment</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-rdf-based-semantics/#table-vocab-owl" id="index-term-owl-2-rdf-based-vocabulary" tabindex="0" aria-haspopup="dialog">OWL 2 RDF-based vocabulary</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Example_on_Semantic_Differences" id="index-term-sec-7-1" tabindex="0" aria-haspopup="dialog">Sec. 7.1</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-owl2-syntax">OWL2-SYNTAX</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-syntax/#Anonymous_Individuals" id="index-term-anonymous-individuals" tabindex="0" aria-haspopup="dialog">anonymous individuals</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-syntax/#The_Restrictions_on_the_Axiom_Closure" id="index-term-following-requirement" tabindex="0" aria-haspopup="dialog">following requirement</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-syntax/#def_ontology" id="index-term-ontology" tabindex="0" aria-haspopup="dialog">Ontology</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-syntax/#Appendix:_Complete_Grammar_.28Normative.29" id="index-term-owl-2-functional-style-syntax-grammar" tabindex="0" aria-haspopup="dialog">OWL 2 functional-style syntax grammar</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-syntax/#Structural_Specification" id="index-term-structurally-equivalent" tabindex="0" aria-haspopup="dialog">structurally equivalent</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/owl2-syntax/#Entity_Declarations_and_Typing" id="index-term-table-5" tabindex="0" aria-haspopup="dialog">Table 5</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-rdf12-concepts">RDF12-CONCEPTS</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-concepts/spec/#dfn-blank-node" id="index-term-blank-nodes" tabindex="0" aria-haspopup="dialog">blank nodes</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-concepts/spec/#section-Datatypes" id="index-term-datatype" tabindex="0" aria-haspopup="dialog">datatype</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-concepts/spec/#section-graph-equality" id="index-term-rdf-graph-equivalence" tabindex="0" aria-haspopup="dialog">RDF graph equivalence</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-concepts/spec/#dfn-literal" id="index-term-rdf-literals" tabindex="0" aria-haspopup="dialog">RDF Literals</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-concepts/spec/#dfn-rdf-term" id="index-term-rdf-term" tabindex="0" aria-haspopup="dialog">RDF term</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-concepts/spec/#dfn-inconsistent" id="index-term-rdfs-inconsistent" tabindex="0" aria-haspopup="dialog">RDFS-inconsistent</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-rdf12-semantics">RDF12-SEMANTICS</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#D_entailment" id="index-term-d-entailment" tabindex="0" aria-haspopup="dialog">D-Entailment</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#dfn-datatype-map" id="index-term-datatype-map" tabindex="0" aria-haspopup="dialog">datatype map</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#rdf_entail" id="index-term-rdf-entailment" tabindex="0" aria-haspopup="dialog">RDF entailment</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#rdfs_entailment" id="index-term-rdf-schema-entailment" tabindex="0" aria-haspopup="dialog">RDF Schema entailment</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdf-vocabulary" id="index-term-rdf-vocabulary" tabindex="0" aria-haspopup="dialog">RDF vocabulary</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfd1" id="index-term-rdfd1" tabindex="0" aria-haspopup="dialog">rdfD1</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#rdf_entailment_patterns" id="index-term-rdfs-entailment-rules" tabindex="0" aria-haspopup="dialog">RDFS entailment rules</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#rdfs_patterns" id="index-term-rdfs-inference-rules" tabindex="0" aria-haspopup="dialog">RDFS inference rules</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfs-vocabulary" id="index-term-rdfs-vocabulary" tabindex="0" aria-haspopup="dialog">RDFS vocabulary</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfs3" id="index-term-rdfs3" tabindex="0" aria-haspopup="dialog">rdfs3</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfs9" id="index-term-rdfs9" tabindex="0" aria-haspopup="dialog">rdfs9</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfs7" id="index-term-rule-rdfs7" tabindex="0" aria-haspopup="dialog">rule rdfs7</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#dfn-simply-entail" id="index-term-simple-entailment-relation-between-rdf-graphs" tabindex="0" aria-haspopup="dialog">simple entailment relation between RDF graphs</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-semantics/spec/#skolemization" id="index-term-skolemization" tabindex="0" aria-haspopup="dialog">Skolemization</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-rdf12-turtle">RDF12-TURTLE</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://w3c.github.io/rdf-turtle/spec/#" id="index-term-turtle-abbreviations" tabindex="0" aria-haspopup="dialog">Turtle abbreviations</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-bld">RIF-BLD</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://www.w3.org/TR/rif-bld/#def-bld-model-formula" id="index-term-model" tabindex="0" aria-haspopup="dialog">model</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/rif-bld/#EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-BLD_.28Informative.29" id="index-term-presentation-syntax" tabindex="0" aria-haspopup="dialog">presentation syntax</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-core">RIF-CORE</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://www.w3.org/TR/rif-core/#Safeness" id="index-term-safety-conditions" tabindex="0" aria-haspopup="dialog">safety conditions</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-rif-rdf-owl">RIF-RDF-OWL</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://www.w3.org/TR/rif-rdf-owl/#def-common-rif-rdf-interpretation" id="index-term-common-rif-rdf-interpretation" tabindex="0" aria-haspopup="dialog">common RIF-RDF interpretation</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/rif-rdf-owl/#def-generalized-rdf-graph" id="index-term-generalized-rdf-graphs" tabindex="0" aria-haspopup="dialog">generalized RDF graphs</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/rif-rdf-owl/#def-rif-rdf-combination" id="index-term-rif-rdf-combination" tabindex="0" aria-haspopup="dialog">RIF-RDF combination</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/rif-rdf-owl/#def-simple-entails" id="index-term-rif-simple-entailment" tabindex="0" aria-haspopup="dialog">RIF-Simple entailment</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/rif-rdf-owl/#def-rif-rdf-satisfies" id="index-term-satisfies" tabindex="0" aria-haspopup="dialog">satisfies</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql12-protocol">SPARQL12-PROTOCOL</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-protocol/spec/#select-malformed" id="index-term-malformedquery" tabindex="0" aria-haspopup="dialog">MalformedQuery</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-protocol/spec/#select-refused" id="index-term-queryrequestrefused" tabindex="0" aria-haspopup="dialog">QueryRequestRefused</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-sparql12-query">SPARQL12-QUERY</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-query/spec/#sparqlBGPExtend" id="index-term-conditions" tabindex="0" aria-haspopup="dialog">conditions</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-query/spec/#initDefinitions" id="index-term-definitions" tabindex="0" aria-haspopup="dialog">definitions</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-query/spec/#sparqlAlgebraEval" id="index-term-evaluation-semantics" tabindex="0" aria-haspopup="dialog">evaluation semantics</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-query/spec/#propertypaths" id="index-term-property-paths" tabindex="0" aria-haspopup="dialog">property paths</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-query/spec/#rdfDataset" id="index-term-rdf-datasets" tabindex="0" aria-haspopup="dialog">RDF datasets</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" id="index-term-scoping-graph" tabindex="0" aria-haspopup="dialog">scoping graph</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-query/spec/#sparqlTranslatePathPatterns" id="index-term-simplified" tabindex="0" aria-haspopup="dialog">simplified</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-query/spec/#grammar" id="index-term-sparql-grammar" tabindex="0" aria-haspopup="dialog">SPARQL grammar</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-query/spec/#sparqlTriplePatterns" id="index-term-the-sparql-triple-patterns-definition" tabindex="0" aria-haspopup="dialog">the SPARQL triple patterns definition</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-query/spec/#sparqlTranslatePathExpressions" id="index-term-translated-to-algebra-objects" tabindex="0" aria-haspopup="dialog">translated to algebra objects</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-query/spec/#rVar" id="index-term-var" tabindex="0" aria-haspopup="dialog">Var</span>
  </li><li>
    <span class="index-term" data-href="https://w3c.github.io/sparql-query/spec/#defn_QueryVariable" id="index-term-variable" tabindex="0" aria-haspopup="dialog">variable</span>
  </li>
        </ul>
      </li><li>
        [<cite><a class="bibref" data-link-type="biblio" href="#bib-xmlschema11-2">XMLSCHEMA11-2</a></cite>] defines the following:
        <ul>
          <li>
    <span class="index-term" data-href="https://www.w3.org/TR/xmlschema11-2/#decimal" id="index-term-decimal" tabindex="0" aria-haspopup="dialog">decimal</span>
  </li><li>
    <span class="index-term" data-href="https://www.w3.org/TR/xmlschema11-2/#integer" id="index-term-xsd-1-0" tabindex="0" aria-haspopup="dialog">XSD 1.0</span>
  </li>
        </ul>
      </li>
  </ul>
  </section></section>

  

<section id="references" class="appendix"><div class="header-wrapper"><h2 id="c-references"><bdi class="secno">C. </bdi>References</h2><a class="self-link" href="#references" aria-label="Permalink for Appendix C."></a></div><section id="normative-references"><div class="header-wrapper"><h3 id="c-1-normative-references"><bdi class="secno">C.1 </bdi>Normative references</h3><a class="self-link" href="#normative-references" aria-label="Permalink for Appendix C.1"></a></div>
    
    <dl class="bibliography"><dt id="bib-owl2-conformance">[OWL2-CONFORMANCE]</dt><dd>
      <a href="https://www.w3.org/TR/owl2-conformance/"><cite>OWL 2 Web Ontology Language Conformance (Second Edition)</cite></a>. Michael[tm] Smith; Ian Horrocks; Markus Krötzsch; Birte Glimm.  W3C. 11 December 2012. W3C Recommendation. URL: <a href="https://www.w3.org/TR/owl2-conformance/">https://www.w3.org/TR/owl2-conformance/</a>
    </dd><dt id="bib-owl2-direct-semantics">[OWL2-DIRECT-SEMANTICS]</dt><dd>
      <a href="https://www.w3.org/TR/owl2-direct-semantics/"><cite>OWL 2 Web Ontology Language Direct Semantics (Second Edition)</cite></a>. Boris Motik; Peter Patel-Schneider; Bernardo Cuenca Grau.  W3C. 11 December 2012. W3C Recommendation. URL: <a href="https://www.w3.org/TR/owl2-direct-semantics/">https://www.w3.org/TR/owl2-direct-semantics/</a>
    </dd><dt id="bib-owl2-mapping-to-rdf">[OWL2-MAPPING-TO-RDF]</dt><dd>
      <a href="https://www.w3.org/TR/owl2-mapping-to-rdf/"><cite>OWL 2 Web Ontology Language Mapping to RDF Graphs (Second Edition)</cite></a>. Peter Patel-Schneider; Boris Motik.  W3C. 11 December 2012. W3C Recommendation. URL: <a href="https://www.w3.org/TR/owl2-mapping-to-rdf/">https://www.w3.org/TR/owl2-mapping-to-rdf/</a>
    </dd><dt id="bib-owl2-profiles">[OWL2-PROFILES]</dt><dd>
      <a href="https://www.w3.org/TR/owl2-profiles/"><cite>OWL 2 Web Ontology Language Profiles (Second Edition)</cite></a>. Boris Motik; Bernardo Cuenca Grau; Ian Horrocks; Zhe Wu; Achille Fokoue.  W3C. 11 December 2012. W3C Recommendation. URL: <a href="https://www.w3.org/TR/owl2-profiles/">https://www.w3.org/TR/owl2-profiles/</a>
    </dd><dt id="bib-owl2-rdf-based-semantics">[OWL2-RDF-BASED-SEMANTICS]</dt><dd>
      <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/"><cite>OWL 2 Web Ontology Language RDF-Based Semantics (Second Edition)</cite></a>. Michael Schneider.  W3C. 11 December 2012. W3C Recommendation. URL: <a href="https://www.w3.org/TR/owl2-rdf-based-semantics/">https://www.w3.org/TR/owl2-rdf-based-semantics/</a>
    </dd><dt id="bib-owl2-syntax">[OWL2-SYNTAX]</dt><dd>
      <a href="https://www.w3.org/TR/owl2-syntax/"><cite>OWL 2 Web Ontology Language Structural Specification and Functional-Style Syntax (Second Edition)</cite></a>. Boris Motik; Peter Patel-Schneider; Bijan Parsia.  W3C. 11 December 2012. W3C Recommendation. URL: <a href="https://www.w3.org/TR/owl2-syntax/">https://www.w3.org/TR/owl2-syntax/</a>
    </dd><dt id="bib-rdf12-concepts">[RDF12-CONCEPTS]</dt><dd>
      <a href="https://w3c.github.io/rdf-concepts/spec/"><cite>RDF 1.2 Concepts and Abstract Syntax</cite></a>. Richard Cyganiak; David Wood; Markus Lanthaler.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/rdf-concepts/spec/">https://w3c.github.io/rdf-concepts/spec/</a>
    </dd><dt id="bib-rdf12-semantics">[RDF12-SEMANTICS]</dt><dd>
      <a href="https://w3c.github.io/rdf-semantics/spec/"><cite>RDF 1.2 Semantics</cite></a>. Patrick Hayes; Peter Patel-Schneider.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/rdf-semantics/spec/">https://w3c.github.io/rdf-semantics/spec/</a>
    </dd><dt id="bib-rdf12-turtle">[RDF12-TURTLE]</dt><dd>
      <a href="https://w3c.github.io/rdf-turtle/spec/"><cite>RDF 1.2 Turtle</cite></a>. Eric Prud'hommeaux; Gavin Carothers.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/rdf-turtle/spec/">https://w3c.github.io/rdf-turtle/spec/</a>
    </dd><dt id="bib-rfc2119">[RFC2119]</dt><dd>
      <a href="https://www.rfc-editor.org/rfc/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>. S. Bradner.  IETF. March 1997. Best Current Practice. URL: <a href="https://www.rfc-editor.org/rfc/rfc2119">https://www.rfc-editor.org/rfc/rfc2119</a>
    </dd><dt id="bib-rfc8174">[RFC8174]</dt><dd>
      <a href="https://www.rfc-editor.org/rfc/rfc8174"><cite>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</cite></a>. B. Leiba.  IETF. May 2017. Best Current Practice. URL: <a href="https://www.rfc-editor.org/rfc/rfc8174">https://www.rfc-editor.org/rfc/rfc8174</a>
    </dd><dt id="bib-rif-bld">[RIF-BLD]</dt><dd>
      <a href="https://www.w3.org/TR/rif-bld/"><cite>RIF Basic Logic Dialect (Second Edition)</cite></a>. Harold Boley; Michael Kifer.  W3C. 5 February 2013. W3C Recommendation. URL: <a href="https://www.w3.org/TR/rif-bld/">https://www.w3.org/TR/rif-bld/</a>
    </dd><dt id="bib-rif-core">[RIF-CORE]</dt><dd>
      <a href="https://www.w3.org/TR/rif-core/"><cite>RIF Core Dialect (Second Edition)</cite></a>. Harold Boley; Gary Hallmark; Michael Kifer; Adrian Paschke; Axel Polleres; Dave Reynolds et al.  W3C. 5 February 2013. W3C Recommendation. URL: <a href="https://www.w3.org/TR/rif-core/">https://www.w3.org/TR/rif-core/</a>
    </dd><dt id="bib-rif-in-rdf">[RIF-in-RDF]</dt><dd>
      <a href="https://www.w3.org/TR/rif-in-rdf/"><cite>RIF In RDF (Second Edition)</cite></a>. Sandro Hawke; Axel Polleres.  W3C. 5 February 2013. W3C Working Group Note. URL: <a href="https://www.w3.org/TR/rif-in-rdf/">https://www.w3.org/TR/rif-in-rdf/</a>
    </dd><dt id="bib-rif-owl-rl">[RIF-OWL-RL]</dt><dd>
      <a href="https://www.w3.org/TR/rif-owl-rl/"><cite>OWL 2 RL in RIF (Second Edition)</cite></a>. Dave Reynolds.  W3C. 5 February 2013. W3C Working Group Note. URL: <a href="https://www.w3.org/TR/rif-owl-rl/">https://www.w3.org/TR/rif-owl-rl/</a>
    </dd><dt id="bib-rif-rdf-owl">[RIF-RDF-OWL]</dt><dd>
      <a href="https://www.w3.org/TR/rif-rdf-owl/"><cite>RIF RDF and OWL Compatibility (Second Edition)</cite></a>. Jos de Bruijn; Christopher Welty.  W3C. 5 February 2013. W3C Recommendation. URL: <a href="https://www.w3.org/TR/rif-rdf-owl/">https://www.w3.org/TR/rif-rdf-owl/</a>
    </dd><dt id="bib-sparql12-protocol">[SPARQL12-PROTOCOL]</dt><dd>
      <a href="https://w3c.github.io/sparql-protocol/spec/"><cite>SPARQL 1.2 Protocol</cite></a>. Lee Feigenbaum; Gregory Williams; Kendall Clark; Elias Torres.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/sparql-protocol/spec/">https://w3c.github.io/sparql-protocol/spec/</a>
    </dd><dt id="bib-sparql12-query">[SPARQL12-QUERY]</dt><dd>
      <a href="https://w3c.github.io/sparql-query/spec/"><cite>SPARQL 1.2 Query Language</cite></a>. Steven Harris; Andy Seaborne.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/sparql-query/spec/">https://w3c.github.io/sparql-query/spec/</a>
    </dd><dt id="bib-xmlschema11-2">[XMLSCHEMA11-2]</dt><dd>
      <a href="https://www.w3.org/TR/xmlschema11-2/"><cite>W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</cite></a>. David Peterson; Sandy Gao; Ashok Malhotra; Michael Sperberg-McQueen; Henry Thompson; Paul V. Biron et al.  W3C. 5 April 2012. W3C Recommendation. URL: <a href="https://www.w3.org/TR/xmlschema11-2/">https://www.w3.org/TR/xmlschema11-2/</a>
    </dd></dl>
  </section><section id="informative-references"><div class="header-wrapper"><h3 id="c-2-informative-references"><bdi class="secno">C.2 </bdi>Informative references</h3><a class="self-link" href="#informative-references" aria-label="Permalink for Appendix C.2"></a></div>
    
    <dl class="bibliography"><dt id="bib-horst05">[HORST05]</dt><dd>
      <a href="https://dx.doi.org/10.2139/ssrn.3199251"><cite>Completeness, Decidability and Complexity of Entailment for RDF Schema and a Semantic Extension Involving the OWL Vocabulary</cite></a>. Herman J. ter Horst.  Journal of Web Semantics. 2005. Conference Proceeding. URL: <a href="https://dx.doi.org/10.2139/ssrn.3199251">https://dx.doi.org/10.2139/ssrn.3199251</a>
    </dd><dt id="bib-owl2-overview">[OWL2-OVERVIEW]</dt><dd>
      <a href="https://www.w3.org/TR/owl2-overview/"><cite>OWL 2 Web Ontology Language Document Overview (Second Edition)</cite></a>. W3C OWL Working Group.  W3C. 11 December 2012. W3C Recommendation. URL: <a href="https://www.w3.org/TR/owl2-overview/">https://www.w3.org/TR/owl2-overview/</a>
    </dd><dt id="bib-safety">[SAFETY]</dt><dd>
      <a href="http://arxiv.org/abs/cs.LO/9809032"><cite>Saftety of recursive horn clauses with infinite relations</cite></a>. R. Ramakrishnan; F. Bancilhon; A. Silberschatz.  ACM New York. 1987. URL: <a href="http://arxiv.org/abs/cs.LO/9809032">http://arxiv.org/abs/cs.LO/9809032</a>
    </dd><dt id="bib-sparql12-concepts">[SPARQL12-CONCEPTS]</dt><dd>
      <a href="https://w3c.github.io/sparql-concepts/spec/"><cite>SPARQL 1.2 Concepts</cite></a>. The W3C RDF-star Working Group.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/sparql-concepts/spec/">https://w3c.github.io/sparql-concepts/spec/</a>
    </dd><dt id="bib-sparql12-federated-query">[SPARQL12-FEDERATED-QUERY]</dt><dd>
      <a href="https://w3c.github.io/sparql-federated-query/spec/"><cite>SPARQL 1.2 Federated Query</cite></a>. Eric Prud'hommeaux; Carlos Buil Aranda.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/sparql-federated-query/spec/">https://w3c.github.io/sparql-federated-query/spec/</a>
    </dd><dt id="bib-sparql12-graph-store-protocol">[SPARQL12-GRAPH-STORE-PROTOCOL]</dt><dd>
      <a href="https://w3c.github.io/sparql-graph-store-protocol/spec/"><cite>SPARQL 1.2 Graph Store HTTP Protocol</cite></a>. Chimezie Ogbuji.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/sparql-graph-store-protocol/spec/">https://w3c.github.io/sparql-graph-store-protocol/spec/</a>
    </dd><dt id="bib-sparql12-new">[SPARQL12-NEW]</dt><dd>
      <a href="https://w3c.github.io/sparql-new/spec/"><cite>What’s New in SPARQL 1.2</cite></a>. The W3C RDF-star Working Group.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/sparql-new/spec/">https://w3c.github.io/sparql-new/spec/</a>
    </dd><dt id="bib-sparql12-results-csv-tsv">[SPARQL12-RESULTS-CSV-TSV]</dt><dd>
      <a href="https://w3c.github.io/sparql-results-csv-tsv/spec/"><cite>SPARQL 1.2 Query Results CSV and TSV Formats</cite></a>. Andy Seaborne.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/sparql-results-csv-tsv/spec/">https://w3c.github.io/sparql-results-csv-tsv/spec/</a>
    </dd><dt id="bib-sparql12-results-json">[SPARQL12-RESULTS-JSON]</dt><dd>
      <a href="https://w3c.github.io/sparql-results-json/spec/"><cite>SPARQL 1.2 Query Results JSON Format</cite></a>. Andy Seaborne.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/sparql-results-json/spec/">https://w3c.github.io/sparql-results-json/spec/</a>
    </dd><dt id="bib-sparql12-results-xml">[SPARQL12-RESULTS-XML]</dt><dd>
      <a href="https://w3c.github.io/sparql-results-xml/spec/"><cite>SPARQL 1.2 Query Results XML Formats</cite></a>. Sandro Hawke; Dave Beckett; Jeen Broekstra.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/sparql-results-xml/spec/">https://w3c.github.io/sparql-results-xml/spec/</a>
    </dd><dt id="bib-sparql12-service-description">[SPARQL12-SERVICE-DESCRIPTION]</dt><dd>
      <a href="https://w3c.github.io/sparql-service-description/spec/"><cite>SPARQL 1.2 Service Description</cite></a>. Gregory Williams.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/sparql-service-description/spec/">https://w3c.github.io/sparql-service-description/spec/</a>
    </dd><dt id="bib-sparql12-update">[SPARQL12-UPDATE]</dt><dd>
      <a href="https://w3c.github.io/sparql-update/spec/"><cite>SPARQL 1.2 Update</cite></a>. Paula Gearon; Alexandre Passant; Axel Polleres.  W3C. W3C Working Draft. URL: <a href="https://w3c.github.io/sparql-update/spec/">https://w3c.github.io/sparql-update/spec/</a>
    </dd></dl>
  </section></section><p role="navigation" id="back-to-top">
    <a href="#title"><abbr title="Back to Top">↑</abbr></a>
  </p><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-owl-2-dl-ontology-document" aria-label="Links in this document to definition: OWL 2 DL ontology document">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-conformance/#Syntactic_Conformance" aria-label="Permalink for definition: OWL 2 DL ontology document. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-owl-2-dl-ontology-document-1" title="§ 7.2 The OWL 2 Direct Semantics Entailment Regime">§ 7.2 The OWL 2 Direct Semantics Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-owl-2-direct-semantics-entailment" aria-label="Links in this document to definition: OWL 2 Direct Semantics entailment">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-direct-semantics/#Inference_Problems" aria-label="Permalink for definition: OWL 2 Direct Semantics entailment. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-owl-2-direct-semantics-entailment-1" title="§ 1. Introduction">§ 1. Introduction</a> 
  </li><li>
    <a href="#ref-for-index-term-owl-2-direct-semantics-entailment-2" title="§ 7.2 The OWL 2 Direct Semantics Entailment Regime">§ 7.2 The OWL 2 Direct Semantics Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-canonical-parsing-process" aria-label="Links in this document to definition: canonical parsing process">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Extracting_Declarations_and_the_IRIs_of_the_Directly_Imported_Ontology_Documents" aria-label="Permalink for definition: canonical parsing process. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-canonical-parsing-process-1" title="§ 7.1.1 OWL Import Directives">§ 7.1.1 OWL Import Directives</a> 
  </li><li>
    <a href="#ref-for-index-term-canonical-parsing-process-2" title="§ 12. Appendix: Mapping from BGPs to the extended OWL 2 Structural Specification">§ 12. Appendix: Mapping from BGPs to the extended OWL 2 Structural Specification</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-mapping-the-queried-rdf-graph-into-an-owl-2-ontology" aria-label="Links in this document to definition: mapping the queried RDF graph into an OWL 2 ontology">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Mapping_from_RDF_Graphs_to_the_Structural_Specification" aria-label="Permalink for definition: mapping the queried RDF graph into an OWL 2 ontology. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-mapping-the-queried-rdf-graph-into-an-owl-2-ontology-1" title="§ 7.1 Introduction">§ 7.1 Introduction</a> 
  </li><li>
    <a href="#ref-for-index-term-mapping-the-queried-rdf-graph-into-an-owl-2-ontology-2" title="§ 12.1 Parsing BGPs into Objects of the Extended OWL 2 Structural Specification">§ 12.1 Parsing BGPs into Objects of the Extended OWL 2 Structural Specification</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-owl-2-rdf-based-semantics-entailment" aria-label="Links in this document to definition: OWL 2 RDF-Based Semantics entailment">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://validator.w3.org/checklink?hide_type=all&depth=&check=Check&uri=https://www.w3.org/TR/2023/WD-sparql12-entailment-20230606/" aria-label="Permalink for definition: OWL 2 RDF-Based Semantics entailment. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-owl-2-rdf-based-semantics-entailment-1" title="§ 1. Introduction">§ 1. Introduction</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-section-3-2" aria-label="Links in this document to definition: Section 3.2">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Populating_an_Ontology" aria-label="Permalink for definition: Section 3.2. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-section-3-2-1" title="§ 12.1 Parsing BGPs into Objects of the Extended OWL 2 Structural Specification">§ 12.1 Parsing BGPs into Objects of the Extended OWL 2 Structural Specification</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-table-12" aria-label="Links in this document to definition: Table 12">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-mapping-to-rdf/#Parsing_of_Expressions" aria-label="Permalink for definition: Table 12. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-table-12-1" title="§ 12.1 Parsing BGPs into Objects of the Extended OWL 2 Structural Specification">§ 12.1 Parsing BGPs into Objects of the Extended OWL 2 Structural Specification</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-implementation-using-rule-based-technologies" aria-label="Links in this document to definition: implementation using rule-based technologies">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-profiles/#Profile_Specification_3" aria-label="Permalink for definition: implementation using rule-based technologies. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-implementation-using-rule-based-technologies-1" title="§ 6.4.4 The OWL 2 RL Profile">§ 6.4.4 The OWL 2 RL Profile</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-owl-rl-rule" aria-label="Links in this document to definition: OWL RL rule">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-profiles/#Reasoning_in_OWL_2_RL_and_RDF_Graphs_using_Rules" aria-label="Permalink for definition: OWL RL rule. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-owl-rl-rule-1" title="§ 6.4.5 Computing Query Answers for the OWL 2 RL Profile with RDF-Based Semantics (Informative)">§ 6.4.5 Computing Query Answers for the OWL 2 RL Profile with RDF-Based Semantics (Informative)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-d-inconsistent" aria-label="Links in this document to definition: D-inconsistent">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-rdf-based-semantics/#def-owlconsistency" aria-label="Permalink for definition: D-inconsistent. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-d-inconsistent-1" title="§ 5. D-Entailment Regime">§ 5. D-Entailment Regime</a> <a href="#ref-for-index-term-d-inconsistent-2" title="Reference 2">(2)</a> 
  </li><li>
    <a href="#ref-for-index-term-d-inconsistent-3" title="§ 6. OWL 2 RDF-Based Semantics Entailment Regime">§ 6. OWL 2 RDF-Based Semantics Entailment Regime</a> <a href="#ref-for-index-term-d-inconsistent-4" title="Reference 2">(2)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-datatype-names" aria-label="Links in this document to definition: datatype names">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Datatype_Names" aria-label="Permalink for definition: datatype names. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-datatype-names-1" title="§ 6. OWL 2 RDF-Based Semantics Entailment Regime">§ 6. OWL 2 RDF-Based Semantics Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-datatype-names-2" title="§ 7.2 The OWL 2 Direct Semantics Entailment Regime">§ 7.2 The OWL 2 Direct Semantics Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-facet-names" aria-label="Links in this document to definition: facet names">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Facet_Names" aria-label="Permalink for definition: facet names. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-facet-names-1" title="§ 6. OWL 2 RDF-Based Semantics Entailment Regime">§ 6. OWL 2 RDF-Based Semantics Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-facet-names-2" title="§ 7.2 The OWL 2 Direct Semantics Entailment Regime">§ 7.2 The OWL 2 Direct Semantics Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-owl-2-rdf-based-datatype-map" aria-label="Links in this document to definition: OWL 2 RDF-Based datatype map">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-rdf-based-semantics/#def-owldatatypemap" aria-label="Permalink for definition: OWL 2 RDF-Based datatype map. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-owl-2-rdf-based-datatype-map-1" title="§ 6. OWL 2 RDF-Based Semantics Entailment Regime">§ 6. OWL 2 RDF-Based Semantics Entailment Regime</a> <a href="#ref-for-index-term-owl-2-rdf-based-datatype-map-2" title="Reference 2">(2)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-owl-2-rdf-based-entailment" aria-label="Links in this document to definition: OWL 2 RDF-Based Entailment">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Satisfaction.2C_Consistency_and_Entailment" aria-label="Permalink for definition: OWL 2 RDF-Based Entailment. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-owl-2-rdf-based-entailment-1" title="§ 6. OWL 2 RDF-Based Semantics Entailment Regime">§ 6. OWL 2 RDF-Based Semantics Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-owl-2-rdf-based-vocabulary" aria-label="Links in this document to definition: OWL 2 RDF-based vocabulary">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-rdf-based-semantics/#table-vocab-owl" aria-label="Permalink for definition: OWL 2 RDF-based vocabulary. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-owl-2-rdf-based-vocabulary-1" title="§ 6. OWL 2 RDF-Based Semantics Entailment Regime">§ 6. OWL 2 RDF-Based Semantics Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-owl-2-rdf-based-vocabulary-2" title="§ 7.2 The OWL 2 Direct Semantics Entailment Regime">§ 7.2 The OWL 2 Direct Semantics Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-sec-7-1" aria-label="Links in this document to definition: Sec. 7.1">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-rdf-based-semantics/#Example_on_Semantic_Differences" aria-label="Permalink for definition: Sec. 7.1. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-sec-7-1-1" title="§ 6.1 Entailments under the OWL 2 RDF-Based Semantics (Informative)">§ 6.1 Entailments under the OWL 2 RDF-Based Semantics (Informative)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-anonymous-individuals" aria-label="Links in this document to definition: anonymous individuals">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-syntax/#Anonymous_Individuals" aria-label="Permalink for definition: anonymous individuals. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-anonymous-individuals-1" title="§ 7.1 Introduction">§ 7.1 Introduction</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-following-requirement" aria-label="Links in this document to definition: following requirement">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-syntax/#The_Restrictions_on_the_Axiom_Closure" aria-label="Permalink for definition: following requirement. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-following-requirement-1" title="§ 7.3.1 BGP Constraints for OWL 2 DL">§ 7.3.1 BGP Constraints for OWL 2 DL</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-ontology" aria-label="Links in this document to definition: Ontology">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-syntax/#def_ontology" aria-label="Permalink for definition: Ontology. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-ontology-1" title="§ 12. Appendix: Mapping from BGPs to the extended OWL 2 Structural Specification">§ 12. Appendix: Mapping from BGPs to the extended OWL 2 Structural Specification</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-owl-2-functional-style-syntax-grammar" aria-label="Links in this document to definition: OWL 2 functional-style syntax grammar">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-syntax/#Appendix:_Complete_Grammar_.28Normative.29" aria-label="Permalink for definition: OWL 2 functional-style syntax grammar. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-owl-2-functional-style-syntax-grammar-1" title="§ 7.1.2 Extended Grammar for OWL 2 Direct Semantics BGPs">§ 7.1.2 Extended Grammar for OWL 2 Direct Semantics BGPs</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-structurally-equivalent" aria-label="Links in this document to definition: structurally equivalent">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-syntax/#Structural_Specification" aria-label="Permalink for definition: structurally equivalent. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-structurally-equivalent-1" title="§ 12. Appendix: Mapping from BGPs to the extended OWL 2 Structural Specification">§ 12. Appendix: Mapping from BGPs to the extended OWL 2 Structural Specification</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-table-5" aria-label="Links in this document to definition: Table 5">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/owl2-syntax/#Entity_Declarations_and_Typing" aria-label="Permalink for definition: Table 5. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-table-5-1" title="§ 7.3 Restrictions on Solutions (Informative)">§ 7.3 Restrictions on Solutions (Informative)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-blank-nodes" aria-label="Links in this document to definition: blank nodes">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-concepts/spec/#dfn-blank-node" aria-label="Permalink for definition: blank nodes. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-blank-nodes-1" title="§ 1.1.3 Preliminary Definitions">§ 1.1.3 Preliminary Definitions</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-datatype" aria-label="Links in this document to definition: datatype">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-concepts/spec/#section-Datatypes" aria-label="Permalink for definition: datatype. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-datatype-1" title="§ 5. D-Entailment Regime">§ 5. D-Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdf-graph-equivalence" aria-label="Links in this document to definition: RDF graph equivalence">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-concepts/spec/#section-graph-equality" aria-label="Permalink for definition: RDF graph equivalence. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdf-graph-equivalence-1" title="§ 1.3 Extensions to Basic Graph Pattern Matching">§ 1.3 Extensions to Basic Graph Pattern Matching</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdf-literals" aria-label="Links in this document to definition: RDF Literals">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-concepts/spec/#dfn-literal" aria-label="Permalink for definition: RDF Literals. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdf-literals-1" title="§ 1.1.3 Preliminary Definitions">§ 1.1.3 Preliminary Definitions</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdf-term" aria-label="Links in this document to definition: RDF term">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-concepts/spec/#dfn-rdf-term" aria-label="Permalink for definition: RDF term. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdf-term-1" title="§ 1.1.4 Result Descriptions">§ 1.1.4 Result Descriptions</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdfs-inconsistent" aria-label="Links in this document to definition: RDFS-inconsistent">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-concepts/spec/#dfn-inconsistent" aria-label="Permalink for definition: RDFS-inconsistent. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdfs-inconsistent-1" title="§ 4. RDFS Entailment Regime">§ 4. RDFS Entailment Regime</a> <a href="#ref-for-index-term-rdfs-inconsistent-2" title="Reference 2">(2)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-d-entailment" aria-label="Links in this document to definition: D-Entailment">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#D_entailment" aria-label="Permalink for definition: D-Entailment. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-d-entailment-1" title="§ 1. Introduction">§ 1. Introduction</a> 
  </li><li>
    <a href="#ref-for-index-term-d-entailment-2" title="§ 5. D-Entailment Regime">§ 5. D-Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-datatype-map" aria-label="Links in this document to definition: datatype map">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#dfn-datatype-map" aria-label="Permalink for definition: datatype map. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-datatype-map-1" title="§ 5. D-Entailment Regime">§ 5. D-Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdf-entailment" aria-label="Links in this document to definition: RDF entailment">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#rdf_entail" aria-label="Permalink for definition: RDF entailment. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdf-entailment-1" title="§ 1. Introduction">§ 1. Introduction</a> 
  </li><li>
    <a href="#ref-for-index-term-rdf-entailment-2" title="§ 2. RDF Entailment Regime">§ 2. RDF Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdf-schema-entailment" aria-label="Links in this document to definition: RDF Schema entailment">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#rdfs_entailment" aria-label="Permalink for definition: RDF Schema entailment. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdf-schema-entailment-1" title="§ 1. Introduction">§ 1. Introduction</a> 
  </li><li>
    <a href="#ref-for-index-term-rdf-schema-entailment-2" title="§ 3.1 Blank Nodes in the Queried Graph">§ 3.1 Blank Nodes in the Queried Graph</a> 
  </li><li>
    <a href="#ref-for-index-term-rdf-schema-entailment-3" title="§ 4. RDFS Entailment Regime">§ 4. RDFS Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-rdf-schema-entailment-4" title="§ 4.1 Inconsistencies (Informative)">§ 4.1 Inconsistencies (Informative)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdf-vocabulary" aria-label="Links in this document to definition: RDF vocabulary">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdf-vocabulary" aria-label="Permalink for definition: RDF vocabulary. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdf-vocabulary-1" title="§ 2. RDF Entailment Regime">§ 2. RDF Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdfd1" aria-label="Links in this document to definition: rdfD1">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfd1" aria-label="Permalink for definition: rdfD1. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdfd1-1" title="§ 1.2 Effects of Different Entailment Regimes">§ 1.2 Effects of Different Entailment Regimes</a> 
  </li><li>
    <a href="#ref-for-index-term-rdfd1-2" title="§ 3.2 Answers from Axiomatic Triples">§ 3.2 Answers from Axiomatic Triples</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdfs-entailment-rules" aria-label="Links in this document to definition: RDFS entailment rules">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#rdf_entailment_patterns" aria-label="Permalink for definition: RDFS entailment rules. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdfs-entailment-rules-1" title="§ 1.2 Effects of Different Entailment Regimes">§ 1.2 Effects of Different Entailment Regimes</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdfs-inference-rules" aria-label="Links in this document to definition: RDFS inference rules">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#rdfs_patterns" aria-label="Permalink for definition: RDFS inference rules. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdfs-inference-rules-1" title="§ 3.1 Blank Nodes in the Queried Graph">§ 3.1 Blank Nodes in the Queried Graph</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdfs-vocabulary" aria-label="Links in this document to definition: RDFS vocabulary">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfs-vocabulary" aria-label="Permalink for definition: RDFS vocabulary. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdfs-vocabulary-1" title="§ 4. RDFS Entailment Regime">§ 4. RDFS Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-rdfs-vocabulary-2" title="§ 5. D-Entailment Regime">§ 5. D-Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdfs3" aria-label="Links in this document to definition: rdfs3">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfs3" aria-label="Permalink for definition: rdfs3. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdfs3-1" title="§ 1.2 Effects of Different Entailment Regimes">§ 1.2 Effects of Different Entailment Regimes</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdfs9" aria-label="Links in this document to definition: rdfs9">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfs9" aria-label="Permalink for definition: rdfs9. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdfs9-1" title="§ 1.2 Effects of Different Entailment Regimes">§ 1.2 Effects of Different Entailment Regimes</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rule-rdfs7" aria-label="Links in this document to definition: rule rdfs7">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#dfn-rdfs7" aria-label="Permalink for definition: rule rdfs7. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
      <li>Not referenced in this document.</li>
    </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-simple-entailment-relation-between-rdf-graphs" aria-label="Links in this document to definition: simple entailment relation between RDF graphs">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#dfn-simply-entail" aria-label="Permalink for definition: simple entailment relation between RDF graphs. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-simple-entailment-relation-between-rdf-graphs-1" title="§ 1. Introduction">§ 1. Introduction</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-skolemization" aria-label="Links in this document to definition: Skolemization">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-semantics/spec/#skolemization" aria-label="Permalink for definition: Skolemization. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-skolemization-1" title="§ 2. RDF Entailment Regime">§ 2. RDF Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-skolemization-2" title="§ 4. RDFS Entailment Regime">§ 4. RDFS Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-skolemization-3" title="§ 5. D-Entailment Regime">§ 5. D-Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-skolemization-4" title="§ 6. OWL 2 RDF-Based Semantics Entailment Regime">§ 6. OWL 2 RDF-Based Semantics Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-skolemization-5" title="§ 7.2 The OWL 2 Direct Semantics Entailment Regime">§ 7.2 The OWL 2 Direct Semantics Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-skolemization-6" title="§ 8.1 (Simple) RIF Core Entailment Regime">§ 8.1 (Simple) RIF Core Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-turtle-abbreviations" aria-label="Links in this document to definition: Turtle abbreviations">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/rdf-turtle/spec/#" aria-label="Permalink for definition: Turtle abbreviations. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-turtle-abbreviations-1" title="§ 1.1.1 Graph Syntax">§ 1.1.1 Graph Syntax</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-model" aria-label="Links in this document to definition: model">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/rif-bld/#def-bld-model-formula" aria-label="Permalink for definition: model. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-model-1" title="§ 8. RIF Core Entailment">§ 8. RIF Core Entailment</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-presentation-syntax" aria-label="Links in this document to definition: presentation syntax">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/rif-bld/#EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-BLD_.28Informative.29" aria-label="Permalink for definition: presentation syntax. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-presentation-syntax-1" title="§ 8.1 (Simple) RIF Core Entailment Regime">§ 8.1 (Simple) RIF Core Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-safety-conditions" aria-label="Links in this document to definition: safety conditions">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/rif-core/#Safeness" aria-label="Permalink for definition: safety conditions. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-safety-conditions-1" title="§ 8.3 Finite Answer Set Conditions (Informative)">§ 8.3 Finite Answer Set Conditions (Informative)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-common-rif-rdf-interpretation" aria-label="Links in this document to definition: common RIF-RDF interpretation">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/rif-rdf-owl/#def-common-rif-rdf-interpretation" aria-label="Permalink for definition: common RIF-RDF interpretation. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-common-rif-rdf-interpretation-1" title="§ 8. RIF Core Entailment">§ 8. RIF Core Entailment</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-generalized-rdf-graphs" aria-label="Links in this document to definition: generalized RDF graphs">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/rif-rdf-owl/#def-generalized-rdf-graph" aria-label="Permalink for definition: generalized RDF graphs. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-generalized-rdf-graphs-1" title="§ 8. RIF Core Entailment">§ 8. RIF Core Entailment</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rif-rdf-combination" aria-label="Links in this document to definition: RIF-RDF combination">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/rif-rdf-owl/#def-rif-rdf-combination" aria-label="Permalink for definition: RIF-RDF combination. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rif-rdf-combination-1" title="§ 8.1 (Simple) RIF Core Entailment Regime">§ 8.1 (Simple) RIF Core Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rif-simple-entailment" aria-label="Links in this document to definition: RIF-Simple entailment">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/rif-rdf-owl/#def-simple-entails" aria-label="Permalink for definition: RIF-Simple entailment. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rif-simple-entailment-1" title="§ 1. Introduction">§ 1. Introduction</a> 
  </li><li>
    <a href="#ref-for-index-term-rif-simple-entailment-2" title="§ 8.1 (Simple) RIF Core Entailment Regime">§ 8.1 (Simple) RIF Core Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-satisfies" aria-label="Links in this document to definition: satisfies">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/rif-rdf-owl/#def-rif-rdf-satisfies" aria-label="Permalink for definition: satisfies. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-satisfies-1" title="§ 8. RIF Core Entailment">§ 8. RIF Core Entailment</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-malformedquery" aria-label="Links in this document to definition: MalformedQuery">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-protocol/spec/#select-malformed" aria-label="Permalink for definition: MalformedQuery. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-malformedquery-1" title="§ 2. RDF Entailment Regime">§ 2. RDF Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-malformedquery-2" title="§ 4. RDFS Entailment Regime">§ 4. RDFS Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-malformedquery-3" title="§ 5. D-Entailment Regime">§ 5. D-Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-malformedquery-4" title="§ 6. OWL 2 RDF-Based Semantics Entailment Regime">§ 6. OWL 2 RDF-Based Semantics Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-malformedquery-5" title="§ 7.2 The OWL 2 Direct Semantics Entailment Regime">§ 7.2 The OWL 2 Direct Semantics Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-malformedquery-6" title="§ 8.1 (Simple) RIF Core Entailment Regime">§ 8.1 (Simple) RIF Core Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-queryrequestrefused" aria-label="Links in this document to definition: QueryRequestRefused">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-protocol/spec/#select-refused" aria-label="Permalink for definition: QueryRequestRefused. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-queryrequestrefused-1" title="§ 2. RDF Entailment Regime">§ 2. RDF Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-queryrequestrefused-2" title="§ 4. RDFS Entailment Regime">§ 4. RDFS Entailment Regime</a> <a href="#ref-for-index-term-queryrequestrefused-3" title="Reference 2">(2)</a> 
  </li><li>
    <a href="#ref-for-index-term-queryrequestrefused-4" title="§ 5. D-Entailment Regime">§ 5. D-Entailment Regime</a> <a href="#ref-for-index-term-queryrequestrefused-5" title="Reference 2">(2)</a> 
  </li><li>
    <a href="#ref-for-index-term-queryrequestrefused-6" title="§ 6. OWL 2 RDF-Based Semantics Entailment Regime">§ 6. OWL 2 RDF-Based Semantics Entailment Regime</a> <a href="#ref-for-index-term-queryrequestrefused-7" title="Reference 2">(2)</a> 
  </li><li>
    <a href="#ref-for-index-term-queryrequestrefused-8" title="§ 7.2 The OWL 2 Direct Semantics Entailment Regime">§ 7.2 The OWL 2 Direct Semantics Entailment Regime</a> <a href="#ref-for-index-term-queryrequestrefused-9" title="Reference 2">(2)</a> 
  </li><li>
    <a href="#ref-for-index-term-queryrequestrefused-10" title="§ 8.1 (Simple) RIF Core Entailment Regime">§ 8.1 (Simple) RIF Core Entailment Regime</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-conditions" aria-label="Links in this document to definition: conditions">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-query/spec/#sparqlBGPExtend" aria-label="Permalink for definition: conditions. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-conditions-1" title="§ 1.3 Extensions to Basic Graph Pattern Matching">§ 1.3 Extensions to Basic Graph Pattern Matching</a> <a href="#ref-for-index-term-conditions-2" title="Reference 2">(2)</a> 
  </li><li>
    <a href="#ref-for-index-term-conditions-3" title="§ 9. Entailment Regimes and Data Sets (Informative)">§ 9. Entailment Regimes and Data Sets (Informative)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-definitions" aria-label="Links in this document to definition: definitions">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-query/spec/#initDefinitions" aria-label="Permalink for definition: definitions. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-definitions-1" title="§ 1.1.3 Preliminary Definitions">§ 1.1.3 Preliminary Definitions</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-evaluation-semantics" aria-label="Links in this document to definition: evaluation semantics">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-query/spec/#sparqlAlgebraEval" aria-label="Permalink for definition: evaluation semantics. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-evaluation-semantics-1" title="§ 10. Entailment Regimes and Property Paths (Informative)">§ 10. Entailment Regimes and Property Paths (Informative)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-property-paths" aria-label="Links in this document to definition: property paths">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-query/spec/#propertypaths" aria-label="Permalink for definition: property paths. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-property-paths-1" title="§ 10. Entailment Regimes and Property Paths (Informative)">§ 10. Entailment Regimes and Property Paths (Informative)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-rdf-datasets" aria-label="Links in this document to definition: RDF datasets">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-query/spec/#rdfDataset" aria-label="Permalink for definition: RDF datasets. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-rdf-datasets-1" title="§ 8.4.2.2 Encoding RIF documents within named graphs in the dataset">§ 8.4.2.2 Encoding RIF documents within named graphs in the dataset</a> 
  </li><li>
    <a href="#ref-for-index-term-rdf-datasets-2" title="§ 9. Entailment Regimes and Data Sets (Informative)">§ 9. Entailment Regimes and Data Sets (Informative)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-scoping-graph" aria-label="Links in this document to definition: scoping graph">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-query/spec/#BGPsparqlBNodes" aria-label="Permalink for definition: scoping graph. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-scoping-graph-1" title="§ 1.3 Extensions to Basic Graph Pattern Matching">§ 1.3 Extensions to Basic Graph Pattern Matching</a> <a href="#ref-for-index-term-scoping-graph-2" title="Reference 2">(2)</a> <a href="#ref-for-index-term-scoping-graph-3" title="Reference 3">(3)</a> <a href="#ref-for-index-term-scoping-graph-4" title="Reference 4">(4)</a> 
  </li><li>
    <a href="#ref-for-index-term-scoping-graph-5" title="§ 2. RDF Entailment Regime">§ 2. RDF Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-scoping-graph-6" title="§ 4. RDFS Entailment Regime">§ 4. RDFS Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-scoping-graph-7" title="§ 5. D-Entailment Regime">§ 5. D-Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-scoping-graph-8" title="§ 6. OWL 2 RDF-Based Semantics Entailment Regime">§ 6. OWL 2 RDF-Based Semantics Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-scoping-graph-9" title="§ 7.2 The OWL 2 Direct Semantics Entailment Regime">§ 7.2 The OWL 2 Direct Semantics Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-scoping-graph-10" title="§ 8.1 (Simple) RIF Core Entailment Regime">§ 8.1 (Simple) RIF Core Entailment Regime</a> 
  </li><li>
    <a href="#ref-for-index-term-scoping-graph-11" title="§ 13. Appendix: Proofs">§ 13. Appendix: Proofs</a> <a href="#ref-for-index-term-scoping-graph-12" title="Reference 2">(2)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-simplified" aria-label="Links in this document to definition: simplified">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-query/spec/#sparqlTranslatePathPatterns" aria-label="Permalink for definition: simplified. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-simplified-1" title="§ 10. Entailment Regimes and Property Paths (Informative)">§ 10. Entailment Regimes and Property Paths (Informative)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-sparql-grammar" aria-label="Links in this document to definition: SPARQL grammar">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-query/spec/#grammar" aria-label="Permalink for definition: SPARQL grammar. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-sparql-grammar-1" title="§ 7.1.2 Extended Grammar for OWL 2 Direct Semantics BGPs">§ 7.1.2 Extended Grammar for OWL 2 Direct Semantics BGPs</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-the-sparql-triple-patterns-definition" aria-label="Links in this document to definition: the SPARQL triple patterns definition">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-query/spec/#sparqlTriplePatterns" aria-label="Permalink for definition: the SPARQL triple patterns definition. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-the-sparql-triple-patterns-definition-1" title="§ 3.3 Literals in the Subject Position">§ 3.3 Literals in the Subject Position</a> <a href="#ref-for-index-term-the-sparql-triple-patterns-definition-2" title="Reference 2">(2)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-translated-to-algebra-objects" aria-label="Links in this document to definition: translated to algebra objects">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-query/spec/#sparqlTranslatePathExpressions" aria-label="Permalink for definition: translated to algebra objects. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-translated-to-algebra-objects-1" title="§ 10. Entailment Regimes and Property Paths (Informative)">§ 10. Entailment Regimes and Property Paths (Informative)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-var" aria-label="Links in this document to definition: Var">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-query/spec/#rVar" aria-label="Permalink for definition: Var. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-var-1" title="§ 7.1.2 Extended Grammar for OWL 2 Direct Semantics BGPs">§ 7.1.2 Extended Grammar for OWL 2 Direct Semantics BGPs</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-variable" aria-label="Links in this document to definition: variable">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://w3c.github.io/sparql-query/spec/#defn_QueryVariable" aria-label="Permalink for definition: variable. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-variable-1" title="§ 1.1.4 Result Descriptions">§ 1.1.4 Result Descriptions</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-decimal" aria-label="Links in this document to definition: decimal">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/xmlschema11-2/#decimal" aria-label="Permalink for definition: decimal. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-decimal-1" title="§ 5.2 XML Schema Datatypes and Canonical Lexical Representations">§ 5.2 XML Schema Datatypes and Canonical Lexical Representations</a> <a href="#ref-for-index-term-decimal-2" title="Reference 2">(2)</a> <a href="#ref-for-index-term-decimal-3" title="Reference 3">(3)</a> <a href="#ref-for-index-term-decimal-4" title="Reference 4">(4)</a> <a href="#ref-for-index-term-decimal-5" title="Reference 5">(5)</a> <a href="#ref-for-index-term-decimal-6" title="Reference 6">(6)</a> <a href="#ref-for-index-term-decimal-7" title="Reference 7">(7)</a> <a href="#ref-for-index-term-decimal-8" title="Reference 8">(8)</a> 
  </li>
  </ul>
    </div><div class="dfn-panel" hidden="" role="dialog" aria-modal="true" id="dfn-panel-for-index-term-xsd-1-0" aria-label="Links in this document to definition: XSD 1.0">
      <span class="caret"></span>
      <div>
        <a class="self-link" href="https://www.w3.org/TR/xmlschema11-2/#integer" aria-label="Permalink for definition: XSD 1.0. Activate to close this dialog.">Permalink</a>
         
      </div>
      <p><b>Referenced in:</b></p>
      <ul>
    <li>
    <a href="#ref-for-index-term-xsd-1-0-1" title="§ 5.2 XML Schema Datatypes and Canonical Lexical Representations">§ 5.2 XML Schema Datatypes and Canonical Lexical Representations</a> 
  </li>
  </ul>
    </div><script id="respec-dfn-panel">(() => {
// @ts-check
if (document.respec) {
  document.respec.ready.then(setupPanel);
} else {
  setupPanel();
}

function setupPanel() {
  const listener = panelListener();
  document.body.addEventListener("keydown", listener);
  document.body.addEventListener("click", listener);
}

function panelListener() {
  /** @type {HTMLElement} */
  let panel = null;
  return event => {
    const { target, type } = event;

    if (!(target instanceof HTMLElement)) return;

    // For keys, we only care about Enter key to activate the panel
    // otherwise it's activated via a click.
    if (type === "keydown" && event.key !== "Enter") return;

    const action = deriveAction(event);

    switch (action) {
      case "show": {
        hidePanel(panel);
        /** @type {HTMLElement} */
        const dfn = target.closest("dfn, .index-term");
        panel = document.getElementById(`dfn-panel-for-${dfn.id}`);
        const coords = deriveCoordinates(event);
        displayPanel(dfn, panel, coords);
        break;
      }
      case "dock": {
        panel.style.left = null;
        panel.style.top = null;
        panel.classList.add("docked");
        break;
      }
      case "hide": {
        hidePanel(panel);
        panel = null;
        break;
      }
    }
  };
}

/**
 * @param {MouseEvent|KeyboardEvent} event
 */
function deriveCoordinates(event) {
  const target = /** @type HTMLElement */ (event.target);

  // We prevent synthetic AT clicks from putting
  // the dialog in a weird place. The AT events sometimes
  // lack coordinates, so they have clientX/Y = 0
  const rect = target.getBoundingClientRect();
  if (
    event instanceof MouseEvent &&
    event.clientX >= rect.left &&
    event.clientY >= rect.top
  ) {
    // The event probably happened inside the bounding rect...
    return { x: event.clientX, y: event.clientY };
  }

  // Offset to the middle of the element
  const x = rect.x + rect.width / 2;
  // Placed at the bottom of the element
  const y = rect.y + rect.height;
  return { x, y };
}

/**
 * @param {Event} event
 */
function deriveAction(event) {
  const target = /** @type {HTMLElement} */ (event.target);
  const hitALink = !!target.closest("a");
  if (target.closest("dfn:not([data-cite]), .index-term")) {
    return hitALink ? "none" : "show";
  }
  if (target.closest(".dfn-panel")) {
    if (hitALink) {
      return target.classList.contains("self-link") ? "hide" : "dock";
    }
    const panel = target.closest(".dfn-panel");
    return panel.classList.contains("docked") ? "hide" : "none";
  }
  if (document.querySelector(".dfn-panel:not([hidden])")) {
    return "hide";
  }
  return "none";
}

/**
 * @param {HTMLElement} dfn
 * @param {HTMLElement} panel
 * @param {{ x: number, y: number }} clickPosition
 */
function displayPanel(dfn, panel, { x, y }) {
  panel.hidden = false;
  // distance (px) between edge of panel and the pointing triangle (caret)
  const MARGIN = 20;

  const dfnRects = dfn.getClientRects();
  // Find the `top` offset when the `dfn` can be spread across multiple lines
  let closestTop = 0;
  let minDiff = Infinity;
  for (const rect of dfnRects) {
    const { top, bottom } = rect;
    const diffFromClickY = Math.abs((top + bottom) / 2 - y);
    if (diffFromClickY < minDiff) {
      minDiff = diffFromClickY;
      closestTop = top;
    }
  }

  const top = window.scrollY + closestTop + dfnRects[0].height;
  const left = x - MARGIN;
  panel.style.left = `${left}px`;
  panel.style.top = `${top}px`;

  // Find if the panel is flowing out of the window
  const panelRect = panel.getBoundingClientRect();
  const SCREEN_WIDTH = Math.min(window.innerWidth, window.screen.width);
  if (panelRect.right > SCREEN_WIDTH) {
    const newLeft = Math.max(MARGIN, x + MARGIN - panelRect.width);
    const newCaretOffset = left - newLeft;
    panel.style.left = `${newLeft}px`;
    /** @type {HTMLElement} */
    const caret = panel.querySelector(".caret");
    caret.style.left = `${newCaretOffset}px`;
  }

  // As it's a dialog, we trap focus.
  // TODO: when <dialog> becomes a implemented, we should really
  // use that.
  trapFocus(panel, dfn);
}

/**
 * @param {HTMLElement} panel
 * @param {HTMLElement} dfn
 * @returns
 */
function trapFocus(panel, dfn) {
  /** @type NodeListOf<HTMLAnchorElement> elements */
  const anchors = panel.querySelectorAll("a[href]");
  // No need to trap focus
  if (!anchors.length) return;

  // Move focus to first anchor element
  const first = anchors.item(0);
  first.focus();

  const trapListener = createTrapListener(anchors, panel, dfn);
  panel.addEventListener("keydown", trapListener);

  // Hiding the panel releases the trap
  const mo = new MutationObserver(records => {
    const [record] = records;
    const target = /** @type HTMLElement */ (record.target);
    if (target.hidden) {
      panel.removeEventListener("keydown", trapListener);
      mo.disconnect();
    }
  });
  mo.observe(panel, { attributes: true, attributeFilter: ["hidden"] });
}

/**
 *
 * @param {NodeListOf<HTMLAnchorElement>} anchors
 * @param {HTMLElement} panel
 * @param {HTMLElement} dfn
 * @returns
 */
function createTrapListener(anchors, panel, dfn) {
  const lastIndex = anchors.length - 1;
  let currentIndex = 0;
  return event => {
    switch (event.key) {
      // Hitting "Tab" traps us in a nice loop around elements.
      case "Tab": {
        event.preventDefault();
        currentIndex += event.shiftKey ? -1 : +1;
        if (currentIndex < 0) {
          currentIndex = lastIndex;
        } else if (currentIndex > lastIndex) {
          currentIndex = 0;
        }
        anchors.item(currentIndex).focus();
        break;
      }

      // Hitting "Enter" on an anchor releases the trap.
      case "Enter":
        hidePanel(panel);
        break;

      // Hitting "Escape" returns focus to dfn.
      case "Escape":
        hidePanel(panel);
        dfn.focus();
        return;
    }
  };
}

/** @param {HTMLElement} panel */
function hidePanel(panel) {
  if (!panel) return;
  panel.hidden = true;
  panel.classList.remove("docked");
}
})()</script><script src="https://www.w3.org/scripts/TR/2021/fixup.js"></script></body></html>
